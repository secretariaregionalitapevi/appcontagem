/* =========================================================================
   app.js ‚Äî Registro de Presen√ßas
   ========================================================================= */

   console.log('üö®üö®üö® ARQUIVO APP.JS CARREGADO - VERS√ÉO ATUALIZADA! üö®üö®üö®');

   // === CONFIGURA√á√ÉO DE TIMEZONE ===
   const TIMEZONE = 'America/Sao_Paulo';
   const SYNC_INTERVAL_MS = 10000; // tenta esvaziar a fila a cada 10s
   
   // === CONFIGURA√á√ïES DE BACKUP AUTOM√ÅTICO ===
   const BACKUP_CONFIG = {
     interval: 24 * 60 * 60 * 1000, // 24 horas em millisegundos
     retention: 7, // Manter 7 backups
     autoBackup: true, // Backup autom√°tico ativado
     compress: true, // Comprimir backups para economizar espa√ßo
     includeQueue: true, // Incluir fila offline no backup
     includeSettings: true // Incluir configura√ß√µes do usu√°rio
   };
   
   // Chaves do localStorage para backup
   const BACKUP_KEYS = [
     'fila_envio',
     'session_user',
     'session_role', 
     'session_local',
     'current_user_id',
     'current_user_name',
     'user_preferences',
     'offline_data',
     'backup_settings'
   ];
   
   // === CONFIGURA√á√ïES MOBILE E DESKTOP =====
   // üõ°Ô∏è DETEC√á√ÉO PRECISA DE PLATAFORMA - CORRIGIDA PARA EVITAR FALSOS POSITIVOS
   if (typeof isMobile === 'undefined') {
     // Detec√ß√£o mais precisa: apenas dispositivos m√≥veis reais
     var isMobile = (
       /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) &&
       // Excluir iPads em modo desktop (macOS)
       !(navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1 && window.screen.width > 1024) &&
       // Excluir navegadores desktop que podem ter user agent mobile
       !(window.screen.width > 1024 && window.screen.height > 768 && !navigator.maxTouchPoints)
     );
   }
   if (typeof isDesktop === 'undefined') {
     // Desktop √© o oposto de mobile, mas com verifica√ß√£o adicional
     var isDesktop = !isMobile && (
       window.screen.width > 1024 || 
       navigator.platform.includes('Win') || 
       navigator.platform.includes('Mac') || 
       navigator.platform.includes('Linux')
     );
   }
   if (typeof isIOS === 'undefined') {
     var isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && isMobile;
   }
  if (typeof isAndroid === 'undefined') {
    var isAndroid = /Android/.test(navigator.userAgent) && isMobile;
  }
  
  // üõ°Ô∏è DETEC√á√ÉO ESPEC√çFICA XIAOMI/MIUI - CR√çTICO PARA COMPATIBILIDADE
  if (typeof isXiaomi === 'undefined') {
    var isXiaomi = /Xiaomi|MIUI|Redmi/i.test(navigator.userAgent) || 
                   /Mi\s/i.test(navigator.userAgent) ||
                   /POCO/i.test(navigator.userAgent) ||
                   /Redmi.*Note.*13/i.test(navigator.userAgent) ||
                   /Note.*13/i.test(navigator.userAgent);
  }
  
  // üõ°Ô∏è DETEC√á√ÉO ESPEC√çFICA REDMI NOTE 13 - Garantir compatibilidade
  if (typeof isRedmiNote13 === 'undefined') {
    var isRedmiNote13 = /Redmi.*Note.*13/i.test(navigator.userAgent) ||
                        /Note.*13.*Redmi/i.test(navigator.userAgent) ||
                        /23021RAAEG|23021RAAEI|23021RAAER/i.test(navigator.userAgent); // C√≥digos de modelo do Redmi Note 13
  }
  
  // üõ°Ô∏è DETEC√á√ÉO DE VERS√ÉO MIUI (importante para problemas de localStorage)
  if (typeof miuiVersion === 'undefined') {
    var miuiVersion = null;
    const miuiMatch = navigator.userAgent.match(/MIUI[\/\s]?([\d.]+)/i);
    if (miuiMatch) {
      miuiVersion = miuiMatch[1];
    }
  }
  
  if (typeof isStandalone === 'undefined') {
    var isStandalone = window.matchMedia('(display-mode: standalone)').matches || 
                       window.navigator.standalone === true;
  }
  
  // üõ°Ô∏è LOG DE DETEC√á√ÉO DE PLATAFORMA PARA DEBUG
  if (isXiaomi) {
    console.log('üì± XIAOMI/MIUI DETECTADO:', {
      userAgent: navigator.userAgent,
      miuiVersion: miuiVersion,
      isAndroid: isAndroid,
      isMobile: isMobile,
      isRedmiNote13: isRedmiNote13
    });
  }
  
  // üõ°Ô∏è LOG ESPEC√çFICO REDMI NOTE 13
  if (isRedmiNote13) {
    console.log('üì± REDMI NOTE 13 DETECTADO - Configura√ß√µes espec√≠ficas aplicadas:', {
      userAgent: navigator.userAgent,
      miuiVersion: miuiVersion,
      isXiaomi: isXiaomi,
      isAndroid: isAndroid,
      isMobile: isMobile
    });
  }
   
   // Detectar ambiente de execu√ß√£o
   const isFileProtocol = window.location.protocol === 'file:';
   const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
   
   // üîß SISTEMA DE VERSIONAMENTO
   const APP_VERSION = '1.1.2'; // Vers√£o atual do sistema
   const VERSION_STORAGE_KEY = 'ccb_app_version';
   
   // üöÄ SISTEMA DE CONTROLE DE LOGS PARA PRODU√á√ÉO
   // Detectar ambiente de produ√ß√£o
   const IS_PRODUCTION = window.location.hostname !== 'localhost' && 
                        window.location.hostname !== '127.0.0.1' && 
                        window.location.protocol !== 'file:' &&
                        !window.location.search.includes('debug=true');
   
   // Configura√ß√£o de logs baseada no ambiente
   const LOG_CONFIG = {
     production: {
       enabled: false, // Desabilitar logs em produ√ß√£o
       error: true,    // Manter apenas erros
       warn: true,     // Manter warnings
       info: false,    // Desabilitar info
       debug: false    // Desabilitar debug
     },
     development: {
       enabled: true,
       error: true,
       warn: true,
       info: true,
       debug: true
     }
   };
   
   const currentLogConfig = IS_PRODUCTION ? LOG_CONFIG.production : LOG_CONFIG.development;
   
   // üöÄ FUN√á√ÉO OTIMIZADA DE LOG (substitui console.log em produ√ß√£o)
   const safeLog = {
     debug: (...args) => {
       if (currentLogConfig.debug) console.log(...args);
     },
     info: (...args) => {
       if (currentLogConfig.info) console.log(...args);
     },
     warn: (...args) => {
       if (currentLogConfig.warn) console.warn(...args);
     },
     error: (...args) => {
       if (currentLogConfig.error) console.error(...args);
     },
     log: (...args) => {
       // Logs com emoji de debug s√£o considerados debug
       const firstArg = args[0];
       if (typeof firstArg === 'string' && (firstArg.includes('üîç') || firstArg.includes('üì±') || firstArg.includes('üéØ'))) {
         if (currentLogConfig.debug) console.log(...args);
       } else if (typeof firstArg === 'string' && (firstArg.includes('‚ùå') || firstArg.includes('üö®'))) {
         if (currentLogConfig.error) console.error(...args);
       } else if (typeof firstArg === 'string' && firstArg.includes('‚ö†Ô∏è')) {
         if (currentLogConfig.warn) console.warn(...args);
       } else {
         if (currentLogConfig.info) console.log(...args);
       }
     }
   };
   
   // Expor globalmente para uso
   window.safeLog = safeLog;
   window.IS_PRODUCTION = IS_PRODUCTION;
   const LAST_UPDATE_CHECK_KEY = 'ccb_last_update_check';
   const isHTTPS = window.location.protocol === 'https:';
   
   // üîß Fun√ß√£o para verificar se h√° nova vers√£o dispon√≠vel
   function verificarNovaVersao() {
     try {
       const versaoArmazenada = localStorage.getItem(VERSION_STORAGE_KEY);
       const versaoAtual = APP_VERSION;
       
       // Se n√£o h√° vers√£o armazenada, armazenar a atual
       if (!versaoArmazenada) {
         localStorage.setItem(VERSION_STORAGE_KEY, versaoAtual);
         return false; // Primeira vez, n√£o mostrar alerta
       }
       
       // Comparar vers√µes (formato: X.Y.Z)
       const compararVersoes = (v1, v2) => {
         const partes1 = v1.split('.').map(Number);
         const partes2 = v2.split('.').map(Number);
         
         for (let i = 0; i < Math.max(partes1.length, partes2.length); i++) {
           const parte1 = partes1[i] || 0;
           const parte2 = partes2[i] || 0;
           if (parte1 > parte2) return 1;
           if (parte1 < parte2) return -1;
         }
         return 0;
       };
       
       const comparacao = compararVersoes(versaoAtual, versaoArmazenada);
       
       // Se a vers√£o atual √© maior que a armazenada, h√° nova vers√£o
       if (comparacao > 0) {
         return true; // H√° nova vers√£o
       }
       
       return false; // Mesma vers√£o ou vers√£o antiga
     } catch (error) {
       console.error('‚ùå Erro ao verificar vers√£o:', error);
       return false;
     }
   }
   
   // üîß Fun√ß√£o para mostrar alerta de nova vers√£o
   async function mostrarAlertaNovaVersao() {
     try {
       // Verificar se SweetAlert2 est√° dispon√≠vel
       if (typeof Swal === 'undefined') {
         console.log('‚ö†Ô∏è SweetAlert2 n√£o dispon√≠vel - usando alert nativo');
         const atualizar = confirm('üÜï Nova vers√£o dispon√≠vel!\n\nDeseja atualizar agora?');
         if (atualizar) {
           atualizarAplicacao();
         }
         return;
       }
       
       const result = await Swal.fire({
         title: 'üÜï Nova Vers√£o Dispon√≠vel!',
         html: `
           <div style="text-align: left;">
             <p><strong>Vers√£o ${APP_VERSION}</strong> est√° dispon√≠vel!</p>
             <p>Recomendamos atualizar para ter acesso √†s melhorias e corre√ß√µes mais recentes.</p>
             <br>
             <small>‚ú® Melhorias de performance<br>
             üêõ Corre√ß√µes de bugs<br>
             üé® Melhorias visuais</small>
           </div>
         `,
         icon: 'info',
         showCancelButton: true,
         confirmButtonText: '<i class="fa-solid fa-download"></i> Atualizar Agora',
         cancelButtonText: '<i class="fa-solid fa-times"></i> Depois',
         confirmButtonColor: '#007bff',
         cancelButtonColor: '#6c757d',
         reverseButtons: true,
         width: '500px',
         padding: '2rem',
         position: 'center',
         backdrop: true,
         allowOutsideClick: false,
         allowEscapeKey: true,
         focusConfirm: false,
         focusCancel: false,
         buttonsStyling: true,
         customClass: {
           popup: 'swal-version-popup',
           title: 'swal-version-title',
           content: 'swal-version-content',
           container: 'swal-version-container',
           confirmButton: 'swal-version-confirm',
           cancelButton: 'swal-version-cancel'
         },
         didOpen: () => {
           // Garantir que o modal est√° vis√≠vel
           const popup = document.querySelector('.swal-version-popup, .swal2-popup');
           if (popup) {
             popup.style.cssText = `
               z-index: 1000000 !important;
               position: relative !important;
               margin: 0 !important;
               width: 500px !important;
               max-width: 90vw !important;
               display: block !important;
               visibility: visible !important;
               opacity: 1 !important;
               pointer-events: auto !important;
             `;
           }
           
           // Garantir que os bot√µes tenham o mesmo tamanho
           setTimeout(() => {
             const confirmBtn = document.querySelector('.swal-version-confirm, .swal2-confirm');
             const cancelBtn = document.querySelector('.swal-version-cancel, .swal2-cancel');
             
             if (confirmBtn && cancelBtn) {
               const confirmWidth = confirmBtn.offsetWidth;
               const cancelWidth = cancelBtn.offsetWidth;
               const maxWidth = Math.max(confirmWidth, cancelWidth);
               
               confirmBtn.style.width = `${maxWidth}px`;
               confirmBtn.style.minWidth = `${maxWidth}px`;
               cancelBtn.style.width = `${maxWidth}px`;
               cancelBtn.style.minWidth = `${maxWidth}px`;
             }
           }, 100);
         }
       });
       
       if (result.isConfirmed) {
         // Usu√°rio confirmou atualiza√ß√£o
         atualizarAplicacao();
       } else {
         // Usu√°rio cancelou - armazenar vers√£o atual para n√£o mostrar novamente nesta sess√£o
         localStorage.setItem(VERSION_STORAGE_KEY, APP_VERSION);
         localStorage.setItem(LAST_UPDATE_CHECK_KEY, Date.now().toString());
       }
     } catch (error) {
       console.error('‚ùå Erro ao mostrar alerta de nova vers√£o:', error);
     }
   }
   
   // üîß Fun√ß√£o para atualizar a aplica√ß√£o
   function atualizarAplicacao() {
     console.log('üîÑ Iniciando atualiza√ß√£o da aplica√ß√£o...');
     
     // Mostrar loading
     if (typeof Swal !== 'undefined') {
       Swal.fire({
         title: 'Atualizando...',
         html: 'Recarregando a aplica√ß√£o com a nova vers√£o',
         icon: 'info',
         allowOutsideClick: false,
         allowEscapeKey: false,
         showConfirmButton: false,
         didOpen: () => {
           Swal.showLoading();
         }
       });
     }
     
     // Limpar cache e recarregar ap√≥s um pequeno delay
     setTimeout(() => {
       // Limpar service workers se existirem
       if ('serviceWorker' in navigator) {
         navigator.serviceWorker.getRegistrations().then(registrations => {
           registrations.forEach(registration => {
             registration.unregister();
           });
         });
       }
       
       // Limpar caches do navegador
       if ('caches' in window) {
         caches.keys().then(cacheNames => {
           return Promise.all(cacheNames.map(cacheName => caches.delete(cacheName)));
         });
       }
       
       // Limpar localStorage de cache (manter dados importantes)
       const keysToKeep = ['session_user', 'session_role', 'session_local', 'theme'];
       const allKeys = Object.keys(localStorage);
       allKeys.forEach(key => {
         if (!keysToKeep.includes(key) && !key.startsWith('ccb_')) {
           localStorage.removeItem(key);
         }
       });
       
       // Atualizar vers√£o armazenada
       localStorage.setItem(VERSION_STORAGE_KEY, APP_VERSION);
       localStorage.setItem(LAST_UPDATE_CHECK_KEY, Date.now().toString());
       
       // Recarregar p√°gina com cache limpo
       window.location.reload(true);
     }, 1500);
   }
   
   // üõ°Ô∏è FUN√á√ÉO PARA GARANTIR COMPATIBILIDADE EM DESENVOLVIMENTO
   function ensureDevelopmentCompatibility() {
     console.log('üîß Verificando compatibilidade de desenvolvimento...');
     
     // Log do ambiente atual
     console.log('üåê Ambiente detectado:', {
       protocol: window.location.protocol,
       hostname: window.location.hostname,
       isFileProtocol,
       isLocalhost,
       isHTTPS,
       isMobile,
       isDesktop,
       userAgent: navigator.userAgent
     });
     
     // Configura√ß√µes espec√≠ficas para desenvolvimento local
     if (isFileProtocol) {
       console.log('üìÅ Modo arquivo local - aplicando configura√ß√µes de desenvolvimento');
       
       // Desabilitar Service Worker em file://
       if ('serviceWorker' in navigator) {
         navigator.serviceWorker.getRegistrations().then(registrations => {
           registrations.forEach(registration => {
             registration.unregister();
             console.log('üóëÔ∏è Service Worker desregistrado para desenvolvimento local');
           });
         });
       }
       
       // Configurar para funcionar offline
       window.DEVELOPMENT_MODE = true;
       console.log('‚úÖ Modo de desenvolvimento ativado');
     }
     
     // Configura√ß√µes para localhost
     if (isLocalhost) {
       console.log('üè† Modo localhost - aplicando configura√ß√µes de desenvolvimento');
       window.DEVELOPMENT_MODE = true;
     }
     
     console.log('‚úÖ Compatibilidade de desenvolvimento verificada');
   }
   const isHTTP = window.location.protocol === 'http:';
   
   // Log detalhado da detec√ß√£o de plataforma
   console.log('üîç DETEC√á√ÉO DE PLATAFORMA:', {
     isMobile,
     isDesktop,
     isIOS,
     isAndroid,
     isStandalone,
     userAgent: navigator.userAgent,
     platform: navigator.platform,
     screenWidth: window.screen.width,
     screenHeight: window.screen.height,
     maxTouchPoints: navigator.maxTouchPoints,
     protocol: window.location.protocol
   });
   
   // Verifica√ß√£o adicional para garantir detec√ß√£o correta
   if (isMobile && isDesktop) {
     console.warn('‚ö†Ô∏è CONFLITO: Sistema detectado como mobile E desktop simultaneamente!');
     console.warn('üîß For√ßando detec√ß√£o como desktop...');
     var isMobile = false;
     var isDesktop = true;
   }
   
   console.log('‚úÖ PLATAFORMA FINAL DETECTADA:', {
     isMobile,
     isDesktop,
     tipo: isMobile ? 'MOBILE' : 'DESKTOP'
   });
   
   console.log('üåê Ambiente de Execu√ß√£o:', {
     protocol: window.location.protocol,
     hostname: window.location.hostname,
     isFileProtocol,
     isLocalhost,
     isHTTPS,
     isHTTP,
     url: window.location.href
   });
   
   // === CONFIGURA√á√ÉO DO ENDPOINT ===
   const ENDPOINT = "https://script.google.com/macros/s/AKfycbxPtvi86jPy7y41neTpIPvn3hpycd3cMjbgjgifzLD6qRwrJVPlF9EDulaQp42nma-i/exec";
   
   // === SISTEMA DE FILA OFFLINE ROBUSTO PARA MOBILE ===
   const OFFLINE_QUEUE_KEY = 'offline_queue_v3';
   const SYNC_INTERVAL = isMobile ? 15000 : 10000; // 15s para mobile, 10s para desktop
   let syncIntervalId = null;
   
  // üõ°Ô∏è FUN√á√ÉO CR√çTICA: Verificar se localStorage est√° dispon√≠vel (COMPATIBILIDADE MULTIPLATAFORMA)
  // üõ°Ô∏è MELHORADO PARA XIAOMI/MIUI - Problemas conhecidos com localStorage em algumas vers√µes
  function isLocalStorageAvailable() {
     try {
       // Verificar se localStorage existe
       if (typeof localStorage === 'undefined') {
         console.warn('‚ö†Ô∏è localStorage n√£o est√° dispon√≠vel nesta plataforma');
         return false;
       }
       
       // üõ°Ô∏è XIAOMI/MIUI: Teste mais robusto para detectar problemas espec√≠ficos
       const test = '__localStorage_test__';
       const testValue = '__test_value_' + Date.now();
       
       try {
         localStorage.setItem(test, testValue);
         const retrieved = localStorage.getItem(test);
         localStorage.removeItem(test);
         
         // Verificar se o valor foi recuperado corretamente
         if (retrieved !== testValue) {
           console.warn('‚ö†Ô∏è localStorage n√£o est√° funcionando corretamente (valor n√£o corresponde)');
           if (isXiaomi) {
             console.warn('‚ö†Ô∏è XIAOMI/MIUI: Problema conhecido com localStorage - usando fallback');
           }
           return false;
         }
         
         // üõ°Ô∏è XIAOMI/MIUI: Teste adicional de quota (algumas vers√µes MIUI t√™m problemas)
         try {
           const largeTest = 'x'.repeat(1024); // 1KB
           localStorage.setItem(test, largeTest);
           localStorage.removeItem(test);
         } catch (quotaError) {
           if (quotaError.name === 'QuotaExceededError' || quotaError.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
             console.warn('‚ö†Ô∏è Quota do localStorage muito limitada');
             if (isXiaomi) {
               console.warn('‚ö†Ô∏è XIAOMI/MIUI: Quota limitada detectada - usando fallback');
             }
             return false;
           }
         }
         
         return true;
       } catch (setError) {
         console.warn('‚ö†Ô∏è Erro ao testar localStorage:', setError.message);
         if (isXiaomi) {
           console.warn('‚ö†Ô∏è XIAOMI/MIUI: Erro ao acessar localStorage - usando fallback');
         }
         return false;
       }
     } catch (e) {
       // Verificar tipo espec√≠fico de erro (quota excedida, privacidade, etc)
       if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
         console.warn('‚ö†Ô∏è Quota do localStorage excedida');
         if (isXiaomi) {
           console.warn('‚ö†Ô∏è XIAOMI/MIUI: Quota excedida - usando fallback');
         }
       } else if (e.name === 'SecurityError' || e.code === 18) {
         console.warn('‚ö†Ô∏è localStorage bloqueado por pol√≠tica de seguran√ßa');
         if (isXiaomi) {
           console.warn('‚ö†Ô∏è XIAOMI/MIUI: localStorage bloqueado - usando fallback');
         }
       } else {
         console.warn('‚ö†Ô∏è localStorage n√£o dispon√≠vel:', e.message);
         if (isXiaomi) {
           console.warn('‚ö†Ô∏è XIAOMI/MIUI: localStorage n√£o dispon√≠vel - usando fallback');
         }
       }
       return false;
     }
   }
   
   // üõ°Ô∏è FALLBACK: Armazenamento alternativo quando localStorage n√£o est√° dispon√≠vel
   const memoryStorage = {};
   const useMemoryStorage = !isLocalStorageAvailable();
   
   if (useMemoryStorage) {
     console.warn('‚ö†Ô∏è Usando armazenamento em mem√≥ria (fallback) - dados ser√£o perdidos ao recarregar');
   } else {
     console.log('‚úÖ localStorage dispon√≠vel e funcional');
   }
   
   // üõ°Ô∏è WRAPPER UNIVERSAL: Fun√ß√µes para acesso consistente ao armazenamento (COMPATIBILIDADE TOTAL)
   function safeGetItem(key, defaultValue = null) {
     try {
       if (useMemoryStorage) {
         return memoryStorage[key] !== undefined ? memoryStorage[key] : defaultValue;
       }
       
       if (typeof localStorage !== 'undefined') {
         try {
           const value = localStorage.getItem(key);
           if (value === null) return defaultValue;
           
           // Tentar fazer parse JSON
           try {
             return JSON.parse(value);
           } catch (parseError) {
             // Se n√£o for JSON v√°lido, retornar string original
             console.warn(`‚ö†Ô∏è Valor de ${key} n√£o √© JSON v√°lido, retornando string`);
             return value;
           }
         } catch (e) {
           console.warn(`‚ö†Ô∏è Erro ao ler ${key} do localStorage:`, e.message);
           // Fallback para mem√≥ria
           return memoryStorage[key] !== undefined ? memoryStorage[key] : defaultValue;
         }
       }
       
       // Fallback final
       return memoryStorage[key] !== undefined ? memoryStorage[key] : defaultValue;
     } catch (e) {
       console.error(`‚ùå Erro cr√≠tico ao ler ${key}:`, e.message);
       return defaultValue;
     }
   }
   
   function safeSetItem(key, value) {
     try {
       if (useMemoryStorage) {
         memoryStorage[key] = value;
         return true;
       }
       
       if (typeof localStorage !== 'undefined') {
         try {
           const serialized = JSON.stringify(value);
           localStorage.setItem(key, serialized);
           return true;
         } catch (e) {
           // Verificar tipo espec√≠fico de erro
           if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
             console.warn(`‚ö†Ô∏è Quota excedida ao salvar ${key}, usando mem√≥ria`);
             memoryStorage[key] = value;
             return true;
           } else {
             console.warn(`‚ö†Ô∏è Erro ao salvar ${key} no localStorage:`, e.message);
             // Fallback para mem√≥ria
             memoryStorage[key] = value;
             return true;
           }
         }
       }
       
       // Fallback para mem√≥ria
       memoryStorage[key] = value;
       return true;
     } catch (e) {
       console.error(`‚ùå Erro cr√≠tico ao salvar ${key}:`, e.message);
       // √öltimo recurso: tentar salvar em mem√≥ria
       try {
         memoryStorage[key] = value;
         return true;
       } catch (e2) {
         console.error(`‚ùå Erro fatal ao salvar ${key} em mem√≥ria`);
         return false;
       }
     }
   }
   
   function getOfflineQueue() {
     try {
       return safeGetItem(OFFLINE_QUEUE_KEY, []);
     } catch (error) {
       console.error('‚ùå Erro ao ler fila offline:', error);
       return [];
     }
   }
   
   function setOfflineQueue(queue) {
     try {
       safeSetItem(OFFLINE_QUEUE_KEY, queue);
       updateQueueCount();
     } catch (error) {
       console.error('‚ùå Erro ao salvar fila offline:', error);
     }
   }
   
   // üõ°Ô∏è FUN√á√ÉO CR√çTICA: Remove duplica√ß√µes da fila offline
   function removeDuplicatesFromQueue(queue) {
     const uniqueItems = [];
     const seen = new Set();
     
     for (const item of queue) {
       // Criar chave √∫nica baseada nos dados essenciais
       const key = `${item.data.nome || item.data.NOME || ''}_${item.data.comum || item.data.COMUM || ''}_${item.data.cargo || item.data.CARGO || ''}_${item.data.uuid || item.data.UUID || ''}`;
       
       if (!seen.has(key)) {
         seen.add(key);
         uniqueItems.push(item);
       } else {
         console.warn('üßπ Duplica√ß√£o removida da fila:', {
           nome: item.data.nome || item.data.NOME,
           comum: item.data.comum || item.data.COMUM,
           cargo: item.data.cargo || item.data.CARGO,
           id: item.id
         });
       }
     }
     
     return uniqueItems;
   }
   
   // üß™ FUN√á√ÉO DE TESTE: Verificar diferencia√ß√£o de g√™nero para Secret√°rio/Secret√°ria da M√∫sica
   async function testarDiferencacaoGeneroSecretario() {
     console.log('üß™ TESTE: Verificando diferencia√ß√£o de g√™nero para Secret√°rio/Secret√°ria da M√∫sica...');
     
     // Simula dados de teste para FL√ÅVIA (feminino)
     const nomeTeste = 'FL√ÅVIA APARECIDA DE MORAES NASCIMENTO';
     const comumTeste = 'JARDIM COTIA';
     const cargoTeste = 'ORGANISTA'; // Cargo selecionado no formul√°rio
     
     console.log('üß™ Dados de teste (FEMININO):', { nomeTeste, comumTeste, cargoTeste });
     
     if (!supabaseLoaded || !sb) {
       console.error('‚ùå Supabase n√£o dispon√≠vel para teste');
       return;
     }
     
     try {
       // Busca no banco para ver se a pessoa √© Secret√°ria da M√∫sica (feminino)
       const { data, error } = await sb
         .from(TABLE_CATALOGO)
         .select('nome, cargo, nivel, instrumento, comum')
         .ilike('comum', `%${comumTeste}%`)
         .ilike('nome', `%${nomeTeste}%`)
         .or('cargo.ilike.%ORGANISTA%,cargo.ilike.%EXAMINADORA%,cargo.ilike.%INSTRUTOR%,cargo.ilike.%INSTRUTORA%,cargo.ilike.%SECRET√ÅRIO DA M√öSICA%,cargo.ilike.%SECRET√ÅRIA DA M√öSICA%,cargo.ilike.%SECRET√ÅRIO DO GEM%,cargo.ilike.%SECRET√ÅRIA DO GEM%')
         .eq('ativo', true)
         .order('cargo', { ascending: true });
       
       console.log('üß™ Resultado da consulta:', { data, error });
       
       if (data && data.length > 0) {
         console.log('üß™ Registros encontrados:');
         data.forEach((r, index) => {
           console.log(`  ${index + 1}. Nome: "${r.nome}", Cargo: "${r.cargo}", Instrumento: "${r.instrumento}", Comum: "${r.comum}"`);
         });
         
         // Verifica especificamente a diferencia√ß√£o de g√™nero
         const secretarioMusica = data.find(r => 
           r.cargo && r.cargo.toUpperCase().includes('SECRET√ÅRIO') && r.cargo.toUpperCase().includes('M√öSICA')
         );
         
         const secretariaMusica = data.find(r => 
           r.cargo && r.cargo.toUpperCase().includes('SECRET√ÅRIA') && r.cargo.toUpperCase().includes('M√öSICA')
         );
         
         if (secretarioMusica) {
           console.log('‚úÖ SECRET√ÅRIO DA M√öSICA ENCONTRADO (MASCULINO):', secretarioMusica);
           console.log('üéØ Cargo correto deveria ser:', secretarioMusica.cargo);
           console.log('‚ö†Ô∏è ATEN√á√ÉO: Nome feminino mas cargo masculino - pode estar incorreto!');
         } else if (secretariaMusica) {
           console.log('‚úÖ SECRET√ÅRIA DA M√öSICA ENCONTRADA (FEMININO):', secretariaMusica);
           console.log('üéØ Cargo correto deveria ser:', secretariaMusica.cargo);
           console.log('‚úÖ CORRETO: Nome feminino e cargo feminino!');
         } else {
           console.log('‚ùå Nenhum cargo de Secret√°rio/Secret√°ria da M√∫sica encontrado');
         }
       } else {
         console.log('‚ùå Nenhum registro encontrado para a pessoa');
       }
       
     } catch (error) {
       console.error('‚ùå Erro no teste:', error);
     }
   }
   
   // üß™ FUN√á√ÉO DE TESTE: Verificar se duplica√ß√£o offline foi corrigida
   function testarCorrecaoDuplicacaoOffline() {
     console.log('üß™ TESTE: Verificando se duplica√ß√£o offline foi corrigida...');
     
     // Simula dados de teste
     const payloadTeste = {
       uuid: uuidv4(),
       nome: 'TESTE DUPLICA√á√ÉO',
       comum: 'TESTE',
       cargo: 'ORGANISTA',
       instrumento: '√ìRG√ÉO',
       data_ensaio: new Date().toLocaleDateString('pt-BR'),
       data_ensaio_iso: new Date().toISOString().split('T')[0]
     };
     
     console.log('üß™ Dados de teste:', payloadTeste);
     
     // Testa adi√ß√£o √† fila offline
     console.log('üß™ Testando adi√ß√£o √† fila offline...');
     const id1 = addToOfflineQueue(payloadTeste);
     console.log('üß™ Primeira adi√ß√£o - ID:', id1);
     
     // Tenta adicionar novamente (deveria ser bloqueado)
     console.log('üß™ Tentando adicionar novamente (deveria ser bloqueado)...');
     const id2 = addToOfflineQueue(payloadTeste);
     console.log('üß™ Segunda adi√ß√£o - ID:', id2);
     
     // Verifica se s√£o o mesmo ID (n√£o duplicou)
     if (id1 === id2) {
       console.log('‚úÖ SUCESSO: Duplica√ß√£o foi prevenida!');
       console.log('‚úÖ Ambas as tentativas retornaram o mesmo ID:', id1);
     } else {
       console.log('‚ùå FALHA: Duplica√ß√£o ainda est√° ocorrendo!');
       console.log('‚ùå IDs diferentes:', id1, 'vs', id2);
     }
     
     // Verifica o conte√∫do da fila
     const queue = getOfflineQueue();
     const itensComMesmoNome = queue.filter(item => 
       (item.data.nome || item.data.NOME) === payloadTeste.nome
     );
     
     console.log('üß™ Itens na fila com mesmo nome:', itensComMesmoNome.length);
     console.log('üß™ Total de itens na fila:', queue.length);
     
     if (itensComMesmoNome.length === 1) {
       console.log('‚úÖ SUCESSO: Apenas 1 item na fila (sem duplica√ß√£o)');
     } else {
       console.log('‚ùå FALHA: M√∫ltiplos itens na fila (duplica√ß√£o detectada)');
     }
     
     // Limpa os dados de teste
     console.log('üß™ Limpando dados de teste...');
     const queueLimpa = queue.filter(item => 
       (item.data.nome || item.data.NOME) !== payloadTeste.nome
     );
     setOfflineQueue(queueLimpa);
     console.log('üß™ Dados de teste removidos');
   }
   
   // üß™ FUN√á√ÉO DE TESTE: Verificar captura de classe para cargos musicais
   async function testarCapturaClasseCargosMusicais() {
     console.log('üß™ TESTE: Verificando captura de classe para cargos musicais...');
     
     // Simula dados de teste para diferentes cargos
     const testes = [
       {
         nome: 'MAGDA DERTINATI SABINO',
         comum: 'CENTRO',
         cargo: 'EXAMINADORA DE ORGANISTAS',
         esperado: 'Classe de organista capturada'
       },
       {
         nome: 'C√çNTIA FERREIRA DE SOUZA',
         comum: 'PARQUE DO AGRESTE',
         cargo: 'SECRET√ÅRIA DA M√öSICA',
         esperado: 'Classe de organista capturada'
       },
       {
         nome: 'VIVIANE SOMOGGI GARCIA VILAR',
         comum: 'PARQUE DO AGRESTE',
         cargo: 'INSTRUTORA',
         esperado: 'Classe de organista capturada'
       },
       {
         nome: 'DANIELE CRISTINA DE SOUSA',
         comum: 'JARDIM MIRANDA',
         cargo: 'ORGANISTA',
         esperado: 'Classe com prefixo padronizada (RJM / OFICIALIZADO(A) ‚Üí RJM / OFICIALIZADA)'
       }
     ];
     
     if (!supabaseLoaded || !sb) {
       console.error('‚ùå Supabase n√£o dispon√≠vel para teste');
       return;
     }
     
     for (const teste of testes) {
       console.log(`\nüß™ Testando: ${teste.nome} - ${teste.cargo}`);
       
       try {
         // Busca a classe de organista no banco
         const { data, error } = await sb
           .from(TABLE_CATALOGO)
           .select('cargo, nivel, instrumento')
           .ilike('nome', `%${teste.nome}%`)
           .ilike(COL_COMUM, `%${teste.comum}%`)
           .ilike('cargo', '%ORGANISTA%')
           .eq('ativo', true)
           .limit(1);
         
         console.log('üß™ Resultado da consulta:', { data, error });
         
         if (data && data.length > 0) {
           const registroOrganista = data[0];
           console.log('‚úÖ REGISTRO DE ORGANISTA ENCONTRADO:', registroOrganista);
           
           if (registroOrganista.nivel) {
             console.log('‚úÖ CLASSE DE ORGANISTA CAPTURADA:', registroOrganista.nivel);
             
             // Testa a l√≥gica de padroniza√ß√£o
             const classeOriginal = registroOrganista.nivel;
             let classePadronizada;
             
             if (classeOriginal.includes('/')) {
               const partes = classeOriginal.split('/');
               const prefixo = partes[0].trim();
               const sufixo = partes[1].trim();
               const sufixoPadronizado = sufixo.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
               classePadronizada = `${prefixo} / ${sufixoPadronizado}`;
               console.log('üéπ CLASSE COM PREFIXO SER√Å PADRONIZADA:', classeOriginal, '‚Üí', classePadronizada);
             } else {
               classePadronizada = classeOriginal.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
               console.log('üéπ CLASSE SER√Å PADRONIZADA PARA: "OFICIALIZADA" (sem o "(A)")');
             }
             
             console.log('üéØ RESULTADO: Classe real encontrada e padronizada');
           } else {
             console.log('‚ö†Ô∏è REGISTRO ENCONTRADO MAS SEM CLASSE - aplicando padr√£o "OFICIALIZADA"');
             console.log('üéØ RESULTADO: Classe padr√£o ser√° aplicada');
           }
         } else {
           console.log('‚ùå NENHUM REGISTRO DE ORGANISTA ENCONTRADO - aplicando padr√£o "OFICIALIZADA"');
           console.log('üéØ RESULTADO: Classe padr√£o ser√° aplicada');
         }
         
       } catch (error) {
         console.error('‚ùå Erro no teste:', error);
       }
     }
     
     console.log('\nüß™ TESTE CONCLU√çDO');
     console.log('üí° O sistema agora busca a classe real de organista para cargos musicais');
     console.log('üí° SEMPRE padroniza para "OFICIALIZADA" (sem o "(A)") para cargos musicais');
     console.log('üí° MANT√âM prefixos como "RJM / OFICIALIZADO(A)" ‚Üí "RJM / OFICIALIZADA"');
     console.log('üí° Se n√£o encontrar, aplica "OFICIALIZADA" como padr√£o');
   }
   
   // üß™ FUN√á√ÉO DE TESTE: Verificar se as corre√ß√µes para SECRET√ÅRIA DA M√öSICA e RJM funcionaram
   async function testarCorrecoesCompletas() {
     console.log('üß™ TESTE: Verificando se todas as corre√ß√µes funcionaram...');
     
     // Teste 1: SECRET√ÅRIA DA M√öSICA
     console.log('\nüìã TESTE 1: SECRET√ÅRIA DA M√öSICA');
     const dadosSecretaria = {
       nomeCompleto: 'C√çNTIA FERREIRA DE SOUZA',
       comum: 'PARQUE DO AGRESTE',
       cargo: 'SECRET√ÅRIA DA M√öSICA',
       instrumento: '√ìRG√ÉO'
     };
     
     const isCargoMusicalSecretaria = dadosSecretaria.cargo && (
       dadosSecretaria.cargo.toUpperCase().includes('ORGANISTA') ||
       dadosSecretaria.cargo.toUpperCase().includes('INSTRUTORA') ||
       dadosSecretaria.cargo.toUpperCase().includes('EXAMINADORA') ||
       // Removido: INSTRUTOR n√£o deve receber classe de organista
       (dadosSecretaria.cargo.toLowerCase().includes('secret√°ria') && dadosSecretaria.cargo.toLowerCase().includes('m√∫sica'))
     );
     
     console.log('üß™ isCargoMusical para SECRET√ÅRIA DA M√öSICA:', isCargoMusicalSecretaria);
     
     if (isCargoMusicalSecretaria) {
       console.log('‚úÖ SECRET√ÅRIA DA M√öSICA √© detectada como cargo musical');
       
       // Simula padroniza√ß√£o
       const classeOriginal = 'OFICIALIZADO(A)';
       const classePadronizada = classeOriginal.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
       console.log('üéπ CLASSE ORIGINAL:', classeOriginal);
       console.log('üéπ CLASSE PADRONIZADA:', classePadronizada);
       
       if (classePadronizada === 'OFICIALIZADA') {
         console.log('‚úÖ SUCESSO: "OFICIALIZADO(A)" ser√° corrigido para "OFICIALIZADA"');
       } else {
         console.log('‚ùå FALHA: Padroniza√ß√£o n√£o funcionou corretamente');
       }
     } else {
       console.log('‚ùå FALHA: SECRET√ÅRIA DA M√öSICA n√£o est√° sendo detectada como cargo musical');
     }
     
     // Teste 2: ORGANISTA com RJM
     console.log('\nüìã TESTE 2: ORGANISTA com RJM');
     const dadosOrganista = {
       nomeCompleto: 'DANIELE CRISTINA DE SOUSA',
       comum: 'JARDIM MIRANDA',
       cargo: 'ORGANISTA',
       instrumento: '√ìRG√ÉO'
     };
     
     const isCargoMusicalOrganista = dadosOrganista.cargo && (
       dadosOrganista.cargo.toUpperCase().includes('ORGANISTA') ||
       dadosOrganista.cargo.toUpperCase().includes('INSTRUTORA') ||
       dadosOrganista.cargo.toUpperCase().includes('EXAMINADORA') ||
       // Removido: INSTRUTOR n√£o deve receber classe de organista
       (dadosOrganista.cargo.toLowerCase().includes('secret√°ria') && dadosOrganista.cargo.toLowerCase().includes('m√∫sica'))
     );
     
     console.log('üß™ isCargoMusical para ORGANISTA:', isCargoMusicalOrganista);
     
     if (isCargoMusicalOrganista) {
       console.log('‚úÖ ORGANISTA √© detectado como cargo musical');
       
       // Simula padroniza√ß√£o com prefixo
       const classeOriginal = 'RJM / OFICIALIZADO(A)';
       let classePadronizada;
       
       if (classeOriginal.includes('/')) {
         const partes = classeOriginal.split('/');
         const prefixo = partes[0].trim();
         const sufixo = partes[1].trim();
         const sufixoPadronizado = sufixo.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
         classePadronizada = `${prefixo} / ${sufixoPadronizado}`;
       } else {
         classePadronizada = classeOriginal.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
       }
       
       console.log('üéπ CLASSE ORIGINAL:', classeOriginal);
       console.log('üéπ CLASSE PADRONIZADA:', classePadronizada);
       
       if (classePadronizada === 'RJM / OFICIALIZADA') {
         console.log('‚úÖ SUCESSO: "RJM / OFICIALIZADO(A)" ser√° corrigido para "RJM / OFICIALIZADA"');
       } else {
         console.log('‚ùå FALHA: Padroniza√ß√£o n√£o funcionou corretamente');
       }
     } else {
       console.log('‚ùå FALHA: ORGANISTA n√£o est√° sendo detectado como cargo musical');
     }
     
     console.log('\nüß™ TESTE COMPLETO CONCLU√çDO');
   }
   
   // üß™ FUN√á√ÉO DE TESTE: Simular exatamente o que acontece com DANIELE
   async function testarDanieleEspecifico() {
     console.log('üß™ TESTE ESPEC√çFICO: Simulando DANIELE CRISTINA DE SOUSA...');
     
     // Simula exatamente os dados de DANIELE
     const nomeCompleto = 'DANIELE CRISTINA DE SOUSA';
     const comum = 'JARDIM MIRANDA';
     const cargo = 'ORGANISTA';
     let classe = null; // Simula que classe est√° vazia inicialmente
     
     console.log('üìã Dados de entrada:', { nomeCompleto, comum, cargo, classe });
     
     // Testa a l√≥gica de detec√ß√£o de cargo musical
     const isCargoMusical = cargo && (
       cargo.toUpperCase().includes('M√öSICO') ||
       cargo.toUpperCase().includes('M√öSICO') ||
       cargo.toUpperCase().includes('M√öSICO') ||
       cargo.toUpperCase().includes('ORGANISTA') ||
       cargo.toUpperCase().includes('INSTRUTORA') ||
       cargo.toUpperCase().includes('EXAMINADORA') ||
       // Removido: INSTRUTOR n√£o deve receber classe de organista
       (cargo.toLowerCase().includes('secret√°ria') && cargo.toLowerCase().includes('m√∫sica'))
     );
     
     console.log('üîç DEBUG - Verificando condi√ß√µes para busca de classe:', {
       isCargoMusical,
       nomeCompleto,
       comum,
       classe,
       cargo,
       condicaoCompleta: isCargoMusical && nomeCompleto && comum && !classe
     });
     
     if (isCargoMusical && nomeCompleto && comum && !classe) {
       console.log('‚úÖ CONDI√á√ÉO ATENDIDA - Vai buscar classe no banco');
       
       // Simula a busca no banco (dados reais de DANIELE)
       const registroOrganista = {
         cargo: 'ORGANISTA',
         nivel: 'RJM / OFICIALIZADO(A)',
         instrumento: '√ìRG√ÉO'
       };
       
       console.log('üéπ REGISTRO DE ORGANISTA ENCONTRADO:', registroOrganista);
       
       if (registroOrganista.nivel) {
         const classeOriginal = registroOrganista.nivel;
         console.log('üéπ Classe original do banco:', classeOriginal);
         
         // Aplica a l√≥gica de padroniza√ß√£o
         if (classeOriginal.includes('/')) {
           const partes = classeOriginal.split('/');
           const prefixo = partes[0].trim();
           const sufixo = partes[1].trim();
           
           const sufixoPadronizado = sufixo.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
           classe = `${prefixo} / ${sufixoPadronizado}`;
           
           console.log('üéπ Processamento com prefixo:');
           console.log('  - Prefixo:', prefixo);
           console.log('  - Sufixo original:', sufixo);
           console.log('  - Sufixo padronizado:', sufixoPadronizado);
           console.log('  - Classe final:', classe);
         } else {
           classe = classeOriginal.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
           console.log('üéπ Processamento sem prefixo:', classe);
         }
         
         console.log('‚úÖ CLASSE DE ORGANISTA CAPTURADA E PADRONIZADA:', classe);
         console.log('üéπ Classe original do banco:', classeOriginal, '‚Üí Padronizada para:', classe);
         
         if (classe === 'RJM / OFICIALIZADA') {
           console.log('‚úÖ SUCESSO: Padroniza√ß√£o funcionou corretamente!');
         } else {
           console.log('‚ùå FALHA: Padroniza√ß√£o n√£o funcionou. Esperado: "RJM / OFICIALIZADA", Obtido:', classe);
         }
       } else {
         console.log('‚ùå FALHA: Registro n√£o tem n√≠vel');
       }
     } else {
       console.log('‚ùå FALHA: Condi√ß√£o n√£o foi atendida');
       console.log('üîç Verificando cada condi√ß√£o:');
       console.log('  - isCargoMusical:', isCargoMusical);
       console.log('  - nomeCompleto:', !!nomeCompleto);
       console.log('  - comum:', !!comum);
       console.log('  - !classe:', !classe);
     }
     
     console.log('\nüß™ TESTE ESPEC√çFICO CONCLU√çDO');
   }
   
   // üß™ FUN√á√ÉO DE TESTE: Verificar suporte a m√∫ltiplos usu√°rios
   async function testarMultiplosUsuarios() {
     console.log('üß™ TESTE: Verificando suporte a m√∫ltiplos usu√°rios simult√¢neos...');
     
     // 1. Verificar sistema de autentica√ß√£o
     console.log('\nüìã 1. SISTEMA DE AUTENTICA√á√ÉO:');
     const sessionUser = localStorage.getItem('session_user');
     const sessionRole = localStorage.getItem('session_role');
     const sessionLocal = localStorage.getItem('session_local');
     const currentUserId = localStorage.getItem('current_user_id');
     const currentUserName = localStorage.getItem('current_user_name');
     
     console.log('‚úÖ Dados de sess√£o atuais:', {
       sessionUser,
       sessionRole,
       sessionLocal,
       currentUserId,
       currentUserName
     });
     
     if (sessionUser && sessionLocal) {
       console.log('‚úÖ Sistema de autentica√ß√£o configurado');
     } else {
       console.log('‚ùå Sistema de autentica√ß√£o n√£o configurado');
     }
     
     // 2. Verificar controle de concorr√™ncia
     console.log('\nüìã 2. CONTROLE DE CONCORR√äNCIA:');
     console.log('‚úÖ processingUsers (Set):', processingUsers);
     console.log('‚úÖ processingQueue (Array):', processingQueue);
     console.log('‚úÖ Sistema permite m√∫ltiplos usu√°rios simult√¢neos');
     
     // 3. Verificar identifica√ß√£o √∫nica de usu√°rios
     console.log('\nüìã 3. IDENTIFICA√á√ÉO √öNICA:');
     if (currentUserId) {
       console.log('‚úÖ Cada usu√°rio tem ID √∫nico:', currentUserId);
     } else {
       console.log('‚ö†Ô∏è Usu√°rio atual n√£o tem ID √∫nico definido');
     }
     
     // 4. Verificar isolamento por local
     console.log('\nüìã 4. ISOLAMENTO POR LOCAL:');
     if (sessionLocal) {
       console.log('‚úÖ Usu√°rio isolado por local:', sessionLocal);
       console.log('‚úÖ Registros filtrados por local do usu√°rio');
     } else {
       console.log('‚ùå Usu√°rio n√£o tem local definido');
     }
     
     // 5. Verificar sistema de roles
     console.log('\nüìã 5. SISTEMA DE ROLES:');
     if (sessionRole) {
       console.log('‚úÖ Sistema de roles configurado:', sessionRole);
       if (sessionRole === 'master') {
         console.log('üëë Usu√°rio tem privil√©gios de master');
       } else {
         console.log('üë§ Usu√°rio tem privil√©gios de usu√°rio comum');
       }
     } else {
       console.log('‚ö†Ô∏è Sistema de roles n√£o configurado');
     }
     
     // 6. Verificar persist√™ncia de dados
     console.log('\nüìã 6. PERSIST√äNCIA DE DADOS:');
     const sessionTime = localStorage.getItem('session_time');
     if (sessionTime) {
       const sessionAge = Date.now() - parseInt(sessionTime);
       const sessionAgeHours = Math.floor(sessionAge / (1000 * 60 * 60));
       console.log('‚úÖ Sess√£o ativa h√°:', sessionAgeHours, 'horas');
       console.log('‚úÖ Sess√£o expira em 24 horas');
     } else {
       console.log('‚ùå Tempo de sess√£o n√£o definido');
     }
     
     // 7. Verificar funcionalidades offline
     console.log('\nüìã 7. FUNCIONALIDADES OFFLINE:');
     const offlineQueue = JSON.parse(localStorage.getItem('offline_queue') || '[]');
     const supabaseQueue = JSON.parse(localStorage.getItem('supabase_queue') || '[]');
     console.log('‚úÖ Fila offline:', offlineQueue.length, 'itens');
     console.log('‚úÖ Fila Supabase:', supabaseQueue.length, 'itens');
     console.log('‚úÖ Sistema funciona offline para m√∫ltiplos usu√°rios');
     
     // 8. Resumo final
     console.log('\nüìã RESUMO FINAL:');
     const suportaMultiplosUsuarios = sessionUser && sessionLocal && currentUserId;
     
     if (suportaMultiplosUsuarios) {
       console.log('‚úÖ SISTEMA SUPORTA M√öLTIPLOS USU√ÅRIOS SIMULT√ÇNEOS');
       console.log('‚úÖ Cada usu√°rio tem:');
       console.log('  - ID √∫nico');
       console.log('  - Local isolado');
       console.log('  - Controle de concorr√™ncia');
       console.log('  - Sess√£o independente');
       console.log('  - Funcionalidades offline');
     } else {
       console.log('‚ùå SISTEMA N√ÉO EST√Å CONFIGURADO PARA M√öLTIPLOS USU√ÅRIOS');
     }
     
     console.log('\nüß™ TESTE DE M√öLTIPLOS USU√ÅRIOS CONCLU√çDO');
   }
   
   // üß™ FUN√á√ÉO DE TESTE: Verificar se funcionalidades s√£o iguais no mobile e desktop
   async function testarFuncionalidadesMobileVsDesktop() {
     console.log('üß™ TESTE: Verificando se funcionalidades s√£o iguais no mobile e desktop...');
     
     // 1. Verificar detec√ß√£o de plataforma
     console.log('\nüìã 1. DETEC√á√ÉO DE PLATAFORMA:');
     console.log('‚úÖ isMobile:', isMobile);
     console.log('‚úÖ isDesktop:', isDesktop);
     console.log('‚úÖ isIOS:', isIOS);
     console.log('‚úÖ isAndroid:', isAndroid);
     console.log('‚úÖ isStandalone:', isStandalone);
     
     // 2. Verificar se as fun√ß√µes principais est√£o dispon√≠veis
     console.log('\nüìã 2. FUN√á√ïES PRINCIPAIS DISPON√çVEIS:');
     const funcoesPrincipais = [
       'capturarClasseAutomaticamente',
       'collectFormData',
       'handleSubmit',
       'processOfflineQueue',
       'addToOfflineQueue',
       'sendToGoogleSheets',
       'insertSupabase'
     ];
     
     funcoesPrincipais.forEach(funcao => {
       if (typeof window[funcao] === 'function') {
         console.log(`‚úÖ ${funcao}: Dispon√≠vel`);
       } else {
         console.log(`‚ùå ${funcao}: N√ÉO DISPON√çVEL`);
       }
     });
     
     // 3. Verificar se a l√≥gica de padroniza√ß√£o est√° funcionando
     console.log('\nüìã 3. L√ìGICA DE PADRONIZA√á√ÉO:');
     
     // Testa a l√≥gica de detec√ß√£o de cargo musical
     const cargoTeste = 'ORGANISTA';
     const isCargoMusical = cargoTeste && (
       cargoTeste.toUpperCase().includes('ORGANISTA') ||
       cargoTeste.toUpperCase().includes('INSTRUTORA') ||
       cargoTeste.toUpperCase().includes('EXAMINADORA') ||
       // Removido: INSTRUTOR n√£o deve receber classe de organista
       (cargoTeste.toLowerCase().includes('secret√°ria') && cargoTeste.toLowerCase().includes('m√∫sica'))
     );
     
     console.log('‚úÖ Detec√ß√£o de cargo musical para ORGANISTA:', isCargoMusical);
     
     // Testa a l√≥gica de padroniza√ß√£o
     const classeOriginal = 'RJM / OFICIALIZADO(A)';
     let classePadronizada;
     
     if (classeOriginal.includes('/')) {
       const partes = classeOriginal.split('/');
       const prefixo = partes[0].trim();
       const sufixo = partes[1].trim();
       const sufixoPadronizado = sufixo.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
       classePadronizada = `${prefixo} / ${sufixoPadronizado}`;
     } else {
       classePadronizada = classeOriginal.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
     }
     
     console.log('‚úÖ Padroniza√ß√£o de classe:', classeOriginal, '‚Üí', classePadronizada);
     
     if (classePadronizada === 'RJM / OFICIALIZADA') {
       console.log('‚úÖ L√ìGICA DE PADRONIZA√á√ÉO FUNCIONANDO CORRETAMENTE');
     } else {
       console.log('‚ùå L√ìGICA DE PADRONIZA√á√ÉO COM PROBLEMA');
     }
     
     // 4. Verificar se os event listeners est√£o funcionando
     console.log('\nüìã 4. EVENT LISTENERS:');
     const nomeEl = document.querySelector('#nome, [name="nome"], input[placeholder*="nome"]');
     if (nomeEl) {
       console.log('‚úÖ Campo nome encontrado:', nomeEl.tagName);
       console.log('‚úÖ Campo nome tem event listeners:', nomeEl.onchange !== null || nomeEl.oninput !== null);
     } else {
       console.log('‚ùå Campo nome n√£o encontrado');
     }
     
     // 5. Verificar se as otimiza√ß√µes mobile est√£o ativas
     console.log('\nüìã 5. OTIMIZA√á√ïES MOBILE:');
     if (isMobile) {
       console.log('‚úÖ Modo mobile ativo');
       console.log('‚úÖ Sincroniza√ß√£o mobile otimizada');
       console.log('‚úÖ Campos otimizados para touch');
       
       // Verificar se h√° indicador de status mobile
       const statusIndicator = document.getElementById('mobile-status-indicator');
       if (statusIndicator) {
         console.log('‚úÖ Indicador de status mobile presente');
       } else {
         console.log('‚ö†Ô∏è Indicador de status mobile n√£o encontrado');
       }
     } else {
       console.log('‚úÖ Modo desktop ativo');
       console.log('‚úÖ Otimiza√ß√µes desktop aplicadas');
     }
     
     // 6. Verificar se as filas offline est√£o funcionando
     console.log('\nüìã 6. FILAS OFFLINE:');
     const offlineQueue = JSON.parse(localStorage.getItem('offline_queue_v3') || '[]');
     const supabaseQueue = JSON.parse(localStorage.getItem('supabase_queue') || '[]');
     console.log('‚úÖ Fila offline:', offlineQueue.length, 'itens');
     console.log('‚úÖ Fila Supabase:', supabaseQueue.length, 'itens');
     
     // 7. Verificar se o Supabase est√° funcionando
     console.log('\nüìã 7. SUPABASE:');
     if (typeof sb !== 'undefined' && sb) {
       console.log('‚úÖ Supabase carregado');
       console.log('‚úÖ Conex√£o com banco dispon√≠vel');
     } else {
       console.log('‚ö†Ô∏è Supabase n√£o carregado');
     }
     
     // 8. Verificar se as fun√ß√µes de teste est√£o dispon√≠veis
     console.log('\nüìã 8. FUN√á√ïES DE TESTE:');
     const funcoesTeste = [
       'testarCorrecoesCompletas',
       'testarDanieleEspecifico',
       'testarMultiplosUsuarios',
       'testarFuncionalidadesMobileVsDesktop'
     ];
     
     funcoesTeste.forEach(funcao => {
       if (typeof window[funcao] === 'function') {
         console.log(`‚úÖ ${funcao}: Dispon√≠vel`);
       } else {
         console.log(`‚ùå ${funcao}: N√ÉO DISPON√çVEL`);
       }
     });
     
     // 9. Resumo final
     console.log('\nüìã RESUMO FINAL:');
     const todasFuncionalidadesOk = isCargoMusical && 
                                    classePadronizada === 'RJM / OFICIALIZADA' && 
                                    nomeEl && 
                                    typeof window['capturarClasseAutomaticamente'] === 'function';
     
     if (todasFuncionalidadesOk) {
       console.log('‚úÖ TODAS AS FUNCIONALIDADES EST√ÉO FUNCIONANDO IGUALMENTE NO MOBILE E DESKTOP');
       console.log('‚úÖ Sistema unificado e consistente');
     } else {
       console.log('‚ùå ALGUMAS FUNCIONALIDADES PODEM ESTAR DIFERENTES ENTRE MOBILE E DESKTOP');
       console.log('‚ö†Ô∏è Verificar logs acima para identificar problemas');
     }
     
     console.log('\nüß™ TESTE DE FUNCIONALIDADES MOBILE VS DESKTOP CONCLU√çDO');
   }
   
   // üß™ FUN√á√ÉO DE DIAGN√ìSTICO: Verificar diferen√ßas espec√≠ficas entre mobile e desktop
   async function diagnosticarDiferencasMobileDesktop() {
     console.log('üîç DIAGN√ìSTICO: Verificando diferen√ßas espec√≠ficas entre mobile e desktop...');
     
     // 1. Verificar se as fun√ß√µes est√£o sendo carregadas corretamente
     console.log('\nüìã 1. CARREGAMENTO DE FUN√á√ïES:');
     
     // Verificar se a fun√ß√£o capturarClasseAutomaticamente est√° definida
     if (typeof capturarClasseAutomaticamente === 'function') {
       console.log('‚úÖ capturarClasseAutomaticamente: Fun√ß√£o carregada');
       
       // Verificar se a fun√ß√£o tem o c√≥digo de padroniza√ß√£o
       const funcaoString = capturarClasseAutomaticamente.toString();
       if (funcaoString.includes('isCargoMusical')) {
         console.log('‚úÖ capturarClasseAutomaticamente: Cont√©m l√≥gica de detec√ß√£o de cargo musical');
       } else {
         console.log('‚ùå capturarClasseAutomaticamente: N√ÉO cont√©m l√≥gica de detec√ß√£o de cargo musical');
       }
       
       if (funcaoString.includes('OFICIALIZADA')) {
         console.log('‚úÖ capturarClasseAutomaticamente: Cont√©m l√≥gica de padroniza√ß√£o');
       } else {
         console.log('‚ùå capturarClasseAutomaticamente: N√ÉO cont√©m l√≥gica de padroniza√ß√£o');
       }
     } else {
       console.log('‚ùå capturarClasseAutomaticamente: Fun√ß√£o N√ÉO carregada');
     }
     
     // 2. Verificar se os event listeners est√£o sendo aplicados
     console.log('\nüìã 2. EVENT LISTENERS:');
     const nomeEl = document.querySelector('#nome, [name="nome"], input[placeholder*="nome"]');
     if (nomeEl) {
       console.log('‚úÖ Campo nome encontrado');
       
       // Verificar se tem event listeners
       const hasChangeListener = nomeEl.onchange !== null;
       const hasInputListener = nomeEl.oninput !== null;
       
       console.log('‚úÖ onchange listener:', hasChangeListener);
       console.log('‚úÖ oninput listener:', hasInputListener);
       
       // Verificar se tem event listeners via addEventListener
       const events = getEventListeners ? getEventListeners(nomeEl) : null;
       if (events) {
         console.log('‚úÖ Event listeners via addEventListener:', Object.keys(events));
       } else {
         console.log('‚ö†Ô∏è N√£o √© poss√≠vel verificar event listeners via addEventListener (fun√ß√£o n√£o dispon√≠vel)');
       }
     } else {
       console.log('‚ùå Campo nome n√£o encontrado');
     }
     
     // 3. Verificar se as otimiza√ß√µes mobile est√£o interferindo
     console.log('\nüìã 3. OTIMIZA√á√ïES MOBILE:');
     if (isMobile) {
       console.log('‚úÖ Modo mobile detectado');
       
       // Verificar se h√° elementos espec√≠ficos do mobile
       const statusIndicator = document.getElementById('mobile-status-indicator');
       if (statusIndicator) {
         console.log('‚úÖ Indicador de status mobile presente');
       } else {
         console.log('‚ö†Ô∏è Indicador de status mobile n√£o encontrado');
       }
       
       // Verificar se h√° dicas offline
       const offlineHint = document.getElementById('mobile-offline-hint');
       if (offlineHint) {
         console.log('‚úÖ Dica offline mobile presente');
       } else {
         console.log('‚úÖ Dica offline mobile n√£o presente (normal quando online)');
       }
     } else {
       console.log('‚úÖ Modo desktop detectado');
     }
     
     // 4. Verificar se h√° conflitos de inicializa√ß√£o
     console.log('\nüìã 4. INICIALIZA√á√ÉO:');
     
     // Verificar se o DOM est√° pronto
     if (document.readyState === 'complete') {
       console.log('‚úÖ DOM completamente carregado');
     } else {
       console.log('‚ö†Ô∏è DOM ainda carregando:', document.readyState);
     }
     
     // Verificar se o Supabase est√° carregado
     if (typeof sb !== 'undefined' && sb) {
       console.log('‚úÖ Supabase carregado');
     } else {
       console.log('‚ö†Ô∏è Supabase n√£o carregado');
     }
     
     // 5. Teste pr√°tico da funcionalidade
     console.log('\nüìã 5. TESTE PR√ÅTICO:');
     
     // Simular sele√ß√£o de nome para testar se a fun√ß√£o √© chamada
     if (nomeEl) {
       console.log('üß™ Testando sele√ß√£o de nome...');
       
       // Simular evento de input
       const event = new Event('input', { bubbles: true });
       nomeEl.value = 'TESTE MOBILE DESKTOP';
       nomeEl.dispatchEvent(event);
       
       console.log('‚úÖ Evento de input disparado');
       
       // Verificar se a fun√ß√£o foi chamada (isso ser√° vis√≠vel nos logs)
       setTimeout(() => {
         console.log('‚úÖ Teste de evento conclu√≠do - verificar logs acima para ver se capturarClasseAutomaticamente foi chamada');
       }, 1000);
     }
     
     // 6. Verificar localStorage
     console.log('\nüìã 6. LOCALSTORAGE:');
     try {
       const sessionUser = localStorage.getItem('session_user');
       const sessionLocal = localStorage.getItem('session_local');
       console.log('‚úÖ session_user:', sessionUser ? 'Definido' : 'N√£o definido');
       console.log('‚úÖ session_local:', sessionLocal ? 'Definido' : 'N√£o definido');
     } catch (e) {
       console.log('‚ùå Erro ao acessar localStorage:', e.message);
     }
     
     console.log('\nüîç DIAGN√ìSTICO CONCLU√çDO');
     console.log('üí° Se alguma funcionalidade n√£o estiver funcionando no mobile, verifique os logs acima');
   }
   
   // üß™ FUN√á√ÉO DE TESTE: Verificar se SECRET√ÅRIO DA M√öSICA n√£o recebe classe de organista
   async function testarCorrecaoSecretarioMusica() {
     console.log('üß™ TESTE: Verificando se SECRET√ÅRIO DA M√öSICA n√£o recebe classe de organista...');
     
     // Teste 1: SECRET√ÅRIO DA M√öSICA (masculino) - N√ÉO deve receber classe
     console.log('\nüìã TESTE 1: SECRET√ÅRIO DA M√öSICA (masculino)');
     const dadosSecretario = {
       nomeCompleto: 'JO√ÉO SILVA',
       comum: 'VILA DOUTOR CARDOSO',
       cargo: 'SECRET√ÅRIO DA M√öSICA',
       instrumento: 'VIOLINO'
     };
     
     const isCargoMusicalSecretario = dadosSecretario.cargo && (
       dadosSecretario.cargo.toUpperCase().includes('ORGANISTA') ||
       dadosSecretario.cargo.toUpperCase().includes('INSTRUTORA') ||
       dadosSecretario.cargo.toUpperCase().includes('EXAMINADORA') ||
       // Removido: INSTRUTOR n√£o deve receber classe de organista
       (dadosSecretario.cargo.toLowerCase().includes('secret√°ria') && dadosSecretario.cargo.toLowerCase().includes('m√∫sica'))
     );
     
     console.log('üß™ isCargoMusical para SECRET√ÅRIO DA M√öSICA:', isCargoMusicalSecretario);
     
     if (!isCargoMusicalSecretario) {
       console.log('‚úÖ SUCESSO: SECRET√ÅRIO DA M√öSICA N√ÉO √© detectado como cargo musical');
       console.log('‚úÖ CORRETO: Secret√°rio da m√∫sica n√£o receber√° classe de organista');
     } else {
       console.log('‚ùå FALHA: SECRET√ÅRIO DA M√öSICA ainda est√° sendo detectado como cargo musical');
       console.log('‚ùå PROBLEMA: Secret√°rio da m√∫sica ainda receber√° classe de organista');
     }
     
     // Teste 2: SECRET√ÅRIA DA M√öSICA (feminino) - DEVE receber classe
     console.log('\nüìã TESTE 2: SECRET√ÅRIA DA M√öSICA (feminino)');
     const dadosSecretaria = {
       nomeCompleto: 'MARIA SANTOS',
       comum: 'CENTRO',
       cargo: 'SECRET√ÅRIA DA M√öSICA',
       instrumento: '√ìRG√ÉO'
     };
     
     const isCargoMusicalSecretaria = dadosSecretaria.cargo && (
       dadosSecretaria.cargo.toUpperCase().includes('ORGANISTA') ||
       dadosSecretaria.cargo.toUpperCase().includes('INSTRUTORA') ||
       dadosSecretaria.cargo.toUpperCase().includes('EXAMINADORA') ||
       // Removido: INSTRUTOR n√£o deve receber classe de organista
       (dadosSecretaria.cargo.toLowerCase().includes('secret√°ria') && dadosSecretaria.cargo.toLowerCase().includes('m√∫sica'))
     );
     
     console.log('üß™ isCargoMusical para SECRET√ÅRIA DA M√öSICA:', isCargoMusicalSecretaria);
     
     if (isCargoMusicalSecretaria) {
       console.log('‚úÖ SUCESSO: SECRET√ÅRIA DA M√öSICA √© detectada como cargo musical');
       console.log('‚úÖ CORRETO: Secret√°ria da m√∫sica receber√° classe de organista');
     } else {
       console.log('‚ùå FALHA: SECRET√ÅRIA DA M√öSICA n√£o est√° sendo detectada como cargo musical');
       console.log('‚ùå PROBLEMA: Secret√°ria da m√∫sica n√£o receber√° classe de organista');
     }
     
     // Teste 3: ORGANISTA - DEVE receber classe
     console.log('\nüìã TESTE 3: ORGANISTA');
     const dadosOrganista = {
       nomeCompleto: 'ANA COSTA',
       comum: 'JARDIM MIRANDA',
       cargo: 'ORGANISTA',
       instrumento: '√ìRG√ÉO'
     };
     
     const isCargoMusicalOrganista = dadosOrganista.cargo && (
       dadosOrganista.cargo.toUpperCase().includes('ORGANISTA') ||
       dadosOrganista.cargo.toUpperCase().includes('INSTRUTORA') ||
       dadosOrganista.cargo.toUpperCase().includes('EXAMINADORA') ||
       // Removido: INSTRUTOR n√£o deve receber classe de organista
       (dadosOrganista.cargo.toLowerCase().includes('secret√°ria') && dadosOrganista.cargo.toLowerCase().includes('m√∫sica'))
     );
     
     console.log('üß™ isCargoMusical para ORGANISTA:', isCargoMusicalOrganista);
     
     if (isCargoMusicalOrganista) {
       console.log('‚úÖ SUCESSO: ORGANISTA √© detectado como cargo musical');
       console.log('‚úÖ CORRETO: Organista receber√° classe de organista');
     } else {
       console.log('‚ùå FALHA: ORGANISTA n√£o est√° sendo detectado como cargo musical');
       console.log('‚ùå PROBLEMA: Organista n√£o receber√° classe de organista');
     }
     
     // Resumo final
     console.log('\nüìã RESUMO FINAL:');
     const correcaoFuncionou = !isCargoMusicalSecretario && isCargoMusicalSecretaria && isCargoMusicalOrganista;
     
     if (correcaoFuncionou) {
       console.log('‚úÖ CORRE√á√ÉO FUNCIONOU PERFEITAMENTE!');
       console.log('‚úÖ SECRET√ÅRIO DA M√öSICA (masculino): N√ÉO recebe classe de organista');
       console.log('‚úÖ SECRET√ÅRIA DA M√öSICA (feminino): RECEBE classe de organista');
       console.log('‚úÖ ORGANISTA: RECEBE classe de organista');
     } else {
       console.log('‚ùå CORRE√á√ÉO N√ÉO FUNCIONOU COMPLETAMENTE');
       console.log('‚ö†Ô∏è Verificar logs acima para identificar problemas');
     }
     
     console.log('\nüß™ TESTE DE CORRE√á√ÉO SECRET√ÅRIO DA M√öSICA CONCLU√çDO');
   }
   
   // üß™ FUN√á√ÉO DE TESTE: Verificar se "RJM / OFICIALIZADO(A)" est√° sendo corrigido
   async function testarCorrecaoRJM() {
     console.log('üß™ TESTE: Verificando se "RJM / OFICIALIZADO(A)" est√° sendo corrigido...');
     
     // Simula dados de teste para DANIELE
     const dadosTeste = {
       nomeCompleto: 'DANIELE CRISTINA DE SOUSA',
       comum: 'JARDIM MIRANDA',
       cargo: 'ORGANISTA',
       instrumento: '√ìRG√ÉO'
     };
     
     console.log('üß™ Dados de teste:', dadosTeste);
     
     // Testa a l√≥gica de detec√ß√£o de cargo musical
     const isCargoMusical = dadosTeste.cargo && (
       dadosTeste.cargo.toUpperCase().includes('ORGANISTA') ||
       dadosTeste.cargo.toUpperCase().includes('EXAMINADORA') ||
       dadosTeste.cargo.toUpperCase().includes('INSTRUTORA') ||
       // Removido: INSTRUTOR n√£o deve receber classe de organista
       (dadosTeste.cargo.toLowerCase().includes('secret√°ria') && dadosTeste.cargo.toLowerCase().includes('m√∫sica'))
     );
     
     console.log('üß™ isCargoMusical para ORGANISTA:', isCargoMusical);
     
     if (isCargoMusical) {
       console.log('‚úÖ ORGANISTA √© detectado como cargo musical');
       
       // Simula a l√≥gica de padroniza√ß√£o
       const classeOriginal = 'RJM / OFICIALIZADO(A)';
       let classePadronizada;
       
       if (classeOriginal.includes('/')) {
         const partes = classeOriginal.split('/');
         const prefixo = partes[0].trim();
         const sufixo = partes[1].trim();
         const sufixoPadronizado = sufixo.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
         classePadronizada = `${prefixo} / ${sufixoPadronizado}`;
       } else {
         classePadronizada = classeOriginal.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
       }
       
       console.log('üéπ CLASSE ORIGINAL:', classeOriginal);
       console.log('üéπ CLASSE PADRONIZADA:', classePadronizada);
       
       if (classePadronizada === 'RJM / OFICIALIZADA') {
         console.log('‚úÖ SUCESSO: "RJM / OFICIALIZADO(A)" ser√° corrigido para "RJM / OFICIALIZADA"');
       } else {
         console.log('‚ùå FALHA: Padroniza√ß√£o n√£o funcionou corretamente');
       }
     } else {
       console.log('‚ùå FALHA: ORGANISTA n√£o est√° sendo detectado como cargo musical');
     }
     
     console.log('üß™ TESTE CONCLU√çDO');
   }
   
   // üß™ FUN√á√ÉO DE TESTE: Verificar se erro de inicializa√ß√£o foi corrigido
   async function testarCorrecaoErroInicializacao() {
     console.log('üß™ TESTE: Verificando se erro de inicializa√ß√£o da vari√°vel classe foi corrigido...');
     
     try {
       // Simula dados de teste que causavam o erro
       const dadosTeste = {
         nomeCompleto: 'HELENA PINHEIRO RODRIGUES',
         comum: 'JARDIM MARGARIDA',
         cargo: 'ORGANISTA',
         instrumento: '√ìRG√ÉO'
       };
       
       console.log('üß™ Dados de teste:', dadosTeste);
       
       // Simula a l√≥gica que causava o erro
       const isCargoMusical = dadosTeste.cargo && (
         dadosTeste.cargo.toUpperCase().includes('EXAMINADORA') ||
         dadosTeste.cargo.toUpperCase().includes('INSTRUTORA') ||
         // Removido: INSTRUTOR n√£o deve receber classe de organista
         (dadosTeste.cargo.toLowerCase().includes('secret√°ria') && dadosTeste.cargo.toLowerCase().includes('m√∫sica'))
       );
       
       console.log('üß™ isCargoMusical:', isCargoMusical);
       
       // Declara a vari√°vel classe no in√≠cio (como na corre√ß√£o)
       let classe = null;
       
       // Testa a condi√ß√£o que causava o erro
       if (isCargoMusical && dadosTeste.nomeCompleto && dadosTeste.comum && !classe) {
         console.log('‚úÖ CONDI√á√ÉO TESTADA: Vari√°vel classe acessada sem erro');
         console.log('‚úÖ RESULTADO: Erro de inicializa√ß√£o foi corrigido');
       } else {
         console.log('‚ÑπÔ∏è CONDI√á√ÉO N√ÉO ATENDIDA: Cargo n√£o √© musical ou classe j√° existe');
       }
       
       console.log('üß™ TESTE CONCLU√çDO COM SUCESSO');
       console.log('üí° A vari√°vel classe agora √© declarada no in√≠cio da fun√ß√£o collectFormData');
       console.log('üí° Isso evita o erro "Cannot access before initialization"');
       
     } catch (error) {
       console.error('‚ùå ERRO NO TESTE:', error);
       console.log('‚ùå O erro ainda persiste');
     }
   }
   
   // üß™ FUN√á√ÉO DE TESTE: Verificar detec√ß√£o de Secret√°rio da M√∫sica
   async function testarDetecaoSecretarioMusica() {
     console.log('üß™ TESTE: Verificando detec√ß√£o de Secret√°rio da M√∫sica...');
     
     // Simula dados de teste
     const nomeTeste = 'FL√ÅVIA APARECIDA DE MORAES NASCIMENTO';
     const comumTeste = 'JARDIM COTIA';
     const cargoTeste = 'ORGANISTA'; // Cargo selecionado no formul√°rio
     
     console.log('üß™ Dados de teste:', { nomeTeste, comumTeste, cargoTeste });
     
     if (!supabaseLoaded || !sb) {
       console.error('‚ùå Supabase n√£o dispon√≠vel para teste');
       return;
     }
     
     try {
       // Busca no banco para ver se a pessoa √© Secret√°ria da M√∫sica
       const { data, error } = await sb
         .from(TABLE_CATALOGO)
         .select('nome, cargo, nivel, instrumento, comum')
         .ilike('comum', `%${comumTeste}%`)
         .ilike('nome', `%${nomeTeste}%`)
         .or('cargo.ilike.%ORGANISTA%,cargo.ilike.%EXAMINADORA%,cargo.ilike.%INSTRUTOR%,cargo.ilike.%INSTRUTORA%,cargo.ilike.%SECRET√ÅRIO DA M√öSICA%,cargo.ilike.%SECRET√ÅRIA DA M√öSICA%,cargo.ilike.%SECRET√ÅRIO DO GEM%,cargo.ilike.%SECRET√ÅRIA DO GEM%')
         .eq('ativo', true)
         .order('cargo', { ascending: true });
       
       console.log('üß™ Resultado da consulta:', { data, error });
       
       if (data && data.length > 0) {
         console.log('üß™ Registros encontrados:');
         data.forEach((r, index) => {
           console.log(`  ${index + 1}. Nome: "${r.nome}", Cargo: "${r.cargo}", Instrumento: "${r.instrumento}", Comum: "${r.comum}"`);
         });
         
         // Verifica se h√° cargo de Secret√°rio/Secret√°ria da M√∫sica
         const secretarioMusica = data.find(r => 
           r.cargo && r.cargo.toUpperCase().includes('SECRET√ÅRIO') && r.cargo.toUpperCase().includes('M√öSICA')
         );
         
         const secretariaMusica = data.find(r => 
           r.cargo && r.cargo.toUpperCase().includes('SECRET√ÅRIA') && r.cargo.toUpperCase().includes('M√öSICA')
         );
         
         if (secretarioMusica) {
           console.log('‚úÖ SECRET√ÅRIO DA M√öSICA ENCONTRADO:', secretarioMusica);
           console.log('üéØ Cargo correto deveria ser:', secretarioMusica.cargo);
         } else if (secretariaMusica) {
           console.log('‚úÖ SECRET√ÅRIA DA M√öSICA ENCONTRADA:', secretariaMusica);
           console.log('üéØ Cargo correto deveria ser:', secretariaMusica.cargo);
         } else {
           console.log('‚ùå Nenhum cargo de Secret√°rio/Secret√°ria da M√∫sica encontrado');
         }
       } else {
         console.log('‚ùå Nenhum registro encontrado para a pessoa');
       }
       
     } catch (error) {
       console.error('‚ùå Erro no teste:', error);
     }
   }
   
   // üõ°Ô∏è FUN√á√ÉO DE EMERG√äNCIA: Limpar todas as duplica√ß√µes do sistema
   function limparTodasDuplicacoes() {
     console.log('üßπ LIMPEZA DE EMERG√äNCIA: Removendo todas as duplica√ß√µes...');
     
     let totalRemovidas = 0;
     
     // 1. Limpar fila offline principal
     const queue = getOfflineQueue();
     const cleanedQueue = removeDuplicatesFromQueue(queue);
     if (cleanedQueue.length !== queue.length) {
       totalRemovidas += (queue.length - cleanedQueue.length);
       setOfflineQueue(cleanedQueue);
       console.log(`üßπ Fila offline: ${queue.length - cleanedQueue.length} duplica√ß√µes removidas`);
     }
     
     // 2. Limpar fila local (Google Sheets)
     try {
       const filaLocal = safeGetItem('fila_envio', []);
       const uniqueLocal = [];
       const seenLocal = new Set();
       
       for (const item of filaLocal) {
         const key = `${item.nome || item.NOME || ''}_${item.comum || item.COMUM || ''}_${item.cargo || item.CARGO || ''}_${item.uuid || item.UUID || ''}`;
         
         if (!seenLocal.has(key)) {
           seenLocal.add(key);
           uniqueLocal.push(item);
         }
       }
       
       if (uniqueLocal.length !== filaLocal.length) {
         totalRemovidas += (filaLocal.length - uniqueLocal.length);
         safeSetItem('fila_envio', uniqueLocal);
         console.log(`üßπ Fila local: ${filaLocal.length - uniqueLocal.length} duplica√ß√µes removidas`);
       }
     } catch (error) {
       console.error('‚ùå Erro ao limpar fila local:', error);
     }
     
     // 3. Limpar fila Supabase
     try {
       const filaSupabase = safeGetItem('fila_supabase', []);
       const uniqueSupabase = [];
       const seenSupabase = new Set();
       
       for (const item of filaSupabase) {
         const key = `${item.nome || item.NOME || ''}_${item.comum || item.COMUM || ''}_${item.cargo || item.CARGO || ''}_${item.uuid || item.UUID || ''}`;
         
         if (!seenSupabase.has(key)) {
           seenSupabase.add(key);
           uniqueSupabase.push(item);
         }
       }
       
       if (uniqueSupabase.length !== filaSupabase.length) {
         totalRemovidas += (filaSupabase.length - uniqueSupabase.length);
         safeSetItem('fila_supabase', uniqueSupabase);
         console.log(`üßπ Fila Supabase: ${filaSupabase.length - uniqueSupabase.length} duplica√ß√µes removidas`);
       }
     } catch (error) {
       console.error('‚ùå Erro ao limpar fila Supabase:', error);
     }
     
     // Atualizar contadores
     updateQueueCount();
     atualizarContadorFila();
     
     console.log(`‚úÖ LIMPEZA CONCLU√çDA: ${totalRemovidas} duplica√ß√µes removidas do sistema`);
     
     // Duplica√ß√µes removidas - sem alertas
     
     return totalRemovidas;
   }
   
   function addToOfflineQueue(data) {
     try {
       // üö® VERIFICA√á√ÉO CR√çTICA: Verificar se j√° foi enviado ANTES de qualquer coisa
       // Isso previne que registros j√° enviados sejam adicionados √† fila
       const sentRecords = safeGetItem('sent_records', {});
     
     // Verificar por UUID
     const dataUuid = data.uuid || data.UUID;
     if (dataUuid) {
       const recordKey = `gs_${dataUuid}`;
       if (sentRecords[recordKey]) {
         console.warn('üö® BLOQUEIO CR√çTICO: Registro j√° foi enviado para Google Sheets (UUID):', dataUuid);
         console.warn('üö® BLOQUEIO CR√çTICO: N√ÉO ser√° adicionado √† fila para evitar duplica√ß√£o');
         return null; // N√£o adiciona √† fila
       }
       
       // üö® VERIFICA√á√ÉO ADICIONAL: Verificar tamb√©m por UUID no Supabase
       const supabaseKey = `sb_${dataUuid}`;
       if (sentRecords[supabaseKey]) {
         console.warn('üö® BLOQUEIO CR√çTICO: Registro j√° foi enviado para Supabase (UUID):', dataUuid);
         console.warn('üö® BLOQUEIO CR√çTICO: N√ÉO ser√° adicionado √† fila para evitar duplica√ß√£o');
         return null; // N√£o adiciona √† fila
       }
     }
     
     // Verificar por conte√∫do (nome + comum + cargo)
     const contentKey = `content_${(data.nome || data.NOME || '').trim()}_${(data.comum || data.COMUM || '').trim()}_${(data.cargo || data.CARGO || '').trim()}`.replace(/\s+/g, '_').toLowerCase();
     if (sentRecords[contentKey]) {
       console.warn('üö® BLOQUEIO CR√çTICO: Registro j√° foi enviado para Google Sheets (conte√∫do):', contentKey);
       console.warn('üö® BLOQUEIO CR√çTICO: N√ÉO ser√° adicionado √† fila para evitar duplica√ß√£o');
       return null; // N√£o adiciona √† fila
     }
     
     // üö® VERIFICA√á√ÉO ADICIONAL: Verificar se est√° na fila de processamento ativo
     if (window.activeSubmissions && dataUuid) {
       if (window.activeSubmissions.has(dataUuid)) {
         console.warn('üö® BLOQUEIO CR√çTICO: Registro est√° sendo processado agora (UUID):', dataUuid);
         console.warn('üö® BLOQUEIO CR√çTICO: N√ÉO ser√° adicionado √† fila para evitar duplica√ß√£o');
         return null; // N√£o adiciona √† fila
       }
     }
     
     const queue = getOfflineQueue();
     
     // üõ°Ô∏è VERIFICA√á√ÉO CR√çTICA: Prevenir duplica√ß√µes
     const existingRecord = queue.find(item => {
       // Verifica se j√° existe um registro com os mesmos dados essenciais
       const sameName = (item.data.nome || item.data.NOME) === (data.nome || data.NOME);
       const sameComum = (item.data.comum || item.data.COMUM) === (data.comum || data.COMUM);
       const sameCargo = (item.data.cargo || item.data.CARGO) === (data.cargo || data.CARGO);
       const sameTimestamp = Math.abs(item.timestamp - Date.now()) < 60000; // 60 segundos (aumentado para maior seguran√ßa)
       
       return sameName && sameComum && sameCargo && sameTimestamp;
     });
     
     if (existingRecord) {
       console.warn('‚ö†Ô∏è DUPLICA√á√ÉO PREVENIDA: Registro j√° existe na fila:', {
         nome: data.nome || data.NOME,
         comum: data.comum || data.COMUM,
         cargo: data.cargo || data.CARGO,
         existingId: existingRecord.id,
         timeDiff: Math.abs(existingRecord.timestamp - Date.now())
       });
       return existingRecord.id; // Retorna o ID do registro existente
     }
     
     // üö® VERIFICA√á√ÉO ADICIONAL: Verificar duplica√ß√µes por conte√∫do exato
     const exactDuplicate = queue.find(item => {
       const itemData = item.data;
       const newData = data;
       
       // Comparar todos os campos principais
       const sameData = (
         (itemData.nome || itemData.NOME) === (newData.nome || newData.NOME) &&
         (itemData.comum || itemData.COMUM) === (newData.comum || newData.COMUM) &&
         (itemData.cargo || itemData.CARGO) === (newData.cargo || newData.CARGO) &&
         (itemData.instrumento || itemData.INSTRUMENTO) === (newData.instrumento || newData.INSTRUMENTO) &&
         (itemData.cidade || itemData.CIDADE) === (newData.cidade || newData.CIDADE)
       );
       
       return sameData && Math.abs(item.timestamp - Date.now()) < 300000; // 5 minutos
     });
     
     if (exactDuplicate) {
       console.warn('‚ö†Ô∏è DUPLICA√á√ÉO PREVENIDA: Registro id√™ntico j√° existe na fila:', {
         nome: data.nome || data.NOME,
         comum: data.comum || data.COMUM,
         cargo: data.cargo || data.CARGO,
         existingId: exactDuplicate.id
       });
       return exactDuplicate.id;
     }
     
     // üõ°Ô∏è VERIFICA√á√ÉO ADICIONAL: UUID nos dados (j√° verificado acima, mas verificar na fila)
     // dataUuid j√° foi declarado e verificado acima
     if (dataUuid) {
       // Verifica se j√° existe um registro com o mesmo UUID na fila
       const existingByUuid = queue.find(item => 
         (item.data.uuid || item.data.UUID) === dataUuid
       );
       
       if (existingByUuid) {
         console.warn('‚ö†Ô∏è DUPLICA√á√ÉO PREVENIDA: UUID j√° existe na fila:', dataUuid);
         return existingByUuid.id;
       }
       
       // üö® VERIFICA√á√ÉO CR√çTICA: Verificar se UUID j√° foi processado (BLOQUEIO DEFINITIVO)
       const processedUuids = safeGetItem('processed_uuids', []);
       if (processedUuids.includes(dataUuid)) {
         console.warn('‚ö†Ô∏è DUPLICA√á√ÉO PREVENIDA: UUID j√° foi processado:', dataUuid);
         return null; // N√£o adiciona √† fila
       }
       
       // üõ°Ô∏è VERIFICA√á√ÉO CR√çTICA: Verificar se j√° foi enviado para Google Sheets (BLOQUEIO DEFINITIVO)
       // sentRecords j√° foi obtido acima, reutilizar
       const recordKey = `gs_${dataUuid}`;
       
       // Verifica√ß√£o DEFINITIVA - SEM TEMPO (j√° verificado acima, mas verificar novamente por seguran√ßa)
       if (sentRecords[recordKey]) {
         console.warn('‚ö†Ô∏è DUPLICA√á√ÉO PREVENIDA: Registro j√° foi enviado para Google Sheets:', dataUuid);
         return null; // N√£o adiciona √† fila
       }
     } else {
       // Gera UUID se n√£o existir
       const newUuid = uuidv4();
       data.uuid = newUuid;
       data.UUID = newUuid;
     }
     
     // Gerar ID √∫nico para o registro (SEMPRE UUID V√ÅLIDO)
     let recordId;
     try {
       recordId = uuidv4();
       
       // VERIFICA√á√ÉO OBRIGAT√ìRIA: UUID deve ser v√°lido
       if (!isValidUUID(recordId)) {
         console.error('‚ùå UUID gerado √© inv√°lido, tentando corrigir...');
         recordId = fixInvalidUUID(recordId);
       }
       
       // VERIFICA√á√ÉO FINAL: Se ainda n√£o for v√°lido, usar UUID de emerg√™ncia
       if (!isValidUUID(recordId)) {
         console.error('‚ùå CR√çTICO: N√£o foi poss√≠vel gerar UUID v√°lido!');
         recordId = '00000000-0000-4000-8000-000000000000';
       }
       
       console.log('‚úÖ UUID final validado:', recordId);
       
     } catch (error) {
       console.error('‚ùå ERRO CR√çTICO ao gerar UUID:', error);
       recordId = '00000000-0000-4000-8000-000000000000';
     }
     
     const record = {
       id: recordId,
       data: data,
       timestamp: Date.now(),
       attempts: 0,
       synced: false
     };
     
     queue.push(record);
     setOfflineQueue(queue);
     
     // üö® CORRE√á√ÉO CR√çTICA: Registrar UUID como processado para evitar duplica√ß√µes futuras
     if (dataUuid) {
       const processedUuids = JSON.parse(localStorage.getItem('processed_uuids') || '[]');
       if (!processedUuids.includes(dataUuid)) {
         processedUuids.push(dataUuid);
         // Manter apenas os √∫ltimos 100 UUIDs para n√£o sobrecarregar o localStorage
         if (processedUuids.length > 100) {
           processedUuids.splice(0, processedUuids.length - 100);
         }
         localStorage.setItem('processed_uuids', JSON.stringify(processedUuids));
       }
     }
     
     console.log('üìã Registro adicionado √† fila offline:', recordId);
     console.log('üìã Total de itens na fila:', queue.length);
     
     // Log espec√≠fico para mobile
     if (isMobile) {
       console.log('üì± MOBILE: Registro adicionado √† fila offline:', {
         id: recordId,
         nome: data.nome || data.NOME || 'Sem nome',
         comum: data.comum || data.COMUM || 'Sem comum',
         cargo: data.cargo || data.CARGO || 'Sem cargo',
         timestamp: new Date().toLocaleTimeString()
       });
     }
     
     // Tentar processar imediatamente se online
     if (navigator.onLine) {
       setTimeout(async () => {
         try {
           const isOnline = await checkSupabaseConnection();
           if (isOnline) {
             await processOfflineQueue();
           }
         } catch (error) {
           console.error('‚ùå Erro no processamento imediato:', error);
         }
       }, 1000);
     }
     
     // üö® CORRE√á√ÉO: Retornar o ID do registro para confirmar que foi adicionado
     return recordId;
     } catch (error) {
       console.error('‚ùå ERRO CR√çTICO em addToOfflineQueue:', error);
       console.error('‚ùå Stack trace:', error.stack);
       console.error('‚ùå Dados que causaram o erro:', data);
       // Retornar null em caso de erro para n√£o quebrar o fluxo
       return null;
     }
   }
   
   function updateQueueCount() {
     const queue = getOfflineQueue();
     const pendingCount = queue.filter(item => !item.synced).length;
     
     // Atualizar elementos da UI se existirem
     const queueCountEl = document.getElementById('queue-count');
     const queueStatusEl = document.getElementById('queue-status');
     
     if (queueCountEl) {
       queueCountEl.textContent = pendingCount;
       
       // Atualizar status do badge
       if (queueStatusEl) {
         if (pendingCount > 0) {
           queueStatusEl.className = 'queue-badge pending';
           queueStatusEl.textContent = 'PENDENTE';
         } else {
           queueStatusEl.className = 'queue-badge empty';
           queueStatusEl.textContent = 'VAZIO';
         }
       }
       
       console.log(`üìã Fila offline: ${pendingCount} registro(s) pendente(s) de ${queue.length} total`);
     }
   }
   
   async function processOfflineQueue() {
     // Verificar se j√° est√° processando para evitar m√∫ltiplas execu√ß√µes simult√¢neas
     if (window.offlineQueueProcessing) {
       console.log('‚è≥ Processamento da fila offline j√° em andamento, aguardando...');
       return;
     }
     
     window.offlineQueueProcessing = true;
     
     // üö® CORRE√á√ÉO: Inicializar conjunto de processamento ativo se n√£o existir
     if (!window.activeSubmissions) {
       window.activeSubmissions = new Set();
       console.log('üîß Conjunto de processamento ativo inicializado');
     }
     
     try {
       const queue = getOfflineQueue();
       
       // üõ°Ô∏è LIMPEZA CR√çTICA: Remover duplica√ß√µes antes de processar
       const cleanedQueue = removeDuplicatesFromQueue(queue);
       if (cleanedQueue.length !== queue.length) {
         console.log(`üßπ Removidas ${queue.length - cleanedQueue.length} duplica√ß√µes da fila`);
         setOfflineQueue(cleanedQueue);
       }
       
       const pendingItems = cleanedQueue.filter(item => !item.synced);
       
       if (pendingItems.length === 0) {
         console.log('üìã Nenhum item pendente na fila offline');
         return;
       }
       
       console.log(`üîÑ Processando ${pendingItems.length} itens da fila offline...`);
       
       // üö® CORRE√á√ÉO CR√çTICA: Verificar conectividade REAL antes de processar
       // navigator.onLine pode ser falso positivo, ent√£o verificamos com checkSupabaseConnection
       const isReallyOnline = await checkSupabaseConnection();
       if (!isReallyOnline) {
         console.log('üì¥ Sem conex√£o real - pulando processamento da fila');
         window.offlineQueueProcessing = false; // Liberar lock
         return;
       }
       
       console.log('‚úÖ Conectividade confirmada - processando fila offline');
       
       const processedItems = [];
       const failedItems = [];
       
       for (const item of pendingItems) {
         try {
           // üõ°Ô∏è VERIFICA√á√ÉO CR√çTICA MELHORADA: Verificar se j√° foi enviado recentemente (m√∫ltiplas camadas)
           const uuid = item.data.uuid || item.data.UUID;
           
           // Valida√ß√£o de dados antes de processar
           if (!item.data.cargo || item.data.cargo.trim() === '') {
             console.warn(`‚ö†Ô∏è Item ${item.id}: Cargo vazio - removendo da fila`);
             processedItems.push(item); // Remove da fila
             continue;
           }
           
           if (!item.data.nome || item.data.nome.trim() === '') {
             console.warn(`‚ö†Ô∏è Item ${item.id}: Nome vazio - removendo da fila`);
             processedItems.push(item); // Remove da fila
             continue;
           }
           
           if (uuid) {
             const sentRecords = safeGetItem('sent_records', {});
             
             // 1. Verifica√ß√£o DEFINITIVA por UUID - SEM TEMPO
             const recordKey = `gs_${uuid}`;
             if (sentRecords[recordKey]) {
               console.log(`‚úÖ Item ${item.id}: J√° foi enviado (BLOQUEIO DEFINITIVO - UUID), marcando como sincronizado`);
               item.synced = true;
               item.syncedAt = Date.now();
               processedItems.push(item);
               continue;
             }
             
             // 2. Verifica√ß√£o DEFINITIVA por conte√∫do - SEM TEMPO
             const contentKey = `content_${(item.data.nome || '').trim()}_${(item.data.comum || '').trim()}_${(item.data.cargo || '').trim()}`.replace(/\s+/g, '_').toLowerCase();
             
             // Log espec√≠fico para irmandade
             const cargoItemUpper = (item.data.cargo || '').toUpperCase();
             const isIrmandadeCheck = cargoItemUpper.includes('IRMANDADE');
             if (isIrmandadeCheck) {
               console.log(`üîç DEBUG IRMANDADE - Verifica√ß√£o de duplica√ß√£o:`, {
                 contentKey: contentKey,
                 sentRecordsHasKey: !!sentRecords[contentKey],
                 sentRecordsValue: sentRecords[contentKey]
               });
             }
             
             if (sentRecords[contentKey]) {
               console.log(`‚úÖ Item ${item.id}: J√° foi enviado (BLOQUEIO DEFINITIVO - CONTE√öDO), marcando como sincronizado`);
               if (isIrmandadeCheck) {
                 console.log(`üîç DEBUG IRMANDADE - Item marcado como j√° enviado por conte√∫do:`, contentKey);
               }
               item.synced = true;
               item.syncedAt = Date.now();
               processedItems.push(item);
               continue;
             }
           }
           
           // Log espec√≠fico para irmandade
           const cargoItem = (item.data.cargo || '').toUpperCase();
           const isIrmandade = cargoItem.includes('IRMANDADE');
           
           if (isIrmandade) {
             console.log(`üîç DEBUG IRMANDADE - Item ${item.id}:`, {
               uuid: item.data.uuid,
               nome: item.data.nome,
               comum: item.data.comum,
               cargo: item.data.cargo,
               cargoUpper: cargoItem
             });
           }
           
           // üö® VERIFICA√á√ÉO CR√çTICA DE DUPLICATAS NO BANCO: Verificar antes de processar
           const nomeVerificacao = item.data.nome || item.data.NOME || item.data['NOME COMPLETO'] || '';
           const comumVerificacao = item.data.comum || item.data.COMUM || '';
           const cargoVerificacao = item.data.cargo || item.data.CARGO || '';
           
           if (supabaseLoaded && sb && nomeVerificacao && comumVerificacao && cargoVerificacao) {
             try {
               const dataAtual = new Date();
               const dataISO = dataAtual.toISOString().split('T')[0];
               
               // Buscar registros duplicados (mesmo nome + comum + cargo no mesmo dia)
               const { data: duplicatas, error: dupError } = await sb
                 .from(TABLE_PRESENCAS)
                 .select('nome_completo, comum, cargo, created_at, uuid')
                 .ilike('nome_completo', `%${nomeVerificacao.trim()}%`)
                 .ilike('comum', `%${comumVerificacao.trim()}%`)
                 .gte('created_at', `${dataISO}T00:00:00.000Z`)
                 .lt('created_at', `${dataISO}T23:59:59.999Z`)
                 .limit(10);
               
               if (!dupError && duplicatas && duplicatas.length > 0) {
                 // Verificar se h√° duplicata exata (mesmo nome, comum e cargo)
                 const duplicataExata = duplicatas.find(d => {
                   const nomeMatch = norm(d.nome_completo || '').toUpperCase().trim() === norm(nomeVerificacao).toUpperCase().trim();
                   const comumMatch = compareComum(d.comum || '', comumVerificacao).match;
                   const cargoMatch = norm(d.cargo || '').toUpperCase().trim() === norm(cargoVerificacao).toUpperCase().trim();
                   return nomeMatch && comumMatch && cargoMatch;
                 });
                 
                 if (duplicataExata) {
                   // üö® CORRE√á√ÉO: Verificar se usu√°rio confirmou a duplicata antes de bloquear
                   const duplicataConfirmada = item.data.duplicataConfirmadaPeloUsuario === true || 
                                               item.data.duplicataConfirmadaPeloUsuario === 'true';
                   const platformType = isMobile ? 'MOBILE' : 'DESKTOP';
                   
                   if (duplicataConfirmada) {
                     console.log(`‚úÖ ${platformType}: Item ${item.id}: Duplicata confirmada pelo usu√°rio - permitindo envio mesmo com duplicata existente`, {
                       itemId: item.id,
                       nome: nomeVerificacao,
                       comum: comumVerificacao,
                       cargo: cargoVerificacao,
                       flagNoItem: item.data.duplicataConfirmadaPeloUsuario
                     });
                     // N√£o bloqueia - continua o processamento normalmente
                   } else {
                     console.log(`‚ö†Ô∏è ${platformType}: Item ${item.id}: Duplicata detectada mas flag n√£o est√° ativa - bloqueando`);
                     console.error(`üö®üö®üö® DUPLICATA DETECTADA NA FILA OFFLINE - BLOQUEANDO PROCESSAMENTO üö®üö®üö®`, {
                       itemId: item.id,
                       nome: nomeVerificacao,
                       comum: comumVerificacao,
                       cargo: cargoVerificacao,
                       uuidExistente: duplicataExata.uuid,
                       dataExistente: duplicataExata.created_at
                     });
                     
                     // üö® BLOQUEIO COMPLETO: Marcar como sincronizado para n√£o tentar novamente
                     item.synced = true;
                     item.syncedAt = Date.now();
                     processedItems.push(item);
                     console.log(`‚úÖ Item ${item.id}: Duplicata detectada - marcado como sincronizado (n√£o ser√° enviado)`);
                     continue;
                   }
                 }
               }
             } catch (error) {
               // Se n√£o conseguir verificar, continua o processamento (n√£o bloqueia)
               console.warn(`‚ö†Ô∏è Erro ao verificar duplicatas para item ${item.id}:`, error);
             }
           }
           
           // üö® CORRE√á√ÉO: Se item tem flag de duplicata confirmada, definir flag global antes de enviar
           const duplicataConfirmadaNoItem = item.data.duplicataConfirmadaPeloUsuario === true || 
                                             item.data.duplicataConfirmadaPeloUsuario === 'true';
           const platformType = isMobile ? 'MOBILE' : 'DESKTOP';
           if (duplicataConfirmadaNoItem) {
             window._duplicataConfirmadaPeloUsuario = true;
             console.log(`‚úÖ ${platformType}: Item ${item.id}: Flag de duplicata confirmada detectada - definindo flag global para permitir envio`);
             console.log(`‚úÖ ${platformType}: Flag window._duplicataConfirmadaPeloUsuario definida como:`, window._duplicataConfirmadaPeloUsuario);
           } else {
             console.log(`üîç ${platformType}: Item ${item.id}: Flag de duplicata N√ÉO encontrada no item (item.data.duplicataConfirmadaPeloUsuario =`, item.data.duplicataConfirmadaPeloUsuario, ')');
           }
           
           console.log(`üì§ Enviando item ${item.id}...`);
           console.log(`üì§ Item ${item.id} - Dados:`, {
             nome: item.data.nome || item.data.NOME,
             comum: item.data.comum || item.data.COMUM,
             cargo: item.data.cargo || item.data.CARGO,
             uuid: item.data.uuid || item.data.UUID
           });
           
           // üö® CORRE√á√ÉO CR√çTICA: Marcar como "em processamento" ANTES de enviar
           // Isso previne que o mesmo item seja processado m√∫ltiplas vezes durante oscila√ß√£o
           const itemUuid = item.data.uuid || item.data.UUID;
           if (itemUuid && window.activeSubmissions) {
             if (window.activeSubmissions.has(itemUuid)) {
               console.warn(`‚ö†Ô∏è Item ${item.id}: J√° est√° sendo processado (UUID: ${itemUuid}) - pulando`);
               continue; // Pula este item se j√° est√° sendo processado
             }
             window.activeSubmissions.add(itemUuid);
             console.log(`üîí Item ${item.id}: Marcado como em processamento (UUID: ${itemUuid})`);
           }
           
           // üö® CORRE√á√ÉO CR√çTICA: Tentar enviar para Google Sheets PRIMEIRO
           // A l√≥gica deve ser: Google Sheets primeiro, depois Supabase
           let googleSheetsSuccess = false;
           try {
             console.log(`üì§ Item ${item.id} - Chamando sendToGoogleSheets...`);
             googleSheetsSuccess = await sendToGoogleSheets(item.data);
             console.log(`üì§ Item ${item.id} - Google Sheets resultado:`, googleSheetsSuccess);
             
             // üö® VALIDA√á√ÉO ADICIONAL: Verificar se realmente retornou true
             if (googleSheetsSuccess === true) {
               console.log(`‚úÖ Item ${item.id} - Google Sheets confirmou sucesso (retornou true)`);
             } else {
               console.error(`‚ùå Item ${item.id} - Google Sheets retornou false ou valor inv√°lido:`, googleSheetsSuccess);
               googleSheetsSuccess = false;
             }
           } catch (gsError) {
             console.error(`‚ùå Item ${item.id} - Erro ao enviar para Google Sheets:`, gsError);
             console.error(`‚ùå Item ${item.id} - Detalhes do erro:`, {
               message: gsError.message,
               name: gsError.name,
               stack: gsError.stack?.substring(0, 300)
             });
             googleSheetsSuccess = false;
           }
           
           // üö® CORRE√á√ÉO: Limpar flag ap√≥s envio para n√£o afetar pr√≥ximos itens
           if (duplicataConfirmadaNoItem) {
             window._duplicataConfirmadaPeloUsuario = false;
           }
           
           if (isIrmandade) {
             console.log(`üîç DEBUG IRMANDADE - Resultado do envio:`, googleSheetsSuccess);
           }
           
           // üö® CORRE√á√ÉO CR√çTICA: S√≥ marcar como sincronizado se Google Sheets foi bem-sucedido
           if (googleSheetsSuccess) {
             console.log(`‚úÖ Item ${item.id}: Google Sheets OK - enviando para Supabase...`);
             
             // üõ°Ô∏è CORRE√á√ÉO: Tamb√©m enviar para Supabase quando Google Sheets for bem-sucedido
             let supabaseSuccess = false;
             if (supabaseLoaded && sb) {
               try {
                 const supabaseResult = await insertSupabase(item.data);
                 console.log(`‚úÖ Item ${item.id}: Supabase OK - resultado:`, supabaseResult);
                 
                 // üö® VALIDA√á√ÉO: Verificar se realmente inseriu
                 if (supabaseResult && (supabaseResult.success === true || supabaseResult.data)) {
                   supabaseSuccess = true;
                   console.log(`‚úÖ Item ${item.id}: Supabase confirmou inser√ß√£o bem-sucedida`);
                 } else {
                   console.warn(`‚ö†Ô∏è Item ${item.id}: Supabase retornou resultado inesperado:`, supabaseResult);
                   // Ainda considera sucesso se n√£o houve erro
                   supabaseSuccess = true;
                 }
               } catch (e) {
                 // üö® TRATAMENTO ESPEC√çFICO: Se for erro de duplicata bloqueada, considera sucesso e marca como sincronizado
                 if (e.message && e.message.includes('DUPLICATA_BLOQUEADA')) {
                   console.log(`‚úÖ Item ${item.id}: Duplicata bloqueada - registro j√° existe no Supabase (n√£o ser√° enviado)`);
                   supabaseSuccess = true; // Considera sucesso pois j√° existe
                 } else if (e.code === '23505' || e.message.includes('duplicate key') || e.message.includes('already exists')) {
                   console.log(`‚úÖ Item ${item.id}: Registro j√° existe no Supabase (duplica√ß√£o evitada)`);
                   supabaseSuccess = true; // Considera sucesso pois j√° existe
                 } else {
                   console.error(`‚ùå Item ${item.id}: Erro no Supabase:`, e.message);
                   console.error(`‚ùå Item ${item.id}: Detalhes do erro Supabase:`, {
                     code: e.code,
                     message: e.message,
                     details: e.details
                   });
                   // üö® CORRE√á√ÉO: Mesmo com erro no Supabase, se Google Sheets foi OK, marca como sincronizado
                   // O importante √© que foi salvo no Google Sheets
                   supabaseSuccess = false; // Mas n√£o bloqueia o envio
                 }
               }
             } else {
               console.warn(`‚ö†Ô∏è Item ${item.id}: Supabase n√£o dispon√≠vel - apenas Google Sheets foi salvo`);
               supabaseSuccess = true; // Considera sucesso se Supabase n√£o est√° dispon√≠vel
             }
             
             // üö® CORRE√á√ÉO CR√çTICA: S√≥ marca como sincronizado se Google Sheets foi bem-sucedido
             // Supabase √© opcional - se falhar mas Google Sheets salvou, ainda marca como sincronizado
             item.synced = true;
             item.syncedAt = Date.now();
             processedItems.push(item);
             
             // üö® CORRE√á√ÉO: Remover do conjunto de processamento ativo ap√≥s sucesso
             if (itemUuid && window.activeSubmissions) {
               window.activeSubmissions.delete(itemUuid);
               console.log(`üîì Item ${item.id}: Removido do conjunto de processamento (UUID: ${itemUuid})`);
             }
             
             console.log(`‚úÖ Item ${item.id} enviado com sucesso (Google Sheets: OK, Supabase: ${supabaseSuccess ? 'OK' : 'Falhou mas n√£o bloqueia'})`);
           } else {
             // üö® CORRE√á√ÉO CR√çTICA: Se Google Sheets falhou, N√ÉO marca como sincronizado
             item.attempts = (item.attempts || 0) + 1;
             failedItems.push(item);
             
             // üö® CORRE√á√ÉO: Remover do conjunto de processamento ativo ap√≥s falha
             if (itemUuid && window.activeSubmissions) {
               window.activeSubmissions.delete(itemUuid);
               console.log(`üîì Item ${item.id}: Removido do conjunto de processamento ap√≥s falha (UUID: ${itemUuid})`);
             }
             
             console.error(`‚ùå Falha ao enviar item ${item.id} para Google Sheets (tentativa ${item.attempts}) - N√ÉO ser√° marcado como sincronizado`);
           }
           
           // üö® CORRE√á√ÉO: Pausa aumentada para 200ms (era 50ms - muito curto quebrava a l√≥gica)
           await new Promise(resolve => setTimeout(resolve, 200));
           
         } catch (error) {
           // üö® CORRE√á√ÉO: Remover do conjunto de processamento ativo em caso de erro
           const itemUuidError = item.data.uuid || item.data.UUID;
           if (itemUuidError && window.activeSubmissions) {
             window.activeSubmissions.delete(itemUuidError);
             console.log(`üîì Item ${item.id}: Removido do conjunto de processamento ap√≥s erro (UUID: ${itemUuidError})`);
           }
           
           // üö® TRATAMENTO ESPEC√çFICO: Se for erro de duplicata bloqueada, marca como sincronizado
           if (error.message && error.message.includes('DUPLICATA_BLOQUEADA')) {
             console.log(`‚úÖ Item ${item.id}: Duplicata bloqueada - registro j√° existe (n√£o ser√° enviado)`);
             item.synced = true;
             item.syncedAt = Date.now();
             processedItems.push(item);
           } else {
             // üö® CORRE√á√ÉO CR√çTICA: Se Google Sheets falhou, N√ÉO marca como sincronizado
             console.error(`‚ùå Erro ao processar item ${item.id}:`, error);
             console.error(`‚ùå Item ${item.id} - Erro detalhado:`, {
               message: error.message,
               name: error.name,
               stack: error.stack?.substring(0, 200)
             });
             
             // Verificar se foi erro de Google Sheets
             const isGoogleSheetsError = error.message && (
               error.message.includes('Google Sheets') ||
               error.message.includes('Sem conex√£o') ||
               error.message.includes('Failed to fetch') ||
               error.message.includes('NetworkError')
             );
             
             if (isGoogleSheetsError) {
               console.error(`üö® Item ${item.id}: Erro no Google Sheets - N√ÉO ser√° marcado como sincronizado`);
             }
             
             item.attempts = (item.attempts || 0) + 1;
             failedItems.push(item);
             console.error(`‚ùå Item ${item.id} adicionado √† lista de falhas (tentativa ${item.attempts})`);
           }
         }
       }
       
       // Atualizar fila removendo itens processados
       const updatedQueue = cleanedQueue.map(item => {
         const processed = processedItems.find(p => p.id === item.id);
         return processed || item;
       });
       
       setOfflineQueue(updatedQueue);
       
       if (processedItems.length > 0) {
         console.log(`‚úÖ ${processedItems.length} itens processados com sucesso`);
         // showToast('success', 'Sincronizado', `${processedItems.length} registro(s) enviado(s)`, 2000); // Removido - alerta desnecess√°rio
       }
       
       if (failedItems.length > 0) {
         console.log(`‚ö†Ô∏è ${failedItems.length} itens falharam e ser√£o tentados novamente`);
       }
       
     } catch (error) {
       console.error('‚ùå Erro geral no processamento da fila offline:', error);
     } finally {
       // üö® CORRE√á√ÉO: Sempre liberar o lock
       window.offlineQueueProcessing = false;
       
       // üö® CORRE√á√ÉO: Limpar conjunto de processamento ativo para itens que foram processados
       // Isso previne que itens fiquem "travados" no conjunto
       if (window.activeSubmissions) {
         const queueAfter = getOfflineQueue();
         const processedUuids = new Set();
         queueAfter.forEach(item => {
           if (item.synced) {
             const uuid = item.data.uuid || item.data.UUID;
             if (uuid) processedUuids.add(uuid);
           }
         });
         
         // Remover apenas UUIDs que foram realmente processados
         processedUuids.forEach(uuid => {
           window.activeSubmissions.delete(uuid);
         });
         
         if (processedUuids.size > 0) {
           console.log(`üßπ Limpeza: ${processedUuids.size} UUID(s) removido(s) do conjunto de processamento ativo`);
         }
       }
     }
   }
   
   // üöÄ FUN√á√ÉO PARA APLICAR REGRAS DE G√äNERO: Padronizar "oficializado(a)" para "oficializada"
   function aplicarRegrasGenero(data) {
     if (!data) return data;
     
     // Cria uma c√≥pia dos dados para n√£o modificar o original
     const dadosProcessados = { ...data };
     
     // Lista de campos que podem conter "oficializado(a)"
     const camposParaProcessar = [
       'classe', 'CLASSE', 'nivel', 'NIVEL', 
       'classe_organista', 'CLASSE_ORGANISTA'
     ];
     
     // Processa cada campo
     camposParaProcessar.forEach(campo => {
       if (dadosProcessados[campo] && typeof dadosProcessados[campo] === 'string') {
         const valorOriginal = dadosProcessados[campo];
         
         // Aplica a regra: "OFICIALIZADO(A)" ‚Üí "OFICIALIZADA"
         let valorProcessado = valorOriginal;
         
         // Verifica se tem prefixo (ex: "RJM / OFICIALIZADO(A)")
         if (valorProcessado.includes('/')) {
           const partes = valorProcessado.split('/');
           const prefixo = partes[0].trim();
           const sufixo = partes[1].trim();
           
           // Remove "(A)" do sufixo e padroniza para "OFICIALIZADA"
           const sufixoPadronizado = sufixo.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
           valorProcessado = `${prefixo} / ${sufixoPadronizado}`;
         } else {
           // Se n√£o tem prefixo, apenas padroniza para "OFICIALIZADA"
           valorProcessado = valorProcessado.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
         }
         
         // S√≥ atualiza se houve mudan√ßa
         if (valorProcessado !== valorOriginal) {
           dadosProcessados[campo] = valorProcessado;
           console.log(`üöÄ Regra de g√™nero aplicada no campo ${campo}:`, valorOriginal, '‚Üí', valorProcessado);
         }
       }
     });
     
     return dadosProcessados;
   }

   // üöÄ FUN√á√ÉO ULTRA-OTIMIZADA: Envio r√°pido para Google Sheets
   async function sendToGoogleSheets(data) {
     try {
       // üöÄ APLICAR REGRA DE G√äNERO: Padronizar "oficializado(a)" para "oficializada"
       const dadosProcessados = aplicarRegrasGenero(data);
       console.log('üöÄ Regras de g√™nero aplicadas:', dadosProcessados);
       
       // üö® VERIFICA√á√ÉO ROBUSTA DE DUPLICATAS: Verificar se usu√°rio j√° confirmou duplicata
       // Se o usu√°rio confirmou no modal, n√£o bloquear novamente
       const duplicataJaConfirmada = window._duplicataConfirmadaPeloUsuario === true;
       
       if (duplicataJaConfirmada) {
         console.log('‚úÖ Usu√°rio j√° confirmou duplicata - permitindo cadastro');
         // Limpar flag ap√≥s usar
         window._duplicataConfirmadaPeloUsuario = false;
         // Pular verifica√ß√£o de duplicata
       } else {
         // üö® VERIFICA√á√ÉO ROBUSTA DE DUPLICATAS: Verificar no Supabase antes de enviar
         const nomeVerificacao = dadosProcessados.nome || dadosProcessados.NOME || '';
         const comumVerificacao = dadosProcessados.comum || dadosProcessados.COMUM || '';
         const cargoVerificacao = dadosProcessados.cargo || dadosProcessados.CARGO || '';
         let isDuplicata = false;
         let duplicataInfo = null;
         
         // Verificar duplicatas no Supabase se dispon√≠vel
         if (supabaseLoaded && sb && nomeVerificacao && comumVerificacao) {
           try {
             const dataAtual = new Date();
             const dataISO = dataAtual.toISOString().split('T')[0];
             
             // Buscar registros duplicados (mesmo nome + comum + cargo no mesmo dia)
             const { data: duplicatas, error: dupError } = await sb
               .from('presencas')
               .select('nome_completo, comum, cargo, created_at, uuid')
               .ilike('nome_completo', `%${nomeVerificacao.trim()}%`)
               .ilike('comum', `%${comumVerificacao.trim()}%`)
               .gte('created_at', `${dataISO}T00:00:00.000Z`)
               .lt('created_at', `${dataISO}T23:59:59.999Z`)
               .limit(10);
             
             if (!dupError && duplicatas && duplicatas.length > 0) {
               // Verificar se h√° duplicata exata (mesmo nome, comum e cargo)
               const duplicataExata = duplicatas.find(d => {
                 const nomeMatch = norm(d.nome_completo || '').toUpperCase().trim() === norm(nomeVerificacao).toUpperCase().trim();
                 const comumMatch = compareComum(d.comum || '', comumVerificacao).match;
                 const cargoMatch = norm(d.cargo || '').toUpperCase().trim() === norm(cargoVerificacao).toUpperCase().trim();
                 return nomeMatch && comumMatch && cargoMatch;
               });
               
               if (duplicataExata) {
                 isDuplicata = true;
                 duplicataInfo = {
                   encontrada: true,
                   uuid: duplicataExata.uuid,
                   data: duplicataExata.created_at,
                   totalEncontradas: duplicatas.length
                 };
                 console.error('üö®üö®üö® DUPLICATA DETECTADA NO SUPABASE - BLOQUEANDO ENVIO üö®üö®üö®', {
                   nome: nomeVerificacao,
                   comum: comumVerificacao,
                   cargo: cargoVerificacao,
                   uuidExistente: duplicataExata.uuid,
                   dataExistente: duplicataExata.created_at
                 });
                 // üö® BLOQUEIO COMPLETO: Retornar erro para impedir envio
                 throw new Error(`DUPLICATA_BLOQUEADA: Registro duplicado detectado. ${nomeVerificacao} de ${comumVerificacao} j√° foi cadastrado hoje.`);
               }
             }
           } catch (error) {
             // Se o erro for de duplicata bloqueada, propagar o erro
             if (error.message && error.message.includes('DUPLICATA_BLOQUEADA')) {
               throw error;
             }
             console.warn('‚ö†Ô∏è Erro ao verificar duplicatas no Supabase:', error);
             // Continua o envio apenas se n√£o for erro de duplicata
           }
         }
       }
       
       // üõ°Ô∏è BLOQUEIO DEFINITIVO DE DUPLICA√á√ïES: Verifica√ß√£o permanente (sem tempo)
       const uuid = dadosProcessados.uuid || dadosProcessados.UUID;
       
       if (uuid) {
         // üõ°Ô∏è FALLBACK: Usar wrapper universal para acesso consistente
         let sentRecords = safeGetItem('sent_records', {});
         
         // 1. Verifica√ß√£o DEFINITIVA por UUID - SEM LIMITE DE TEMPO
         const recordKey = `gs_${uuid}`;
         if (sentRecords[recordKey]) {
           console.warn('‚ö†Ô∏è DUPLICA√á√ÉO BLOQUEADA DEFINITIVAMENTE (UUID): Registro j√° foi enviado:', uuid);
           return true; // Retorna sucesso para evitar nova tentativa
         }
         
         // 2. Verifica√ß√£o DEFINITIVA por conte√∫do (nome + comum + cargo) - SEM LIMITE DE TEMPO
         const contentKey = `content_${(dadosProcessados.nome || '').trim()}_${(dadosProcessados.comum || '').trim()}_${(dadosProcessados.cargo || '').trim()}`.replace(/\s+/g, '_').toLowerCase();
         if (sentRecords[contentKey]) {
           console.warn('‚ö†Ô∏è DUPLICA√á√ÉO BLOQUEADA DEFINITIVAMENTE (CONTE√öDO): Registro id√™ntico j√° foi enviado:', contentKey);
           return true;
         }
         
         // 3. Verifica√ß√£o na fila de processamento ativo (evita envios simult√¢neos)
         if (window.activeSubmissions && window.activeSubmissions.has(uuid)) {
           console.warn('‚ö†Ô∏è DUPLICA√á√ÉO BLOQUEADA (PROCESSAMENTO): Registro j√° est√° sendo processado:', uuid);
           return true;
         }
         
         // Marca como em processamento ANTES de enviar
         if (!window.activeSubmissions) window.activeSubmissions = new Set();
         window.activeSubmissions.add(uuid);
       }
       
       // 4. Valida√ß√£o cr√≠tica: Verificar se cargo est√° preenchido corretamente
       const cargo = dadosProcessados.cargo || dadosProcessados.CARGO;
       if (!cargo || cargo.trim() === '') {
         console.error('‚ùå ERRO CR√çTICO: Cargo n√£o pode estar vazio ao enviar');
         if (uuid && window.activeSubmissions) window.activeSubmissions.delete(uuid);
         throw new Error('Cargo √© obrigat√≥rio');
       }
       
       // Log espec√≠fico para irmandade
       const cargoUpper = (cargo || '').toUpperCase();
       const isIrmandade = cargoUpper.includes('IRMANDADE');
       if (isIrmandade) {
         console.log('üîç DEBUG IRMANDADE - sendToGoogleSheets:', {
           uuid: uuid,
           nome: dadosProcessados.nome || dadosProcessados.NOME,
           comum: dadosProcessados.comum || dadosProcessados.COMUM,
           cargo: cargo,
           cargoUpper: cargoUpper
         });
       }
       
       // 5. Valida√ß√£o cr√≠tica: Verificar se nome est√° preenchido corretamente
       const nome = dadosProcessados.nome || dadosProcessados.NOME;
       if (!nome || nome.trim() === '') {
         console.error('‚ùå ERRO CR√çTICO: Nome n√£o pode estar vazio ao enviar');
         if (uuid && window.activeSubmissions) window.activeSubmissions.delete(uuid);
         throw new Error('Nome √© obrigat√≥rio');
       }
       
       // 6. Valida√ß√£o cr√≠tica: Verificar se comum est√° preenchido corretamente
       const comum = dadosProcessados.comum || dadosProcessados.COMUM;
       if (!comum || comum.trim() === '') {
         console.error('‚ùå ERRO CR√çTICO: Comum n√£o pode estar vazia ao enviar');
         if (uuid && window.activeSubmissions) window.activeSubmissions.delete(uuid);
         throw new Error('Comum √© obrigat√≥ria');
       }
       
       // üöÄ OTIMIZA√á√ÉO: Gera√ß√£o r√°pida de hor√°rio
       const horarioRegistro = new Date().toLocaleTimeString('pt-BR', {
         timeZone: 'America/Sao_Paulo',
         hour: '2-digit',
         minute: '2-digit',
         second: '2-digit',
         hour12: false
       });
       
       // üöÄ OTIMIZA√á√ÉO: Constru√ß√£o direta sem logs verbosos
       const googleSheetsData = {
         "UUID": dadosProcessados.uuid || dadosProcessados.UUID || "",
         "NOME COMPLETO": dadosProcessados.nome || dadosProcessados.NOME || "",
         "COMUM": dadosProcessados.comum || dadosProcessados.COMUM || "",
         "CIDADE": dadosProcessados.cidade || dadosProcessados.CIDADE || dadosProcessados.local || dadosProcessados.LOCAL || "",
         "CARGO": dadosProcessados.cargo || dadosProcessados.CARGO || "",
         "INSTRUMENTO": dadosProcessados.instrumento || dadosProcessados.INSTRUMENTO || "",
         "NAIPE_INSTRUMENTO": dadosProcessados.naipe || dadosProcessados.NAIPE || dadosProcessados.naipe_instrumento || dadosProcessados.NAIPE_INSTRUMENTO || "",
         "CLASSE_ORGANISTA": dadosProcessados.classe || dadosProcessados.CLASSE || dadosProcessados.nivel || dadosProcessados.NIVEL || dadosProcessados.classe_organista || dadosProcessados.CLASSE_ORGANISTA || "",
         "LOCAL_ENSAIO": dadosProcessados.local_ensaio || dadosProcessados.LOCAL_ENSAIO || "",
         "DATA_ENSAIO": dadosProcessados.data_ensaio || dadosProcessados.DATA_ENSAIO || "",
         "HOR√ÅRIO": horarioRegistro,
         "REGISTRADO_POR": dadosProcessados.registrado_por || dadosProcessados.REGISTRADO_POR || localStorage.getItem('current_user_name') || localStorage.getItem('session_user') || "Sistema",
         "USER_ID": dadosProcessados.user_id || dadosProcessados.USER_ID || "",
         "ANOTACOES": dadosProcessados.anotacoes || dadosProcessados.ANOTACOES || "",
         "SYNC_STATUS": "ATUALIZADO"
       };
       
       // üö® REMOVIDO: N√£o permitir envio de duplicatas - elas s√£o bloqueadas antes de chegar aqui
       
       // üéØ CORRE√á√ÉO CR√çTICA: Determinar aba de destino baseado nas anota√ß√µes
       // Se cont√©m "SAM Desatualizado", envia para aba "Anota√ß√µes"
       const anotacoes = googleSheetsData.ANOTACOES || '';
       const sheetDestino = (anotacoes.toUpperCase().includes('SAM DESATUALIZADO')) 
         ? 'Anota√ß√µes' 
         : 'Dados';
       
       console.log('üîç DEBUG - Detec√ß√£o de anota√ß√µes online:');
       console.log('  - anotacoes:', anotacoes);
       console.log('  - anotacoes.toUpperCase():', anotacoes.toUpperCase());
       console.log('  - includes SAM DESATUALIZADO:', anotacoes.toUpperCase().includes('SAM DESATUALIZADO'));
       console.log('  - sheetDestino:', sheetDestino);
       console.log('üì§ Enviando para aba:', sheetDestino, anotacoes ? `(anota√ß√µes: ${anotacoes})` : '');
       
       // üöÄ CORRE√á√ÉO: Timeout otimizado para 15 segundos (equil√≠brio entre seguran√ßa e performance)
       const controller = new AbortController();
       const timeoutId = setTimeout(() => controller.abort(), 15000);
       
       // üö® CORRE√á√ÉO CR√çTICA: Verificar conectividade antes de tentar enviar
       if (!navigator.onLine) {
         console.error('‚ùå Google Sheets: Sem conex√£o - n√£o √© poss√≠vel enviar');
         throw new Error('Sem conex√£o com a internet');
       }
       
       console.log('üì§ Google Sheets: Iniciando envio para', sheetDestino);
       console.log('üì§ Google Sheets: Dados a enviar:', {
         UUID: googleSheetsData.UUID,
         NOME: googleSheetsData['NOME COMPLETO'],
         COMUM: googleSheetsData.COMUM,
         CARGO: googleSheetsData.CARGO
       });
       console.log('üì§ Google Sheets: URL do script:', "https://script.google.com/macros/s/AKfycbxPtvi86jPy7y41neTpIPvn3hpycd3cMjbgjgifzLD6qRwrJVPlF9EDulaQp42nma-i/exec");
       console.log('üì§ Google Sheets: Payload completo:', JSON.stringify({
         op: 'append',
         sheet: sheetDestino,
         data: googleSheetsData
       }));
       
       console.log('üì§ Google Sheets: Executando fetch...');
       let response;
       try {
         response = await fetch("https://script.google.com/macros/s/AKfycbxPtvi86jPy7y41neTpIPvn3hpycd3cMjbgjgifzLD6qRwrJVPlF9EDulaQp42nma-i/exec", {
           method: 'POST',
           headers: {
             'Content-Type': 'text/plain;charset=utf-8'
           },
           body: JSON.stringify({
             op: 'append',
             sheet: sheetDestino, // Usa aba determinada pela detec√ß√£o de entrada manual
             data: googleSheetsData
           }),
           signal: controller.signal
         });
         console.log('üì§ Google Sheets: Fetch conclu√≠do, status:', response.status);
       } catch (fetchError) {
         clearTimeout(timeoutId);
         console.error('‚ùå Google Sheets: Erro no fetch:', fetchError);
         throw new Error(`Erro ao executar fetch: ${fetchError.message}`);
       }
       
       clearTimeout(timeoutId);
       console.log('üì§ Google Sheets: Timeout cancelado, processando resposta...');
       
       // üö® CORRE√á√ÉO CR√çTICA: Verificar resposta de forma mais robusta
       const responseText = await response.text();
       console.log('üì§ Google Sheets: Resposta recebida:', {
         status: response.status,
         ok: response.ok,
         responseText: responseText.substring(0, 200) // Primeiros 200 caracteres
       });
       
       // üö® CORRE√á√ÉO CR√çTICA: Verificar se a resposta indica sucesso
       // Google Apps Script pode retornar status 200 mesmo com erro, ent√£o verificamos o conte√∫do tamb√©m
       const responseTextLower = responseText.toLowerCase().trim();
       const hasError = responseTextLower.includes('error') || 
                        responseTextLower.includes('erro') ||
                        responseTextLower.includes('failed') ||
                        responseTextLower.includes('falhou') ||
                        responseTextLower.includes('exception') ||
                        responseTextLower.includes('invalid') ||
                        responseTextLower.includes('inv√°lido');
       
       // üö® CORRE√á√ÉO CR√çTICA: Verificar se realmente salvou na planilha
       // Google Apps Script pode retornar 200 mesmo com erro, ent√£o verificamos o conte√∫do
       const isSuccess = response.ok && 
                        (response.status === 200 || response.status === 201) &&
                        !hasError;
       
       // üö® CORRE√á√ÉO: Se response.ok √© true, status √© 200/201 e N√ÉO h√° palavras de erro, considera sucesso
       // N√£o exige palavras expl√≠citas de sucesso pois Google Apps Script pode retornar resposta vazia
       if (isSuccess) {
         console.log('‚úÖ Google Sheets: Resposta confirmada como sucesso');
         console.log('‚úÖ Google Sheets: Status:', response.status, '| OK:', response.ok, '| Sem erros detectados');
         console.log('‚úÖ Google Sheets: Resposta:', responseText.substring(0, 100));
         // üõ°Ô∏è MARCAR COMO ENVIADO DEFINITIVAMENTE: Registrar permanente (SEM TEMPO)
         if (uuid) {
           // üõ°Ô∏è FALLBACK: Usar wrapper universal para acesso consistente
           let sentRecords = safeGetItem('sent_records', {});
           
           // 1. Marca por UUID - PERMANENTE (sem timestamp)
           sentRecords[`gs_${uuid}`] = true;
           
           // 2. Marca por conte√∫do (nome + comum + cargo) - PERMANENTE
           const contentKey = `content_${(dadosProcessados.nome || '').trim()}_${(dadosProcessados.comum || '').trim()}_${(dadosProcessados.cargo || '').trim()}`.replace(/\s+/g, '_').toLowerCase();
           sentRecords[contentKey] = true;
           
           // 3. Limpa apenas se armazenamento estiver muito grande (>5MB)
           try {
             const storageSize = new Blob([JSON.stringify(sentRecords)]).size;
             if (storageSize > 5000000) { // 5MB
               // Limpa apenas registros mais antigos (com timestamp)
               Object.keys(sentRecords).forEach(key => {
                 if (typeof sentRecords[key] === 'number' && sentRecords[key] < Date.now() - 86400000) {
                   delete sentRecords[key];
                 }
               });
             }
           } catch (e) {
             // Ignora erro de limpeza
           }
           
           // Salva de forma consistente usando wrapper universal
           safeSetItem('sent_records', sentRecords);
           
           // Remove do conjunto de processamento ativo
           if (window.activeSubmissions) {
             window.activeSubmissions.delete(uuid);
           }
         }
         
         console.log('‚úÖ Google Sheets: Enviado com sucesso para', sheetDestino);
         console.log('‚úÖ Google Sheets: UUID enviado:', uuid);
         console.log('‚úÖ Google Sheets: Registro salvo na planilha');
         console.log('‚úÖ Google Sheets: Resposta completa:', {
           status: response.status,
           statusText: response.statusText,
           responseText: responseText.substring(0, 500),
           isSuccess: isSuccess,
           hasError: hasError
         });
         
         // üö® VALIDA√á√ÉO FINAL: Garantir que realmente salvou
         // Se chegou aqui, a valida√ß√£o passou - retornar true
         console.log('‚úÖ Google Sheets: Valida√ß√£o completa - registro realmente salvo na planilha');
         return true;
       } else {
         // üö® CORRE√á√ÉO CR√çTICA: Se a resposta n√£o indica sucesso, lan√ßar erro
         const errorMsg = hasError 
           ? `Google Sheets retornou erro na resposta: ${responseText.substring(0, 200)}`
           : `Google Sheets retornou status inv√°lido: ${response.status} - ${response.statusText}`;
         
         console.error('‚ùå Google Sheets: Erro ao enviar', {
           status: response.status,
           statusText: response.statusText,
           ok: response.ok,
           hasError: hasError,
           isSuccess: isSuccess,
           responseText: responseText.substring(0, 200)
         });
         
         throw new Error(errorMsg);
       }
     } catch (error) {
       // Remove do conjunto de processamento ativo em caso de erro
       if (uuid && window.activeSubmissions) {
         window.activeSubmissions.delete(uuid);
       }
       
       // üö® CORRE√á√ÉO: Tratamento espec√≠fico para diferentes tipos de erro
       if (error.message && error.message.includes('DUPLICATA_BLOQUEADA')) {
         // üö® BLOQUEIO DE DUPLICATA: Retornar erro espec√≠fico para ser tratado pelo chamador
         console.error('üö®üö®üö® DUPLICATA BLOQUEADA - ENVIO CANCELADO üö®üö®üö®');
         console.error('üìã Detalhes:', error.message);
         // Propagar o erro para que o chamador possa tratar adequadamente
         throw error;
       } else if (error.name === 'AbortError') {
         console.error('‚ùå Google Sheets: Timeout (15s)');
       } else if (error.message && (error.message.includes('Failed to fetch') || error.message.includes('CORS'))) {
         console.error('‚ùå Google Sheets: Erro de CORS ou conectividade');
         console.error('   Detalhes:', error.message);
         // üö® CORRE√á√ÉO: Log detalhado para debug, mas retorna false para tratamento no handleSubmit
         console.error('   Isso geralmente indica problema de CORS no Google Apps Script ou falta de conex√£o');
       } else {
         console.error('‚ùå Google Sheets: Erro', error.message || error);
       }
       return false;
     }
   }
   
   function startOfflineQueueSync() {
     if (syncIntervalId) {
       clearInterval(syncIntervalId);
     }
     
     // üöÄ OTIMIZA√á√ÉO: Processamento mais frequente - a cada 5 segundos
     syncIntervalId = setInterval(async () => {
       if (navigator.onLine && !window.offlineQueueProcessing) {
         try {
           const queue = getOfflineQueue();
           const pendingItems = queue.filter(item => !item.synced);
           
           if (pendingItems.length > 0) {
             console.log(`üîÑ Processamento autom√°tico: ${pendingItems.length} itens pendentes`);
             // üöÄ OTIMIZA√á√ÉO: Processamento ass√≠ncrono sem await
             processOfflineQueue().catch(error => {
               console.error('‚ùå Erro no processamento autom√°tico:', error);
             });
           }
         } catch (error) {
           console.error('‚ùå Erro no processamento autom√°tico:', error);
         }
       }
     }, 5000); // A cada 5 segundos
     
     console.log('üîÑ Sincroniza√ß√£o autom√°tica da fila offline iniciada (a cada 5s)');
   }
   
   // Fun√ß√£o para for√ßar processamento da fila
   async function forcarProcessamentoFilaOffline() {
     console.log('üîÑ For√ßando processamento da fila offline...');
     
     const queue = getOfflineQueue();
     const pendingItems = queue.filter(item => !item.synced);
     
     if (pendingItems.length === 0) {
       console.log('üìã Nenhum item pendente na fila');
       // showToast('info', 'Fila vazia', 'Todos os registros j√° foram sincronizados', 2000); // Removido - alerta desnecess√°rio
       return;
     }
     
     console.log(`üì§ Processando ${pendingItems.length} itens pendentes...`);
     // Alerta removido para acelerar processamento
     
     await processOfflineQueue();
   }
   
   // Fun√ß√£o para limpar UUIDs inv√°lidos da fila - CORRE√á√ÉO DEFINITIVA
   function cleanInvalidUUIDsFromQueue() {
     const queue = getOfflineQueue();
     let cleanedCount = 0;
     
     const cleanedQueue = queue.map(item => {
       // Verifica se o ID do item √© um UUID v√°lido
       if (!isValidUUID(item.id)) {
         // Gera um novo UUID v√°lido
         const newUUID = uuidv4();
         cleanedCount++;
         return {
           ...item,
           id: newUUID
         };
       }
       
       // Verifica se o UUID nos dados tamb√©m √© v√°lido
       if (item.data && item.data.uuid && !isValidUUID(item.data.uuid)) {
         // Gera um novo UUID v√°lido
         const newUUID = uuidv4();
         cleanedCount++;
         return {
           ...item,
           data: {
             ...item.data,
             uuid: newUUID
           }
         };
       }
       
       return item;
     });
     
     if (cleanedCount > 0) {
       setOfflineQueue(cleanedQueue);
     }
     
     return cleanedCount;
   }
   
   // Fun√ß√£o para limpar UUIDs inv√°lidos de TODAS as filas - CORRE√á√ÉO DEFINITIVA
   function cleanAllInvalidUUIDs() {
     let totalCleaned = 0;
     
     // 1. Limpa fila offline
     totalCleaned += cleanInvalidUUIDsFromQueue();
     
     // 2. Limpa fila local (Google Sheets)
     try {
       const filaLocal = safeGetItem('fila_envio', []);
       let localCleaned = 0;
       
       const filaLocalLimpa = filaLocal.map(item => {
         if (item.data && item.data.uuid && !isValidUUID(item.data.uuid)) {
           item.data.uuid = uuidv4();
           localCleaned++;
         }
         return item;
       });
       
       if (localCleaned > 0) {
         safeSetItem('fila_envio', filaLocalLimpa);
         totalCleaned += localCleaned;
       }
     } catch (error) {
       console.error('‚ùå Erro ao limpar fila local:', error);
     }
     
     // 3. Limpa fila Supabase
     try {
       const filaSupabase = safeGetItem('fila_supabase', []);
       let supabaseCleaned = 0;
       
       const filaSupabaseLimpa = filaSupabase.map(item => {
         if (item.data && item.data.uuid && !isValidUUID(item.data.uuid)) {
           item.data.uuid = uuidv4();
           supabaseCleaned++;
         }
         return item;
       });
       
       if (supabaseCleaned > 0) {
         safeSetItem('fila_supabase', filaSupabaseLimpa);
         totalCleaned += supabaseCleaned;
       }
     } catch (error) {
       console.error('‚ùå Erro ao limpar fila Supabase:', error);
     }
     
     return totalCleaned;
   }
   
   // Fun√ß√£o para for√ßar processamento da fila offline - ESPEC√çFICA PARA MOBILE
   function forceProcessOfflineQueue() {
     // PRIMEIRO: Limpa UUIDs inv√°lidos
     cleanInvalidUUIDsFromQueue();
     
     const queue = getOfflineQueue();
     const pendingItems = queue.filter(item => !item.synced);
     
     if (pendingItems.length > 0) {
       // Log espec√≠fico para mobile
       if (isMobile) {
         console.log('üì± MOBILE: For√ßando processamento da fila offline...', pendingItems.length, 'itens pendentes');
       }
       
       // For√ßa o processamento
       processOfflineQueue();
     } else {
       if (isMobile) {
         console.log('üì± MOBILE: Nenhum item pendente na fila offline');
       }
     }
   }
   
   // Fun√ß√£o para melhorar sincroniza√ß√£o mobile
   function optimizeMobileSync() {
     if (!isMobile) return;
     
     console.log('üì± Otimizando sincroniza√ß√£o mobile...');
     
     // Sincroniza√ß√£o mais frequente para mobile
     const mobileSyncInterval = setInterval(async () => {
       if (navigator.onLine && !window.offlineQueueProcessing) {
         try {
           const queue = getOfflineQueue();
           const pendingItems = queue.filter(item => !item.synced);
           
           if (pendingItems.length > 0) {
             console.log(`üì± MOBILE: Sincroniza√ß√£o autom√°tica - ${pendingItems.length} itens pendentes`);
             await processOfflineQueue();
           }
         } catch (error) {
           console.error('üì± MOBILE: Erro na sincroniza√ß√£o autom√°tica:', error);
         }
       }
     }, 8000); // A cada 8 segundos para mobile (mais frequente)
     
     // Armazenar ID do intervalo para limpeza posterior
     window.mobileSyncInterval = mobileSyncInterval;
     
     console.log('‚úÖ Sincroniza√ß√£o mobile otimizada');
   }
   
   // Fun√ß√£o para otimizar experi√™ncia desktop
   function optimizeDesktopExperience() {
     if (isMobile) return;
     
     console.log('üñ•Ô∏è Otimizando experi√™ncia desktop...');
     
     // Melhorar performance de scroll
     document.addEventListener('wheel', (e) => {
       // Scroll mais suave no desktop
       if (e.deltaY !== 0) {
         e.preventDefault();
         window.scrollBy({
           top: e.deltaY * 0.5,
           behavior: 'smooth'
         });
       }
     }, { passive: false });
     
     // Melhorar hover effects
     const buttons = document.querySelectorAll('button');
     buttons.forEach(btn => {
       btn.addEventListener('mouseenter', () => {
         btn.style.transform = 'translateY(-1px)';
         btn.style.transition = 'all 0.2s ease';
       });
       
       btn.addEventListener('mouseleave', () => {
         btn.style.transform = 'translateY(0)';
       });
     });
     
     console.log('‚úÖ Experi√™ncia desktop otimizada');
   }
   
   function stopOfflineQueueSync() {
     if (syncIntervalId) {
       clearInterval(syncIntervalId);
       syncIntervalId = null;
     }
     
     console.log('‚èπÔ∏è Sincroniza√ß√£o autom√°tica da fila offline parada');
   }
   
   // === CONECTIVIDADE ROBUSTA (baseado no app que funciona) ===
   let isOnline = navigator.onLine; // Inicializar com o status real do navegador
   let connectivityCheckInterval = null;
   let lastConnectivityCheck = 0;
   let forceOfflineMode = false;
   
   // Detectar dispositivos m√≥veis (vari√°veis j√° declaradas acima)
   const isChromeIOS = isIOS && /CriOS|Chrome/.test(navigator.userAgent);
   const isSafariIOS = isIOS && /Safari/.test(navigator.userAgent) && !/CriOS|Chrome/.test(navigator.userAgent);
   
   // üõ°Ô∏è FUN√á√ÉO CR√çTICA: Fetch com timeout compat√≠vel (COMPATIBILIDADE TOTAL)
   // üö® CORRE√á√ÉO: Timeout padr√£o aumentado para 10 segundos (era 5s - muito curto para requisi√ß√µes lentas)
   async function fetchWithTimeout(url, options = {}, timeout = 10000) {
     try {
       // Verificar se AbortSignal.timeout est√° dispon√≠vel
       if (typeof AbortSignal !== 'undefined' && AbortSignal.timeout) {
         // M√©todo moderno (suportado em navegadores recentes)
         return await fetch(url, {
           ...options,
           signal: AbortSignal.timeout(timeout)
         });
       } else {
         // Fallback para AbortController (compatibilidade com navegadores antigos)
         const controller = new AbortController();
         const timeoutId = setTimeout(() => controller.abort(), timeout);
         
         try {
           const response = await fetch(url, {
             ...options,
             signal: controller.signal
           });
           clearTimeout(timeoutId);
           return response;
         } catch (error) {
           clearTimeout(timeoutId);
           if (error.name === 'AbortError') {
             throw new Error('Timeout: Requisi√ß√£o excedeu o tempo limite');
           }
           throw error;
         }
       }
     } catch (error) {
       // Tratamento de erro consistente
       if (error.name === 'AbortError' || error.message.includes('Timeout')) {
         console.warn(`‚è±Ô∏è Timeout na requisi√ß√£o para ${url}`);
         throw new Error('Timeout: Requisi√ß√£o excedeu o tempo limite');
       }
       throw error;
     }
   }
   
   // Fun√ß√£o para testar conectividade real (COMPATIBILIDADE TOTAL)
   async function testConnectivity() {
     try {
       if (forceOfflineMode) {
         console.log("üîß Modo offline for√ßado ativo - retornando false");
         return false;
       }
       
       // Para protocolo file://, assumir online se o navegador estiver online
       if (window.location.protocol === 'file:') {
         console.log("üìÅ Protocolo file:// - verificando status do navegador");
         return navigator.onLine;
       }
       
       if (!navigator.onLine) {
         console.log("üì¥ Navegador reporta offline");
         return false;
       }
       
      // Verifica√ß√£o adicional para mobile (mais permissiva para iOS)
      if (navigator.connection) {
        const connection = navigator.connection;
        // CORRE√á√ÉO iOS: Ser mais permissivo com conex√µes lentas
        if (connection.effectiveType === 'slow-2g' && connection.downlink < 0.1) {
          console.log("üì¥ Conex√£o extremamente lenta detectada - assumindo offline");
          return false;
        }
        // Remover verifica√ß√£o de RTT que pode causar falsos negativos no iOS
      }
       
      // üöÄ OTIMIZA√á√ÉO MOBILE: Teste unificado para Android e iOS (mesma performance)
      // Usar URL √∫nica e timeout unificado para garantir comportamento consistente
      const testUrls = [
        "https://www.google.com/favicon.ico" // URL √∫nica para ambas as plataformas
      ];
       
       let quickTestPassed = false;
       for (const url of testUrls) {
         try {
          // üö® CORRE√á√ÉO CR√çTICA: Timeout aumentado para 8 segundos (era 2s - muito curto quebrava a l√≥gica)
          // Timeout muito curto estava cancelando testes de conectividade antes que completassem
          const timeout = isMobile ? 8000 : 8000; // 8 segundos para mobile e desktop
          
           // Usar fetchWithTimeout para compatibilidade total
           const quickTest = await fetchWithTimeout(url, {
             method: 'HEAD',
             mode: 'no-cors',
             cache: 'no-store'
           }, timeout);
           
           console.log("‚úÖ Teste r√°pido de conectividade passou:", url);
           quickTestPassed = true;
           break;
         } catch (quickError) {
           console.log("‚ùå Teste r√°pido falhou para:", url, quickError.message);
           continue;
         }
       }
       
       if (!quickTestPassed) {
         console.log("‚ùå Todos os testes r√°pidos falharam - assumindo offline");
         return false;
       }
       
       console.log("‚úÖ Conectividade confirmada via teste r√°pido");
       return true;
       
     } catch (error) {
       console.log("‚ùå Conectividade falhou:", error.message);
       return false;
     }
   }
   
   // Fun√ß√£o para atualizar status de conectividade
   async function updateConnectivityStatus() {
     if (forceOfflineMode) {
       console.log("üîß Modo offline for√ßado ativo - pulando verifica√ß√£o autom√°tica");
       return isOnline;
     }
     
     const now = Date.now();
     
     // Evitar verifica√ß√µes muito frequentes (m√°ximo a cada 2 segundos)
     if (now - lastConnectivityCheck < 2000) {
       return isOnline;
     }
     
     lastConnectivityCheck = now;
     
     // Verificar conectividade real
     const hasConnectivity = await testConnectivity();
     
     // Atualizar estado
     const wasOnline = isOnline;
     isOnline = hasConnectivity;
     
       // Sempre atualizar UI para garantir consist√™ncia
       updateStatusUI();
       
       // üîß CORRE√á√ÉO CR√çTICA: Se voltou online, processar TODAS as filas
       if (isOnline && !wasOnline) {
         console.log("üåê Conectividade restaurada - processando TODAS as filas");
         // Usar a fun√ß√£o centralizada que processa todas as filas
         setTimeout(() => {
           processQueueOnConnectionRestore().catch(err => {
             console.error('‚ùå Erro ao processar filas ap√≥s reconex√£o:', err);
           });
         }, 1000); // Aguardar 1s antes de sincronizar para garantir conex√£o est√°vel
     }
     
     return isOnline;
   }
   
   // Fun√ß√£o para atualizar a UI do status
   function updateStatusUI() {
     const statusIcon = document.getElementById('statusIcon');
     const statusText = document.getElementById('statusText');
     
     if (statusIcon && statusText) {
       if (isOnline) {
         statusIcon.classList.remove('offline');
         statusIcon.classList.add('online');
         statusText.textContent = "Online";
         console.log("‚úÖ Status atualizado: Online");
       } else {
         statusIcon.classList.remove('online');
         statusIcon.classList.add('offline');
         statusText.textContent = "Offline";
         console.log("‚ö†Ô∏è Status atualizado: Offline");
       }
     }
   }
   
   // Fun√ß√£o para iniciar monitoramento de conectividade
   function startConnectivityMonitoring() {
     // Verificar conectividade inicial
     updateConnectivityStatus();
     
     // Verificar a cada 3 segundos (mais responsivo)
     if (connectivityCheckInterval) {
       clearInterval(connectivityCheckInterval);
     }
     
     connectivityCheckInterval = setInterval(updateConnectivityStatus, 3000);
     
     console.log("üîÑ Monitoramento de conectividade iniciado (verifica√ß√£o a cada 3s)");
   }
   
   // Fun√ß√£o para parar monitoramento
   function stopConnectivityMonitoring() {
     if (connectivityCheckInterval) {
       clearInterval(connectivityCheckInterval);
       connectivityCheckInterval = null;
     }
   }
   
   // Fun√ß√£o para for√ßar verifica√ß√£o de conectividade
   async function forceConnectivityCheck() {
     console.log("üîÑ For√ßando verifica√ß√£o de conectividade...");
     
     // Resetar o timer para permitir verifica√ß√£o imediata
     lastConnectivityCheck = 0;
     
     // For√ßar verifica√ß√£o
     const result = await updateConnectivityStatus();
     
     console.log(`‚úÖ Verifica√ß√£o for√ßada conclu√≠da: ${result ? 'Online' : 'Offline'}`);
     return result;
   }
   
   // Fun√ß√£o para otimizar experi√™ncia desktop
   function optimizeForDesktop() {
     if (!isDesktop) return;
     
     console.log('üñ•Ô∏è Otimizando experi√™ncia para desktop...');
     
     // Melhorar intera√ß√£o com dropdowns
     document.addEventListener('click', (e) => {
       if (e.target.classList.contains('dropdown-item')) {
         // Adicionar feedback visual para desktop
         e.target.style.transform = 'scale(0.98)';
         setTimeout(() => {
           e.target.style.transform = '';
         }, 150);
       }
     });
     
     // Otimizar scroll para desktop
     document.documentElement.style.scrollBehavior = 'smooth';
     
     // Melhorar foco em campos de input
     document.addEventListener('focusin', (e) => {
       if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
         e.target.style.outline = '2px solid #007bff';
         e.target.style.outlineOffset = '2px';
       }
     });
     
     document.addEventListener('focusout', (e) => {
       if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
         e.target.style.outline = '';
         e.target.style.outlineOffset = '';
       }
     });
     
     console.log('‚úÖ Experi√™ncia desktop otimizada');
   }
   
   // Fun√ß√£o para otimizar experi√™ncia mobile
   function optimizeMobileExperience() {
     if (!isMobile) return;
     
     console.log('üì± Otimizando experi√™ncia mobile...');
     
     // Vari√°veis para controle do teclado virtual
     let keyboardHeight = 0;
     let originalViewportHeight = window.innerHeight;
     let isKeyboardVisible = false;
     let activeField = null;
     
     // Fun√ß√£o para detectar mudan√ßas na altura da viewport (teclado virtual)
     function detectKeyboardVisibility() {
       const currentHeight = window.innerHeight;
       const heightDifference = originalViewportHeight - currentHeight;
       
       // Se a altura diminuiu significativamente, o teclado est√° vis√≠vel
       if (heightDifference > 150) {
         keyboardHeight = heightDifference;
         isKeyboardVisible = true;
         console.log('üì± Teclado virtual detectado, altura:', keyboardHeight);
         
         // Scroll para o campo ativo
         if (activeField) {
           scrollToActiveField();
         }
       } else {
         isKeyboardVisible = false;
         keyboardHeight = 0;
         console.log('üì± Teclado virtual oculto');
       }
     }
     
     // Fun√ß√£o para scroll autom√°tico para o campo ativo
     function scrollToActiveField() {
       if (!activeField) return;
       
       const fieldRect = activeField.getBoundingClientRect();
       const fieldBottom = fieldRect.bottom;
       const availableHeight = window.innerHeight - keyboardHeight;
       
       // Se o campo est√° sendo coberto pelo teclado
       if (fieldBottom > availableHeight) {
         const scrollAmount = fieldBottom - availableHeight + 20; // 20px de margem
         
         console.log('üì± Ajustando scroll para campo ativo:', {
           fieldBottom,
           availableHeight,
           scrollAmount,
           keyboardHeight
         });
         
         // Scroll suave para manter o campo vis√≠vel
         window.scrollBy({
           top: scrollAmount,
           behavior: 'smooth'
         });
       }
     }
     
     // Detectar mudan√ßas na viewport
     window.addEventListener('resize', detectKeyboardVisibility);
     
     // Melhorar campos de input para mobile
     document.addEventListener('focusin', (e) => {
       if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
         activeField = e.target;
         
         // Evita zoom no iOS
         e.target.style.fontSize = '16px';
         
         // Adiciona classe para estiliza√ß√£o mobile
         e.target.classList.add('mobile-focused');
         
         console.log('üì± Campo focado:', e.target.id || e.target.name || 'sem-id');
         
         // Scroll imediato para o campo
         setTimeout(() => {
           scrollToActiveField();
         }, 100);
         
         // Scroll adicional ap√≥s o teclado aparecer
         setTimeout(() => {
           scrollToActiveField();
         }, 500);
       }
     });
     
     document.addEventListener('focusout', (e) => {
       if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
         // Remove classe mobile
         e.target.classList.remove('mobile-focused');
         
         // Limpa refer√™ncia do campo ativo ap√≥s um delay
         setTimeout(() => {
           if (activeField === e.target) {
             activeField = null;
           }
         }, 100);
       }
     });
     
     // Detectar mudan√ßas na orienta√ß√£o
     window.addEventListener('orientationchange', () => {
       setTimeout(() => {
         originalViewportHeight = window.innerHeight;
         detectKeyboardVisibility();
       }, 500);
     });
     
     // Detectar quando o usu√°rio est√° digitando para ajustar scroll
     document.addEventListener('input', (e) => {
       if (e.target === activeField && isKeyboardVisible) {
         // Pequeno ajuste de scroll durante a digita√ß√£o
         setTimeout(() => {
           scrollToActiveField();
         }, 50);
       }
     });
     
     // Fun√ß√£o para for√ßar scroll para campo espec√≠fico (√∫til para chamadas externas)
     window.scrollToActiveField = function(fieldId) {
       const field = document.getElementById(fieldId);
       if (field) {
         activeField = field;
         field.focus();
         setTimeout(() => {
           scrollToActiveField();
         }, 100);
       }
     };
     
     // Fun√ß√£o para obter status do teclado virtual
     window.getKeyboardStatus = function() {
       return {
         isVisible: isKeyboardVisible,
         height: keyboardHeight,
         activeField: activeField ? activeField.id || activeField.name : null
       };
     };
     
     // Melhorar bot√µes para mobile
     const buttons = document.querySelectorAll('button');
     buttons.forEach(btn => {
       btn.style.minHeight = '44px'; // Tamanho m√≠nimo recomendado para touch
       btn.style.minWidth = '44px';
     });
     
     // Melhorar selects para mobile
     const selects = document.querySelectorAll('select');
     selects.forEach(select => {
       select.style.minHeight = '44px';
       select.style.fontSize = '16px';
     });
     
     // Adicionar estilos CSS espec√≠ficos para mobile
     const mobileStyles = document.createElement('style');
     mobileStyles.textContent = `
       @media (max-width: 768px) {
         .mobile-focused {
           border-color: #007bff !important;
           box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25) !important;
           transform: scale(1.02);
           transition: all 0.2s ease;
           position: relative;
           z-index: 1000;
         }
         
         input, select, textarea {
           font-size: 16px !important; /* Evita zoom no iOS */
           min-height: 48px !important;
           padding: 12px 16px !important;
           border-radius: 8px !important;
           border: 2px solid #e9ecef !important;
           transition: all 0.2s ease !important;
         }
         
         input:focus, select:focus, textarea:focus {
           border-color: #007bff !important;
           box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25) !important;
           outline: none !important;
         }
         
         /* Garantir que campos focados sejam vis√≠veis */
         .mobile-focused {
           position: relative;
           z-index: 1000;
         }
         
         /* Melhorar √°rea de toque */
         button, input, select, textarea {
           min-height: 44px !important;
           min-width: 44px !important;
         }
         
         /* Indicador visual de campo ativo */
         .mobile-focused::after {
           content: '';
           position: absolute;
           top: -2px;
           left: -2px;
           right: -2px;
           bottom: -2px;
           border: 2px solid #007bff;
           border-radius: 10px;
           pointer-events: none;
           animation: pulse 2s infinite;
         }
         
         @keyframes pulse {
           0% { opacity: 1; }
           50% { opacity: 0.5; }
           100% { opacity: 1; }
         }
         
         /* Melhorar sugest√µes de autocomplete no mobile */
         .comum-suggestions {
           max-height: 200px !important;
           overflow-y: auto !important;
           -webkit-overflow-scrolling: touch !important;
           border-radius: 8px !important;
           box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
         }
         
         .suggestion-item {
           padding: 12px 16px !important;
           min-height: 44px !important;
           display: flex !important;
           align-items: center !important;
         }
         
         .suggestion-item.selected,
         .suggestion-item.highlighted {
           background-color: #007bff !important;
           color: white !important;
         }
       }
     `;
     document.head.appendChild(mobileStyles);
     
     // Adicionar indicador visual de status de conex√£o
     const statusIndicator = document.createElement('div');
     statusIndicator.id = 'mobile-status-indicator';
     statusIndicator.style.cssText = `
       position: fixed;
       top: 10px;
       right: 10px;
       width: 12px;
       height: 12px;
       border-radius: 50%;
       z-index: 9999;
       transition: all 0.3s ease;
     `;
     
     // Atualizar status baseado na conectividade
     function updateMobileStatus() {
       if (navigator.onLine) {
         statusIndicator.style.backgroundColor = '#10b981';
         statusIndicator.title = 'Online';
       } else {
         statusIndicator.style.backgroundColor = '#ef4444';
         statusIndicator.title = 'Offline';
       }
     }
     
     updateMobileStatus();
     document.body.appendChild(statusIndicator);
     
     // Atualizar status quando a conectividade mudar
     window.addEventListener('online', updateMobileStatus);
     window.addEventListener('offline', updateMobileStatus);
     
     // Fun√ß√£o espec√≠fica para otimizar modais no mobile
     function optimizeMobileModals() {
       // Detectar quando modal √© aberto
       document.addEventListener('shown.bs.modal', function(e) {
         const modal = e.target;
         const activeInput = modal.querySelector('input:focus, select:focus, textarea:focus');
         
         if (activeInput) {
           // Scroll para o campo ativo no modal
           setTimeout(() => {
             activeInput.scrollIntoView({ 
               behavior: 'smooth', 
               block: 'center' 
             });
           }, 300);
         }
       });
       
       // Melhorar campos dentro de modais
       document.addEventListener('focusin', function(e) {
         if (e.target.closest('.modal')) {
           const modal = e.target.closest('.modal');
           const modalContent = modal.querySelector('.modal-content');
           
           if (modalContent) {
             // Ajustar scroll do modal para manter campo vis√≠vel
             setTimeout(() => {
               const fieldRect = e.target.getBoundingClientRect();
               const modalRect = modalContent.getBoundingClientRect();
               
               if (fieldRect.bottom > modalRect.bottom - 50) {
                 modalContent.scrollTop += fieldRect.bottom - modalRect.bottom + 50;
               }
             }, 100);
           }
         }
       });
     }
     
     // Aplicar otimiza√ß√µes de modal
     optimizeMobileModals();
     
     console.log('‚úÖ Experi√™ncia mobile otimizada');
   }
   
   // Fun√ß√£o para otimizar experi√™ncia mobile offline
   function optimizeMobileOffline() {
     if (!isMobile) return;
     
     console.log('üì± Otimizando experi√™ncia mobile offline...');
     
     // Melhorar campos de input para mobile offline
     document.addEventListener('focusin', (e) => {
       if (e.target.tagName === 'INPUT' && e.target.id === 'nome') {
         // Se est√° offline, melhora a experi√™ncia de digita√ß√£o
         if (!navigator.onLine || !isOnline) {
           e.target.style.fontSize = '16px'; // Evita zoom no iOS
           e.target.style.backgroundColor = '#fff3cd';
           e.target.placeholder = 'Digite o nome completo (modo offline)';
           
           // Adiciona dica visual
           const hint = document.createElement('div');
           hint.id = 'mobile-offline-hint';
           hint.style.cssText = `
             position: absolute;
             top: -25px;
             left: 0;
             font-size: 12px;
             color: #856404;
             background: #fff3cd;
             padding: 2px 6px;
             border-radius: 3px;
             z-index: 1000;
           `;
           hint.textContent = 'Modo offline - digite manualmente';
           
           // Posiciona a dica
           const rect = e.target.getBoundingClientRect();
           hint.style.position = 'fixed';
           hint.style.top = (rect.top - 25) + 'px';
           hint.style.left = rect.left + 'px';
           
           document.body.appendChild(hint);
           
           // Remove a dica ap√≥s 3 segundos
           setTimeout(() => {
             if (hint.parentNode) {
               hint.parentNode.removeChild(hint);
             }
           }, 3000);
         }
       }
     });
     
     document.addEventListener('focusout', (e) => {
       if (e.target.tagName === 'INPUT' && e.target.id === 'nome') {
         // Remove dica se existir
         const hint = document.getElementById('mobile-offline-hint');
         if (hint && hint.parentNode) {
           hint.parentNode.removeChild(hint);
         }
       }
     });
     
     console.log('‚úÖ Experi√™ncia mobile offline otimizada');
   }
   
   // === M√âTODOS DE ENVIO (baseado no app que funciona) ===
   // M√©todo 1: sendBeacon (mais confi√°vel)
   function tryBeacon(data) {
     try {
       if (!("sendBeacon" in navigator)) {
         console.log("üì° SendBeacon n√£o dispon√≠vel");
         return false;
       }
       
       console.log("üì° Tentando sendBeacon...");
       
       // Usar FormData - funciona em todos os navegadores
       const formData = new FormData();
       formData.append('cargo', data.cargo || '');
       formData.append('ministerio', data.ministerio || '');
       formData.append('administracao', data.administracao || '');
       formData.append('timestamp', String(data.timestamp || ''));
       
       const success = navigator.sendBeacon(ENDPOINT, formData);
       console.log("üì° SendBeacon result:", success);
       return success;
     } catch (error) {
       console.error("üì° SendBeacon error:", error);
       return false;
     }
   }
   
   // M√©todo 2: fetch com keepalive
   async function tryFetchKeepalive(data) {
     try {
       console.log("üîÑ Tentando fetch keepalive...");
       
       const formData = new FormData();
       formData.append('cargo', data.cargo || '');
       formData.append('ministerio', data.ministerio || '');
       formData.append('administracao', data.administracao || '');
       formData.append('timestamp', String(data.timestamp || ''));
       
       const response = await fetch(ENDPOINT, {
         method: 'POST',
         body: formData,
         keepalive: true
       });
       
       console.log("üîÑ Fetch keepalive response:", response.status);
       return response.ok;
       
     } catch (error) {
       console.error("üîÑ Fetch keepalive error:", error);
       return false;
     }
   }
   
   // M√©todo 3: GET como fallback
   async function tryGet(data) {
     try {
       console.log("Tentando GET...");
       
       const params = new URLSearchParams({
         cargo: data.cargo || "",
         ministerio: data.ministerio || "",
         administracao: data.administracao || ""
       });
       
       const controller = new AbortController();
       const timeoutId = setTimeout(() => {
         console.log("‚è∞ Timeout no GET (10s)");
         controller.abort();
       }, 10000);
       
       const response = await fetch(`${ENDPOINT}?${params}`, {
         method: "GET",
         mode: "cors",
         keepalive: true,
         signal: controller.signal
       });
       
       clearTimeout(timeoutId);
       console.log("GET resposta:", response.status);
       
       if (response.ok) {
         try {
           const result = await response.json();
           console.log("GET resultado:", result);
           return result.success === true;
         } catch (parseError) {
           console.log("‚ö†Ô∏è Resposta OK mas n√£o √© JSON v√°lido - assumindo sucesso");
           return true;
         }
       } else {
         console.log("GET falhou - status:", response.status);
         return false;
       }
     } catch (error) {
       console.error("GET erro:", error);
       return false;
     }
   }
   
   async function sendItem(data) {
     // Verificar se o endpoint est√° configurado
     if (!ENDPOINT) {
       console.error("‚ùå ENDPOINT n√£o configurado");
       return false;
     }
     
     console.log("üöÄ Enviando dados:", data);
     
     // Tentar sendBeacon primeiro (mais confi√°vel)
     if (tryBeacon(data)) {
       console.log("‚úÖ Enviado via sendBeacon");
       return true;
     }
     
     // Tentar fetch keepalive
     if (await tryFetchKeepalive(data)) {
       console.log("‚úÖ Enviado via fetch keepalive");
       return true;
     }
     
     // Tentar GET como fallback
     if (await tryGet(data)) {
       console.log("‚úÖ Enviado via GET");
       return true;
     }
     
     console.log("‚ùå Falha em todos os m√©todos");
     return false;
   }
   
   // === SINCRONIZA√á√ÉO ROBUSTA (baseado no app que funciona) ===
   let isSyncing = false;
   
   async function syncPending() {
     // Evitar m√∫ltiplas sincroniza√ß√µes simult√¢neas
     if (isSyncing) {
       console.log("‚è≥ Sincroniza√ß√£o j√° em andamento");
       return;
     }
     
     // Verificar conectividade real antes de sincronizar
     const reallyOnline = await testConnectivity();
     if (!reallyOnline) {
       console.log("üì¥ Offline - pulando sincroniza√ß√£o");
       return;
     }
     
     const q = JSON.parse(localStorage.getItem('fila_envio') || '[]');
     // Filtrar apenas itens n√£o sincronizados
     const pendingItems = q.filter(item => !item.synced);
     
     if (pendingItems.length === 0) {
       console.log("üì≠ Nenhum item pendente para sincronizar");
       return;
     }
     
     isSyncing = true;
     updateQueueCount(); // Atualizar status visual
     console.log(`üîÑ Iniciando sincroniza√ß√£o de ${pendingItems.length} itens pendentes da fila...`);
     
     const remain = [];
     let successCount = 0;
     
     try {
       for (let i = 0; i < pendingItems.length; i++) {
         const item = pendingItems[i];
         console.log(`üì§ Sincronizando item ${i + 1}/${pendingItems.length} (ID: ${item.id}):`, item);
         
         // Tentar enviar o item
         const ok = await sendItem(item);
         if (ok) {
           // Marcar como sincronizado
           item.synced = true;
           item.syncedAt = Date.now();
           successCount++;
           console.log(`‚úÖ Item ${i + 1} (ID: ${item.id}) sincronizado com sucesso`);
         } else {
           remain.push(item);
           console.log(`‚ùå Falha ao sincronizar item ${i + 1} (ID: ${item.id}) - mantendo na fila`);
         }
         
         // üöÄ OTIMIZA√á√ÉO: Pausa m√≠nima entre envios
         if (i < pendingItems.length - 1) {
           // üö® CORRE√á√ÉO: Delay aumentado para 200ms (era 20ms - muito curto quebrava a l√≥gica de sincroniza√ß√£o)
           await new Promise(resolve => setTimeout(resolve, 200));
         }
       }
       
       // Atualizar fila com todos os itens (incluindo os marcados como sincronizados)
       const updatedQueue = q.map(item => {
         const pendingItem = pendingItems.find(p => p.id === item.id);
         return pendingItem || item;
       });
       
       // Remover itens sincronizados h√° mais de 24 horas para limpeza
       const cleanedQueue = updatedQueue.filter(item => {
         if (!item.synced) return true;
         const hoursSinceSync = (Date.now() - item.syncedAt) / (1000 * 60 * 60);
         return hoursSinceSync < 24; // Manter sincronizados por 24h
       });
       
       setQueue(cleanedQueue);
       
       if (successCount > 0) {
         // showToast('success', 'Sincronizado', `${successCount} item(s) sincronizado(s)`, 2000); // Removido - alerta desnecess√°rio
         console.log(`‚úÖ Sincroniza√ß√£o conclu√≠da: ${successCount} enviados, ${remain.length} restantes`);
       }
       
       if (remain.length > 0) {
         console.log(`‚ö†Ô∏è ${remain.length} itens permanecem na fila`);
       }
       
     } catch (error) {
       console.error("‚ùå Erro durante sincroniza√ß√£o:", error);
       showToast("Erro na sincroniza√ß√£o", 'error');
     } finally {
       isSyncing = false;
       updateQueueCount(); // Atualizar status visual final
     }
   }
   
   // Fun√ß√£o utilit√°ria para gerar timestamp no timezone correto
   function getCurrentTimestamp() {
     const now = new Date();
     
     // SOLU√á√ÉO ROBUSTA: Sempre usar formata√ß√£o manual para garantir consist√™ncia
     // Converter para timezone de S√£o Paulo (UTC-3)
     const saoPauloTime = new Date(now.getTime() - (3 * 60 * 60 * 1000));
     
     // Formatar manualmente para garantir o mesmo formato em todos os dispositivos
     const year = saoPauloTime.getUTCFullYear();
     const month = String(saoPauloTime.getUTCMonth() + 1).padStart(2, '0');
     const day = String(saoPauloTime.getUTCDate()).padStart(2, '0');
     const hours = String(saoPauloTime.getUTCHours()).padStart(2, '0');
     const minutes = String(saoPauloTime.getUTCMinutes()).padStart(2, '0');
     const seconds = String(saoPauloTime.getUTCSeconds()).padStart(2, '0');
     
     // Retornar no formato dd/MM/yyyy HH:mm:ss
     const formattedTimestamp = `${day}/${month}/${year} ${hours}:${minutes}:${seconds}`;
     
     return formattedTimestamp;
   }
   // ==============
   
   // === SISTEMA DE BACKUP AUTOM√ÅTICO ===
   let backupIntervalId = null;
   let lastBackupTime = null;
   
   // Fun√ß√£o para criar backup dos dados
   function createBackup() {
     try {
       console.log('üíæ Iniciando cria√ß√£o de backup...');
       
       const backupData = {
         timestamp: Date.now(),
         date: getCurrentTimestamp(),
         version: '1.0',
         data: {}
       };
       
       // Coletar dados do localStorage
       BACKUP_KEYS.forEach(key => {
         const value = localStorage.getItem(key);
         if (value !== null) {
           backupData.data[key] = value;
         }
       });
       
       // Adicionar dados da fila offline se configurado
       if (BACKUP_CONFIG.includeQueue) {
         const queue = getOfflineQueue();
         if (queue && queue.length > 0) {
           backupData.data.offline_queue = queue;
         }
       }
       
       // Comprimir dados se configurado
       let backupString;
       if (BACKUP_CONFIG.compress) {
         // Compress√£o simples usando JSON compacto
         backupString = JSON.stringify(backupData);
       } else {
         backupString = JSON.stringify(backupData, null, 2);
       }
       
       // Salvar backup
       const backupKey = `backup_${backupData.timestamp}`;
       localStorage.setItem(backupKey, backupString);
       
       // Atualizar lista de backups
       updateBackupList(backupKey, backupData);
       
       // Limpar backups antigos
       cleanupOldBackups();
       
       lastBackupTime = backupData.timestamp;
       
       // Atualizar timestamp do √∫ltimo backup
       localStorage.setItem('last_backup_time', backupData.timestamp.toString());
       
       console.log('‚úÖ Backup criado com sucesso:', backupKey);
       // showToast('success', 'Backup Criado', 'Backup autom√°tico realizado com sucesso', 3000); // Removido - alerta desnecess√°rio
       
       return backupKey;
       
     } catch (error) {
       console.error('‚ùå Erro ao criar backup:', error);
       // showToast('error', 'Erro no Backup', 'Falha ao criar backup autom√°tico', 3000); // Removido - alerta desnecess√°rio para backup autom√°tico
       return null;
     }
   }
   
   // Fun√ß√£o para restaurar backup
   function restoreBackup(backupKey) {
     try {
       console.log('üîÑ Iniciando restaura√ß√£o do backup:', backupKey);
       
       const backupString = localStorage.getItem(backupKey);
       if (!backupString) {
         throw new Error('Backup n√£o encontrado');
       }
       
       const backupData = JSON.parse(backupString);
       
       // Verificar se √© um backup v√°lido
       if (!backupData.data || !backupData.timestamp) {
         throw new Error('Formato de backup inv√°lido');
       }
       
       // Restaurar dados
       Object.keys(backupData.data).forEach(key => {
         if (key !== 'offline_queue') {
           localStorage.setItem(key, backupData.data[key]);
         }
       });
       
       // Restaurar fila offline se existir
       if (backupData.data.offline_queue) {
         setOfflineQueue(backupData.data.offline_queue);
       }
       
       console.log('‚úÖ Backup restaurado com sucesso');
       showToast('success', 'Backup Restaurado', 'Dados restaurados com sucesso', 3000);
       
       // Recarregar p√°gina para aplicar mudan√ßas
       setTimeout(() => {
         window.location.reload();
       }, 2000);
       
       return true;
       
     } catch (error) {
       console.error('‚ùå Erro ao restaurar backup:', error);
       showToast('error', 'Erro na Restaura√ß√£o', 'Falha ao restaurar backup', 3000);
       return false;
     }
   }
   
   // Fun√ß√£o para listar backups dispon√≠veis
   function listBackups() {
     try {
       const backups = [];
       const keys = Object.keys(localStorage);
       
       keys.forEach(key => {
         if (key.startsWith('backup_')) {
           try {
             const backupString = localStorage.getItem(key);
             const backupData = JSON.parse(backupString);
             
             backups.push({
               key: key,
               timestamp: backupData.timestamp,
               date: backupData.date,
               size: backupString.length
             });
           } catch (error) {
             console.warn('‚ö†Ô∏è Backup corrompido ignorado:', key);
           }
         }
       });
       
       // Ordenar por timestamp (mais recente primeiro)
       backups.sort((a, b) => b.timestamp - a.timestamp);
       
       return backups;
       
     } catch (error) {
       console.error('‚ùå Erro ao listar backups:', error);
       return [];
     }
   }
   
   // Fun√ß√£o para atualizar lista de backups
   function updateBackupList(backupKey, backupData) {
     try {
       const backupList = JSON.parse(localStorage.getItem('backup_list') || '[]');
       
       backupList.push({
         key: backupKey,
         timestamp: backupData.timestamp,
         date: backupData.date,
         size: JSON.stringify(backupData).length
       });
       
       // Ordenar por timestamp
       backupList.sort((a, b) => b.timestamp - a.timestamp);
       
       localStorage.setItem('backup_list', JSON.stringify(backupList));
       
     } catch (error) {
       console.error('‚ùå Erro ao atualizar lista de backups:', error);
     }
   }
   
   // Fun√ß√£o para limpar backups antigos
   function cleanupOldBackups() {
     try {
       const backups = listBackups();
       
       if (backups.length > BACKUP_CONFIG.retention) {
         const backupsToRemove = backups.slice(BACKUP_CONFIG.retention);
         
         backupsToRemove.forEach(backup => {
           localStorage.removeItem(backup.key);
           console.log('üóëÔ∏è Backup antigo removido:', backup.key);
         });
         
         // Atualizar lista
         const updatedList = backups.slice(0, BACKUP_CONFIG.retention);
         localStorage.setItem('backup_list', JSON.stringify(updatedList));
         
         console.log(`‚úÖ ${backupsToRemove.length} backup(s) antigo(s) removido(s)`);
       }
       
     } catch (error) {
       console.error('‚ùå Erro ao limpar backups antigos:', error);
     }
   }
   
   // Fun√ß√£o para iniciar backup autom√°tico
   function startAutoBackup() {
     if (!BACKUP_CONFIG.autoBackup) {
       console.log('‚è∏Ô∏è Backup autom√°tico desabilitado');
       return;
     }
     
     // Verificar se j√° existe um intervalo ativo
     if (backupIntervalId) {
       clearInterval(backupIntervalId);
     }
     
     // Criar backup inicial se necess√°rio
     const lastBackup = localStorage.getItem('last_backup_time');
     const now = Date.now();
     
     if (!lastBackup || (now - parseInt(lastBackup)) > BACKUP_CONFIG.interval) {
       console.log('üîÑ Criando backup inicial...');
       createBackup();
     }
     
     // Configurar intervalo para backups autom√°ticos
     backupIntervalId = setInterval(() => {
       console.log('‚è∞ Verificando necessidade de backup autom√°tico...');
       createBackup();
     }, BACKUP_CONFIG.interval);
     
     console.log(`‚úÖ Backup autom√°tico iniciado (intervalo: ${BACKUP_CONFIG.interval / (1000 * 60 * 60)} horas)`);
   }
   
   // Fun√ß√£o para parar backup autom√°tico
   function stopAutoBackup() {
     if (backupIntervalId) {
       clearInterval(backupIntervalId);
       backupIntervalId = null;
       console.log('‚èπÔ∏è Backup autom√°tico parado');
     }
   }
   
   // Fun√ß√£o para verificar status do backup
   function getBackupStatus() {
     const backups = listBackups();
     const lastBackup = localStorage.getItem('last_backup_time');
     
     return {
       enabled: BACKUP_CONFIG.autoBackup,
       interval: BACKUP_CONFIG.interval,
       retention: BACKUP_CONFIG.retention,
       totalBackups: backups.length,
       lastBackup: lastBackup ? new Date(parseInt(lastBackup)) : null,
       nextBackup: lastBackup ? new Date(parseInt(lastBackup) + BACKUP_CONFIG.interval) : null
     };
   }
   
   // Fun√ß√£o para criar interface de gerenciamento de backup
   function createBackupUI() {
     try {
       // Verificar se j√° existe a interface
       let backupModal = document.getElementById('backupModal');
       if (backupModal) {
         backupModal.remove();
       }
       
       // Criar modal de backup
       const modalHTML = `
         <div id="backupModal" class="modal fade" tabindex="-1" role="dialog" aria-labelledby="backupModalLabel" aria-hidden="true">
           <div class="modal-dialog modal-lg" role="document">
             <div class="modal-content">
               <div class="modal-header">
                 <h5 class="modal-title" id="backupModalLabel">
                   <i class="fa fa-database"></i> Gerenciamento de Backup
                 </h5>
                 <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                   <span aria-hidden="true">&times;</span>
                 </button>
               </div>
               <div class="modal-body">
                 <div class="row">
                   <div class="col-md-6">
                     <div class="card">
                       <div class="card-header">
                         <h6><i class="fa fa-cog"></i> Configura√ß√µes</h6>
                       </div>
                       <div class="card-body">
                         <div class="form-group">
                           <label>Status do Backup Autom√°tico:</label>
                           <div class="form-check">
                             <input class="form-check-input" type="checkbox" id="autoBackupEnabled" ${BACKUP_CONFIG.autoBackup ? 'checked' : ''}>
                             <label class="form-check-label" for="autoBackupEnabled">
                               Backup autom√°tico ativado
                             </label>
                           </div>
                         </div>
                         <div class="form-group">
                           <label>Intervalo (horas):</label>
                           <select class="form-control" id="backupInterval">
                             <option value="1" ${BACKUP_CONFIG.interval === 3600000 ? 'selected' : ''}>1 hora</option>
                             <option value="6" ${BACKUP_CONFIG.interval === 21600000 ? 'selected' : ''}>6 horas</option>
                             <option value="12" ${BACKUP_CONFIG.interval === 43200000 ? 'selected' : ''}>12 horas</option>
                             <option value="24" ${BACKUP_CONFIG.interval === 86400000 ? 'selected' : ''}>24 horas</option>
                             <option value="168" ${BACKUP_CONFIG.interval === 604800000 ? 'selected' : ''}>7 dias</option>
                           </select>
                         </div>
                         <div class="form-group">
                           <label>Reten√ß√£o (backups):</label>
                           <select class="form-control" id="backupRetention">
                             <option value="3" ${BACKUP_CONFIG.retention === 3 ? 'selected' : ''}>3 backups</option>
                             <option value="7" ${BACKUP_CONFIG.retention === 7 ? 'selected' : ''}>7 backups</option>
                             <option value="14" ${BACKUP_CONFIG.retention === 14 ? 'selected' : ''}>14 backups</option>
                             <option value="30" ${BACKUP_CONFIG.retention === 30 ? 'selected' : ''}>30 backups</option>
                           </select>
                         </div>
                         <button class="btn btn-primary btn-sm" onclick="saveBackupSettings()">
                           <i class="fa fa-save"></i> Salvar Configura√ß√µes
                         </button>
                       </div>
                     </div>
                   </div>
                   <div class="col-md-6">
                     <div class="card">
                       <div class="card-header">
                         <h6><i class="fa fa-info-circle"></i> Status</h6>
                       </div>
                       <div class="card-body">
                         <div id="backupStatus">
                           <p><strong>Total de Backups:</strong> <span id="totalBackups">-</span></p>
                           <p><strong>√öltimo Backup:</strong> <span id="lastBackup">-</span></p>
                           <p><strong>Pr√≥ximo Backup:</strong> <span id="nextBackup">-</span></p>
                           <p><strong>Status:</strong> <span id="backupStatusText">-</span></p>
                         </div>
                         <button class="btn btn-success btn-sm" onclick="createBackupNow()">
                           <i class="fa fa-plus"></i> Criar Backup Agora
                         </button>
                       </div>
                     </div>
                   </div>
                 </div>
                 <div class="row mt-3">
                   <div class="col-12">
                     <div class="card">
                       <div class="card-header">
                         <h6><i class="fa fa-list"></i> Backups Dispon√≠veis</h6>
                       </div>
                       <div class="card-body">
                         <div id="backupList">
                           <p class="text-muted">Carregando backups...</p>
                         </div>
                       </div>
                     </div>
                   </div>
                 </div>
               </div>
               <div class="modal-footer">
                 <button type="button" class="btn btn-secondary" data-dismiss="modal">Fechar</button>
               </div>
             </div>
           </div>
         </div>
       `;
       
       // Adicionar modal ao DOM
       document.body.insertAdjacentHTML('beforeend', modalHTML);
       
       // Atualizar status
       updateBackupStatus();
       
       // Carregar lista de backups
       loadBackupList();
       
       console.log('‚úÖ Interface de backup criada');
       
     } catch (error) {
       console.error('‚ùå Erro ao criar interface de backup:', error);
     }
   }
   
   // Fun√ß√£o para atualizar status do backup na interface
   function updateBackupStatus() {
     try {
       const status = getBackupStatus();
       
       document.getElementById('totalBackups').textContent = status.totalBackups;
       document.getElementById('lastBackup').textContent = status.lastBackup ? 
         status.lastBackup.toLocaleString('pt-BR') : 'Nunca';
       document.getElementById('nextBackup').textContent = status.nextBackup ? 
         status.nextBackup.toLocaleString('pt-BR') : 'N√£o agendado';
       document.getElementById('backupStatusText').textContent = status.enabled ? 
         'Ativo' : 'Inativo';
       
     } catch (error) {
       console.error('‚ùå Erro ao atualizar status do backup:', error);
     }
   }
   
   // Fun√ß√£o para carregar lista de backups
   function loadBackupList() {
     try {
       const backups = listBackups();
       const backupListDiv = document.getElementById('backupList');
       
       if (backups.length === 0) {
         backupListDiv.innerHTML = '<p class="text-muted">Nenhum backup encontrado</p>';
         return;
       }
       
       let html = '<div class="table-responsive"><table class="table table-sm">';
       html += '<thead><tr><th>Data</th><th>Tamanho</th><th>A√ß√µes</th></tr></thead><tbody>';
       
       backups.forEach(backup => {
         const sizeKB = Math.round(backup.size / 1024);
         html += `
           <tr>
             <td>${backup.date}</td>
             <td>${sizeKB} KB</td>
             <td>
               <button class="btn btn-warning btn-sm" onclick="restoreBackupFromUI('${backup.key}')" title="Restaurar">
                 <i class="fa fa-undo"></i>
               </button>
               <button class="btn btn-danger btn-sm" onclick="deleteBackup('${backup.key}')" title="Excluir">
                 <i class="fa fa-trash"></i>
               </button>
             </td>
           </tr>
         `;
       });
       
       html += '</tbody></table></div>';
       backupListDiv.innerHTML = html;
       
     } catch (error) {
       console.error('‚ùå Erro ao carregar lista de backups:', error);
     }
   }
   
   // Fun√ß√µes globais para a interface
   window.createBackupNow = function() {
     const backupKey = createBackup();
     if (backupKey) {
       updateBackupStatus();
       loadBackupList();
     }
   };
   
   window.restoreBackupFromUI = function(backupKey) {
     if (confirm('Tem certeza que deseja restaurar este backup? Todos os dados atuais ser√£o substitu√≠dos.')) {
       restoreBackup(backupKey);
     }
   };
   
   window.deleteBackup = function(backupKey) {
     if (confirm('Tem certeza que deseja excluir este backup?')) {
       localStorage.removeItem(backupKey);
       updateBackupStatus();
       loadBackupList();
       showToast('success', 'Backup Exclu√≠do', 'Backup removido com sucesso', 2000);
     }
   };
   
   window.saveBackupSettings = function() {
     try {
       const autoBackup = document.getElementById('autoBackupEnabled').checked;
       const interval = parseInt(document.getElementById('backupInterval').value) * 60 * 60 * 1000;
       const retention = parseInt(document.getElementById('backupRetention').value);
       
       // Atualizar configura√ß√µes
       BACKUP_CONFIG.autoBackup = autoBackup;
       BACKUP_CONFIG.interval = interval;
       BACKUP_CONFIG.retention = retention;
       
       // Salvar no localStorage
       localStorage.setItem('backup_settings', JSON.stringify(BACKUP_CONFIG));
       
       // Reiniciar backup autom√°tico se necess√°rio
       if (autoBackup) {
         startAutoBackup();
       } else {
         stopAutoBackup();
       }
       
       showToast('success', 'Configura√ß√µes Salvas', 'Configura√ß√µes de backup atualizadas', 2000);
       updateBackupStatus();
       
     } catch (error) {
       console.error('‚ùå Erro ao salvar configura√ß√µes:', error);
       showToast('error', 'Erro', 'Falha ao salvar configura√ß√µes', 2000);
     }
   };
   
   // Fun√ß√£o para abrir interface de backup
   window.openBackupManager = function() {
     createBackupUI();
     $('#backupModal').modal('show');
   };
   
   // === FUN√á√ïES AUXILIARES PARA CAMPOS ===
   function findComumField() {
     return document.querySelector('#comumInput');
   }
   
   function findInstrumentField() {
     return document.querySelector('#instrumento');
   }
   
   function findCargoField() {
     return document.querySelector('#cargo');
   }
   
   function findNomeField() {
     return document.querySelector('#nome');
   }
   
   function getSubmitButton() {
     const all = Array.from(document.querySelectorAll('button'));
     const byText = all.find(b => /enviar/i.test((b.textContent || '').trim()));
     if (byText) return byText;
     return document.querySelector('#btnEnviar, button[type="submit"], button[type="button"]');
   }
   
   
   
  // Fun√ß√£o para converter SELECT para INPUT quando usu√°rio escolhe digitar manualmente
  function converterParaInputManual(selectEl) {
    console.log('‚úèÔ∏è Convertendo SELECT para INPUT - modo manual escolhido pelo usu√°rio');
    console.log('‚úèÔ∏è converterParaInputManual chamada com elemento:', selectEl);
    console.log('‚úèÔ∏è converterParaInputManual - Elemento tag:', selectEl.tagName);
    console.log('‚úèÔ∏è converterParaInputManual - Elemento value:', selectEl.value);
    console.log('‚úèÔ∏è converterParaInputManual - Elemento parent:', selectEl.parentNode);
    
    // Verifica se o elemento e seu parent existem
    if (!selectEl || !selectEl.parentNode) {
      console.error('‚ùå Elemento ou parentNode n√£o encontrado para convers√£o manual');
      return null;
    }
    
    // Verifica se o elemento ainda est√° no DOM
    if (!document.contains(selectEl)) {
      console.error('‚ùå Elemento n√£o est√° mais no DOM para convers√£o manual');
      return null;
    }
     
     // Cria container para INPUT e bot√£o de retorno
     const containerEl = document.createElement('div');
     containerEl.style.position = 'relative';
     containerEl.style.display = 'flex';
     containerEl.style.alignItems = 'center';
     containerEl.style.gap = '8px';
     
     // Cria novo elemento INPUT
     const inputEl = document.createElement('input');
     inputEl.type = 'text';
     inputEl.id = 'nome';
     inputEl.className = 'form-control';
     inputEl.required = true;
     inputEl.placeholder = 'Digite o nome completo manualmente';
     inputEl.style.backgroundColor = '#e8f5e8'; // Verde claro para indicar modo manual escolhido
     inputEl.style.borderColor = '#28a745';
     inputEl.style.color = '#155724';
     inputEl.style.flex = '1';
     
     // üè∑Ô∏è MARCA√á√ÉO: Adiciona atributo para identificar nome inserido manualmente
     inputEl.setAttribute('data-nome-manual', 'true');
     console.log('üè∑Ô∏è INPUT marcado como nome manual:', inputEl.getAttribute('data-nome-manual'));
     
     // Cria bot√£o para voltar √† lista
     const returnBtn = document.createElement('button');
     returnBtn.type = 'button';
     returnBtn.className = 'btn btn-outline-primary btn-sm';
     returnBtn.innerHTML = 'üìã Voltar √† Lista';
     returnBtn.style.whiteSpace = 'nowrap';
     returnBtn.style.fontSize = '12px';
     returnBtn.style.padding = '6px 12px';
     returnBtn.title = 'Voltar para a lista de nomes';
     
     // Adiciona evento ao bot√£o de retorno
     returnBtn.addEventListener('click', function() {
       console.log('üîÑ Usu√°rio clicou em voltar √† lista');
       voltarParaListaNomes(containerEl);
     });
     
     // Adiciona elementos ao container
     containerEl.appendChild(inputEl);
     containerEl.appendChild(returnBtn);
     
     console.log('‚úèÔ∏è INPUT e bot√£o criados:', inputEl, returnBtn);
     
     // Otimiza√ß√µes para mobile
     if (isMobile) {
       inputEl.style.fontSize = '16px'; // Previne zoom no iOS
       inputEl.style.minHeight = '44px'; // Tamanho m√≠nimo para touch
       inputEl.style.padding = '12px 16px';
       inputEl.style.borderRadius = '8px';
       inputEl.style.border = '2px solid #28a745';
       inputEl.style.width = '100%';
       inputEl.style.boxSizing = 'border-box';
       inputEl.autocomplete = 'off';
       inputEl.spellcheck = false;
       
       // Adicionar feedback visual para mobile
       inputEl.addEventListener('focus', () => {
         inputEl.style.borderColor = '#1e7e34';
         inputEl.style.boxShadow = '0 0 0 3px rgba(40, 167, 69, 0.1)';
       });
       
       inputEl.addEventListener('blur', () => {
         inputEl.style.boxShadow = 'none';
       });
     }
     
     // Copia outros atributos importantes
     if (selectEl.hasAttribute('name')) {
       inputEl.setAttribute('name', selectEl.getAttribute('name'));
     }
     
     // Substitui o SELECT pelo container (INPUT + bot√£o) de forma segura
     try {
       console.log('‚úèÔ∏è Substituindo SELECT pelo container...');
       selectEl.parentNode.replaceChild(containerEl, selectEl);
       console.log('‚úÖ SELECT convertido para INPUT (modo manual) com sucesso');
       
       // Adiciona eventos ao novo elemento INPUT
       inputEl.addEventListener('change', capturarClasseAutomaticamente);
       inputEl.addEventListener('input', capturarClasseAutomaticamente);
       
       console.log('‚úèÔ∏è Event listeners adicionados ao INPUT');
       
       // Foca no campo para facilitar digita√ß√£o (sem toast)
       setTimeout(() => {
         inputEl.focus();
         console.log('‚úèÔ∏è INPUT focado');
       }, 100);
       
       return inputEl;
     } catch (error) {
       console.error('‚ùå Erro ao converter SELECT para INPUT (modo manual):', error);
       console.error('‚ùå Stack trace:', error.stack);
       return null;
     }
  }
  
  // Fun√ß√£o para voltar √† lista de nomes
  async function voltarParaListaNomes(containerEl) {
    try {
      console.log('üîÑ voltarParaListaNomes chamada');
      
      // Obt√©m os valores atuais dos campos
      const comumEl = findComumField();
      const cargoEl = findCargoField();
      const instrumentoEl = findInstrumentField();
      
      if (!comumEl || !cargoEl) {
        console.error('‚ùå Campos obrigat√≥rios n√£o encontrados para recarregar lista');
        return;
      }
      
      const comumVal = comumEl.value.trim();
      const cargoVal = cargoEl.value.trim();
      const instrumentoVal = instrumentoEl ? instrumentoEl.value.trim() : '';
      
      console.log('üîÑ Valores atuais:', { comumVal, cargoVal, instrumentoVal });
      
      // Busca nomes novamente usando a fun√ß√£o correta
      await loadNomes();
      console.log('üîÑ Nomes recarregados com sucesso');
      
      console.log('‚úÖ Volta √† lista conclu√≠da com sucesso');
      
    } catch (error) {
      console.error('‚ùå Erro ao voltar para lista:', error);
    }
  }
  
  // Fun√ß√£o para capturar classe automaticamente (placeholder)
  function capturarClasseAutomaticamente(event) {
    console.log('üéπ capturarClasseAutomaticamente chamada - Event:', event);
    console.log('üéπ capturarClasseAutomaticamente chamada - Event target:', event.target);
    console.log('üéπ capturarClasseAutomaticamente chamada - This:', this);
    
    const nomeEl = event.target || this;
    const nomeSelecionado = nomeEl.value.trim();
    
    console.log('üéπ capturarClasseAutomaticamente chamada para:', nomeSelecionado);
    console.log('üéπ capturarClasseAutomaticamente - Elemento:', nomeEl);
    console.log('üéπ capturarClasseAutomaticamente - Tag name:', nomeEl.tagName);
    
    if (!nomeSelecionado) {
      console.log('üéπ Nome vazio, saindo da fun√ß√£o');
      return;
    }
    
    // Verifica se o usu√°rio selecionou a op√ß√£o para digitar manualmente
    if (nomeSelecionado === '__MANUAL_INPUT__') {
      console.log('‚úèÔ∏è Usu√°rio escolheu digitar manualmente - convertendo para INPUT');
      console.log('‚úèÔ∏è Chamando converterParaInputManual com elemento:', nomeEl);
      setTimeout(() => {
        const resultado = converterParaInputManual(nomeEl);
        console.log('‚úèÔ∏è Resultado da convers√£o:', resultado);
      }, 50);
      return;
    }
    
    // Aqui voc√™ pode adicionar l√≥gica adicional se necess√°rio
    console.log('‚úÖ Nome selecionado/digitado:', nomeSelecionado);
  }
   
   // ==============
   
   /* ===== CONFIG ===== */
   const SUPABASE_URL      = "https://wfqehmdawhfjqbqpjapp.supabase.co";
   const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndmcWVobWRhd2hmanFicXBqYXBwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc0NDI0ODIsImV4cCI6MjA3MzAxODQ4Mn0.lFfEZKIVS7dqk48QFW4IvpRcJsgQnMjYE3iUqsrXsFg";
   
   const TABLE_CATALOGO    = "musicos_unificado";
   const TABLE_PRESENCAS   = "presencas";
   const COL_COMUM         = "comum";
   
   /* ===== FUN√á√ïES AUXILIARES ===== */
  
  // üè∑Ô∏è FUN√á√ÉO GLOBAL: Detectar se nome foi inserido manualmente
  window.isNomeManual = function() {
    console.log('üîç Verificando se nome foi inserido manualmente...');
    
    // Primeiro tenta encontrar o campo principal
    let nomeEl = findNomeField();
    
    // Se n√£o encontrar, tenta encontrar no modal
    if (!nomeEl) {
      nomeEl = document.querySelector('#gsNome');
      console.log('üîç Campo nome principal n√£o encontrado, tentando modal:', nomeEl);
    }
    
    if (!nomeEl) {
      console.log('‚ö†Ô∏è Campo nome n√£o encontrado em nenhum local');
      return false;
    }
    
    console.log('üîç DEBUG - Campo nome encontrado:', {
      tagName: nomeEl.tagName,
      id: nomeEl.id,
      value: nomeEl.value,
      hasDataAttribute: nomeEl.hasAttribute('data-nome-manual'),
      hasSelectedFromList: nomeEl.hasAttribute('data-selected-from-list'),
      backgroundColor: nomeEl.style.backgroundColor,
      borderColor: nomeEl.style.borderColor
    });
    
    // CORRE√á√ÉO CR√çTICA: Se foi selecionado da lista, NUNCA √© manual
    if (nomeEl.hasAttribute('data-selected-from-list')) {
      console.log('‚úÖ Nome selecionado da lista - N√ÉO √© manual');
      return false;
    }
    
    // Verifica se tem o atributo data-nome-manual (modo manual ativo)
    if (nomeEl.hasAttribute('data-nome-manual')) {
      console.log('‚úèÔ∏è Nome inserido manualmente detectado via atributo data-nome-manual');
      return true;
    }
    
    // Verifica se √© INPUT com estilo de entrada manual
    if (nomeEl.tagName === 'INPUT') {
      const temEstiloManual = nomeEl.style.backgroundColor === 'rgb(232, 245, 232)' || // #e8f5e8
                             nomeEl.style.backgroundColor === 'rgb(254, 243, 199)' || // #fef3c7
                             nomeEl.style.backgroundColor === 'rgb(240, 249, 255)' || // #f0f9ff
                             nomeEl.style.borderColor === 'rgb(40, 167, 69)' || // #28a745
                             nomeEl.style.borderColor === 'rgb(245, 158, 11)' || // #f59e0b
                             nomeEl.style.borderColor === 'rgb(59, 130, 246)'; // #3b82f6
      
      if (temEstiloManual) {
        console.log('‚úèÔ∏è Nome inserido manualmente detectado via estilo do INPUT');
        return true;
      }
    }
    
    // Verifica se √© SELECT com valor n√£o presente nas op√ß√µes
    if (nomeEl.tagName === 'SELECT') {
      const valorAtual = nomeEl.value;
      const opcoes = Array.from(nomeEl.options).map(option => option.value);
      
      if (valorAtual && !opcoes.includes(valorAtual) && valorAtual !== '__MANUAL_INPUT__') {
        console.log('‚úèÔ∏è Nome inserido manualmente detectado via SELECT (valor n√£o est√° nas op√ß√µes)');
        return true;
      }
    }
    
    console.log('üìã Nome selecionado da lista (n√£o manual)');
    return false;
  };

  // Fun√ß√£o para testar detec√ß√£o de entrada manual + cargo musical
  window.testarDetecaoSAM = function() {
    console.log('üß™ Testando detec√ß√£o de entrada manual + cargo musical...');
    
    // Simular dados de teste
    const cargoTeste = 'M√∫sico';
    const nomeTeste = 'Jo√£o Silva Teste';
    
    // Testar fun√ß√£o isCargoMusical
    const isMusical = isCargoMusical(cargoTeste);
    console.log('üéµ Teste isCargoMusical:', {
      cargo: cargoTeste,
      resultado: isMusical
    });
    
    // Testar detec√ß√£o inline
    const isCargoMusicalInline = cargoTeste && (
      cargoTeste.toUpperCase().includes('M√öSICO') ||
      cargoTeste.toUpperCase().includes('ORGANISTA') ||
      cargoTeste.toUpperCase().includes('EXAMINADORA') ||
      cargoTeste.toUpperCase().includes('INSTRUTORA') ||
      (cargoTeste.toLowerCase().includes('secret√°ria') && cargoTeste.toLowerCase().includes('m√∫sica'))
    );
    
    console.log('üéµ Teste isCargoMusicalInline:', {
      cargo: cargoTeste,
      resultado: isCargoMusicalInline
    });
    
    // Testar fun√ß√£o window.isNomeManual se dispon√≠vel
    if (typeof window.isNomeManual === 'function') {
      const isManual = window.isNomeManual();
      console.log('‚úèÔ∏è Teste window.isNomeManual:', {
        resultado: isManual
      });
    } else {
      console.log('‚ö†Ô∏è window.isNomeManual n√£o dispon√≠vel');
    }
    
    return {
      isMusical,
      isCargoMusicalInline,
      cargoTeste,
      nomeTeste
    };
  };

  // üö® FUN√á√ÉO DE TESTE CR√çTICA: Verificar se classe fantasma foi eliminada
  window.testarEliminacaoClasseFantasma = function() {
    console.log('üö® TESTE CR√çTICO: Verifica√ß√£o de elimina√ß√£o de classe fantasma');
    console.log('='.repeat(70));
    
    try {
      // Simular cen√°rio de nome manual + organista
      const nomeEl = document.createElement('input');
      nomeEl.setAttribute('data-nome-manual', 'true');
      nomeEl.setAttribute('data-classe', '');
      
      const cargo = 'ORGANISTA';
      const isNomeManual = nomeEl && nomeEl.hasAttribute('data-nome-manual');
      const isOrganista = cargo === 'ORGANISTA';
      const cargosComClasseOficializada = false; // Simula que n√£o √© instrutora/examinadora
      
      console.log('üìã Dados de teste:', {
        cargo,
        isNomeManual,
        isOrganista,
        cargosComClasseOficializada
      });
      
      // Aplicar a l√≥gica corrigida
      let classeFinal = null; // Simula que n√£o h√° classe do banco
      if (cargosComClasseOficializada && !classeFinal && !isNomeManual) {
        classeFinal = 'OFICIALIZADA';
        console.log(`üéØ Aplicando classe autom√°tica OFICIALIZADA para ${cargo} (nome da lista)`);
      } else if (cargosComClasseOficializada && !classeFinal && isNomeManual) {
        console.log(`üö® Nome inserido manualmente - N√ÉO aplicando classe autom√°tica para ${cargo} (cadastro desatualizado)`);
        classeFinal = null; // Garante que fique vazio
      }
      
      // Verificar resultado
      const classeNoPayload = (isOrganista && !isNomeManual) || cargosComClasseOficializada ? classeFinal : null;
      
      console.log('üîç Resultado do teste:', {
        classeFinal,
        classeNoPayload,
        isOrganista,
        cargosComClasseOficializada,
        isNomeManual
      });
      
      if (classeNoPayload === null) {
        console.log('‚úÖ SUCESSO: Classe fantasma eliminada - campo ficar√° vazio');
        console.log('‚úÖ CORRE√á√ÉO FUNCIONANDO: Nome manual + organista n√£o recebe classe autom√°tica');
        return {
          success: true,
          message: 'Classe fantasma eliminada com sucesso'
        };
      } else {
        console.log('‚ùå FALHA: Classe fantasma ainda presente:', classeNoPayload);
        return {
          success: false,
          message: 'Classe fantasma ainda n√£o foi eliminada'
        };
      }
      
    } catch (error) {
      console.error('‚ùå ERRO NO TESTE:', error);
      return {
        success: false,
        error: error.message
      };
    }
  };

  // üö® FUN√á√ÉO DE TESTE CR√çTICA: Verificar corre√ß√£o de g√™nero para organistas
  window.testarCorrecaoGeneroOrganista = async function() {
    console.log('üö® TESTE CR√çTICO: Verifica√ß√£o de corre√ß√£o de g√™nero para organistas');
    console.log('='.repeat(70));
    
    try {
      // Simular dados de teste com cargo masculino
      const nomeTeste = 'MARIA SILVA TESTE';
      const comumTeste = 'JARDIM MIRANDA';
      const cargoTeste = 'ORGANISTA';
      
      console.log('üìã Dados de teste:', { nomeTeste, comumTeste, cargoTeste });
      
      // Simular campo de cargo
      const cargoEl = document.createElement('div');
      cargoEl.setAttribute('data-cargo-real', '');
      
      console.log('üîç Testando detec√ß√£o de cargo masculino...');
      
      // Simular resultado da consulta com cargo masculino (ERRO)
      const dataSimulada = [
        {
          nome: nomeTeste,
          cargo: 'INSTRUTOR', // Cargo masculino - ERRO!
          instrumento: '√ìRG√ÉO',
          comum: comumTeste,
          nivel: 'OFICIALIZADO'
        }
      ];
      
      console.log('üìä Dados simulados (com erro):', dataSimulada);
      
      // Aplicar a l√≥gica de valida√ß√£o
      const registro = dataSimulada[0];
      const cargoEncontrado = registro.cargo;
      
      const isCargoMasculino = cargoEncontrado.toUpperCase().includes('INSTRUTOR') && 
                              !cargoEncontrado.toUpperCase().includes('INSTRUTORA');
      
      console.log('üîç An√°lise do cargo:', {
        cargo: cargoEncontrado,
        isCargoMasculino,
        contemInstrutor: cargoEncontrado.toUpperCase().includes('INSTRUTOR'),
        contemInstrutora: cargoEncontrado.toUpperCase().includes('INSTRUTORA')
      });
      
      if (isCargoMasculino) {
        console.log('‚úÖ SUCESSO: Cargo masculino detectado e rejeitado corretamente');
        console.log('‚úÖ CORRE√á√ÉO FUNCIONANDO: Sistema previne atribui√ß√£o de cargo masculino para organista');
        return {
          success: true,
          message: 'Corre√ß√£o de g√™nero funcionando corretamente'
        };
      } else {
        console.log('‚ùå FALHA: Cargo masculino n√£o foi detectado');
        return {
          success: false,
          message: 'Corre√ß√£o de g√™nero n√£o est√° funcionando'
        };
      }
      
    } catch (error) {
      console.error('‚ùå ERRO NO TESTE:', error);
      return {
        success: false,
        error: error.message
      };
    }
  };

  // üß™ FUN√á√ÉO DE TESTE COMPLETA: Testar implementa√ß√£o SAM Desatualizado
  window.testarSAMDesatualizado = async function() {
    console.log('üß™ TESTE COMPLETO: Implementa√ß√£o SAM Desatualizado');
    console.log('='.repeat(60));
    
    try {
      // 1. Testar detec√ß√£o de nome manual
      console.log('üìã 1. TESTANDO DETEC√á√ÉO DE NOME MANUAL:');
      const nomeEl = findNomeField();
      if (nomeEl) {
        console.log('‚úÖ Campo nome encontrado:', nomeEl.tagName, nomeEl.id);
        
        // Simular modo manual
        nomeEl.setAttribute('data-nome-manual', 'true');
        const isManual = window.isNomeManual();
        console.log('‚úÖ Detec√ß√£o de nome manual:', isManual);
        
        // Limpar atributo
        nomeEl.removeAttribute('data-nome-manual');
      } else {
        console.log('‚ùå Campo nome n√£o encontrado');
      }
      
      // 2. Testar detec√ß√£o de cargo musical
      console.log('\nüéµ 2. TESTANDO DETEC√á√ÉO DE CARGO MUSICAL:');
      const cargosTeste = ['M√∫sico', 'Organista', 'Examinadora', 'Instrutora', 'Secret√°ria da M√∫sica'];
      cargosTeste.forEach(cargo => {
        const isMusical = cargo && (
          cargo.toUpperCase().includes('M√öSICO') ||
          cargo.toUpperCase().includes('ORGANISTA') ||
          cargo.toUpperCase().includes('EXAMINADORA') ||
          cargo.toUpperCase().includes('INSTRUTORA') ||
          (cargo.toLowerCase().includes('secret√°ria') && cargo.toLowerCase().includes('m√∫sica'))
        );
        console.log(`‚úÖ ${cargo}: ${isMusical ? 'MUSICAL' : 'N√ÉO-MUSICAL'}`);
      });
      
      // 3. Testar l√≥gica completa de anota√ß√µes
      console.log('\nüìù 3. TESTANDO L√ìGICA DE ANOTA√á√ïES:');
      const cenariosTeste = [
        { nome: 'Jo√£o Silva', cargo: 'M√∫sico', isManual: true, esperado: 'SAM Desatualizado' },
        { nome: 'Maria Santos', cargo: 'Organista', isManual: true, esperado: 'SAM Desatualizado' },
        { nome: 'Pedro Costa', cargo: 'M√∫sico', isManual: false, esperado: '' },
        { nome: 'Ana Lima', cargo: 'Auxiliar', isManual: true, esperado: '' },
        { nome: 'Carlos Souza', cargo: 'Examinadora', isManual: true, esperado: '' }, // Examinadora n√£o recebe SAM Desatualizado
        { nome: 'Jo√£o Anci√£o', cargo: 'Anci√£o', isManual: true, esperado: '' }, // Minist√©rio n√£o recebe SAM Desatualizado
        { nome: 'Maria Di√°cono', cargo: 'Di√°cono', isManual: true, esperado: '' } // Minist√©rio n√£o recebe SAM Desatualizado
      ];
      
      cenariosTeste.forEach(cenario => {
        // CORRE√á√ÉO: Apenas M√∫sico e Organista recebem SAM Desatualizado
        const isCargoMusical = cenario.cargo && (
          cenario.cargo.toUpperCase().includes('M√öSICO') ||
          cenario.cargo.toUpperCase().includes('ORGANISTA')
        );
        
        let anotacaoFinal = '';
        if (cenario.isManual && isCargoMusical) {
          anotacaoFinal = 'SAM Desatualizado';
        }
        
        const resultado = anotacaoFinal === cenario.esperado ? '‚úÖ' : '‚ùå';
        console.log(`${resultado} ${cenario.nome} (${cenario.cargo}, manual: ${cenario.isManual}) ‚Üí "${anotacaoFinal}"`);
      });
      
      // 4. Testar fun√ß√£o collectFormData se poss√≠vel
      console.log('\nüîç 4. TESTANDO INTEGRA√á√ÉO COM collectFormData:');
      if (typeof collectFormData === 'function') {
        console.log('‚úÖ Fun√ß√£o collectFormData dispon√≠vel');
        console.log('üí° Para testar completamente, preencha o formul√°rio e envie um registro');
      } else {
        console.log('‚ùå Fun√ß√£o collectFormData n√£o encontrada');
      }
      
      console.log('\nüéâ TESTE COMPLETO FINALIZADO');
      console.log('='.repeat(60));
      
      return {
        success: true,
        message: 'Teste de implementa√ß√£o SAM Desatualizado conclu√≠do com sucesso'
      };
      
    } catch (error) {
      console.error('‚ùå ERRO NO TESTE:', error);
      return {
        success: false,
        error: error.message
      };
    }
  };

  // Fun√ß√£o para determinar se um cargo √© musical (deve receber anota√ß√£o SAM DESATUALIZADO)
  function isCargoMusical(cargo) {
    if (!cargo) return false;
    
    const cargoUpper = cargo.toUpperCase();
    const cargoLower = cargo.toLowerCase();
    
    return cargoUpper.includes('M√öSICO') ||
           cargoUpper.includes('ORGANISTA') ||
           cargoUpper.includes('EXAMINADORA') ||
           cargoUpper.includes('INSTRUTORA') ||
           (cargoLower.includes('secret√°ria') && cargoLower.includes('m√∫sica'));
  }

  /* ===== LISTAS FIXAS ===== */
  const INSTRUMENTS_FIXED = [
    'ACORDEON','VIOLINO','VIOLA','VIOLONCELO','FLAUTA','OBO√â',"OBO√â D'AMORE",'CORNE INGL√äS','CLARINETE',
    'CLARINETE ALTO','CLARINETE BAIXO (CLARONE)','CLARINETE CONTRA BAIXO','FAGOTE','SAXOFONE SOPRANO (RETO)','SAXOFONE SOPRANINO','SAXOFONE ALTO','SAXOFONE TENOR',
    'SAXOFONE BAR√çTONO','SAXOFONE BAIXO','SAXOFONE OCTA CONTRABAIXO','SAX HORN','TROMPA','TROMPETE','CORNET','FLUGELHORN','TROMBONE','TROMBONITO','EUF√îNIO','BAR√çTONO (PISTO)','TUBA'    
  ];
   
   // Mapeamento de instrumentos para naipes (PADRONIZADO)
   const INSTRUMENT_NAIPES = {
     'VIOLINO': 'CORDAS',
     'VIOLA': 'CORDAS',
     'VIOLONCELO': 'CORDAS',
     'FLAUTA': 'MADEIRAS',
     'OBO√â': 'MADEIRAS',
     "OBO√â D'AMORE": 'MADEIRAS',
     'CORNE INGL√äS': 'MADEIRAS',
     'CLARINETE': 'MADEIRAS',
     'CLARINETE ALTO': 'MADEIRAS',
     'CLARINETE BAIXO (CLARONE)': 'MADEIRAS',
     'CLARINETE CONTRA BAIXO': 'MADEIRAS',
     'FAGOTE': 'MADEIRAS',
     'SAXOFONE SOPRANO (RETO)': 'MADEIRAS',
     'SAXOFONE SOPRANINO': 'MADEIRAS',
     'SAXOFONE ALTO': 'MADEIRAS',
     'SAXOFONE TENOR': 'MADEIRAS',
     'SAXOFONE BAR√çTONO': 'MADEIRAS',
     'SAXOFONE BAIXO': 'MADEIRAS',
     'SAXOFONE OCTA CONTRABAIXO': 'MADEIRAS',
     'SAX HORN': 'METAIS',
     'TROMPA': 'METAIS',
     'TROMPETE': 'METAIS',
     'CORNET': 'METAIS',
     'FLUGELHORN': 'METAIS',
     'TROMBONE': 'METAIS',
     'TROMBONITO': 'METAIS',
     'EUF√îNIO': 'METAIS',
     'BAR√çTONO (PISTO)': 'METAIS',
     'TUBA': 'METAIS',
     'ACORDEON': 'TECLADO'     
   };
   // Cargos para o app principal (otimizados para nossa jurisdi√ß√£o)
   const CARGOS_FIXED = [
     'M√∫sico',
     'Organista',
     'Irmandade',
     'Anci√£o',
     'Di√°cono',
     'Cooperador do Of√≠cio',
     'Cooperador de Jovens',
     'Porteiro (a)',
     'Bombeiro (a)',
     'M√©dico (a)',
     'Enfermeiro (a)'
   ];
   
   // Cargos completos para o modal (todas as jurisdi√ß√µes)
   const CARGOS_COMPLETOS_MODAL = [
     // Cargos Musicais (primeiro)
     'M√∫sico',
     'Organista',
     'Instrutor',
     'Instrutora',
     'Examinadora',
     'Encarregado Local',
     'Encarregado Regional',
     'Secret√°rio da M√∫sica',
     'Secret√°ria da M√∫sica',
     
     // Cargos Ministeriais
     'Irmandade',
     'Anci√£o',
     'Di√°cono',
     'Cooperador do Of√≠cio',
     'Cooperador de Jovens',
     
     // Cargos de Servi√ßo
     'Porteiro (a)',
     'Bombeiro (a)',
     'M√©dico (a)',
     'Enfermeiro (a)'
   ];
   
   // üîß CORRE√á√ÉO: Expor vari√°vel globalmente para garantir acesso
   window.CARGOS_COMPLETOS_MODAL = CARGOS_COMPLETOS_MODAL;
   
   /* ===== SUPABASE ===== */
   let sb = null;
   let supabaseLoaded = false;
   
   // Fun√ß√£o para inicializar Supabase
   async function initSupabase() {
     console.log('üîß Tentando inicializar Supabase (opcional)...');
     
     // Configura√ß√£o para desabilitar Supabase se necess√°rio
     const SUPABASE_DISABLED = localStorage.getItem('supabase_disabled') === 'true';
     
     if (SUPABASE_DISABLED) {
       console.log('‚ö†Ô∏è Supabase desabilitado pelo usu√°rio');
       supabaseLoaded = false;
       return false;
     }
     
     try {
       // üö® CORRE√á√ÉO: Aguarda 500ms para garantir que o script carregou completamente (era 100ms - muito curto)
       await new Promise(resolve => setTimeout(resolve, 500));
       
       if (typeof window.supabase !== 'undefined' && typeof window.supabase.createClient === 'function') {
         console.log('üîß Criando cliente Supabase...');
         // üö® CORRE√á√ÉO: Configurar timeout de 30 segundos para consultas Supabase
         // Timeout muito curto estava cancelando consultas antes que completassem
         sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
           db: {
             schema: 'public'
           },
           global: {
             headers: {
               'x-client-info': 'ccb-presenca'
             }
           },
           // Configurar timeout de 30 segundos para requisi√ß√µes
           fetch: (url, options = {}) => {
             const controller = new AbortController();
             const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 segundos
             
             return fetch(url, {
               ...options,
               signal: controller.signal
             }).finally(() => {
               clearTimeout(timeoutId);
             });
           }
         });
         
         // Testar se o cliente foi criado corretamente
         if (sb && typeof sb.from === 'function') {
           supabaseLoaded = true;
           // üöÄ CORRE√á√ÉO: Expor vari√°veis globalmente para o index.html
           window.supabaseLoaded = true;
           window.sb = sb;
           console.log('‚úÖ Supabase carregado e inicializado com sucesso');
           console.log('‚úÖ Vari√°veis expostas globalmente: window.supabaseLoaded =', window.supabaseLoaded);
           return true;
         } else {
           console.warn('‚ö†Ô∏è Cliente Supabase criado mas n√£o funcional');
           supabaseLoaded = false;
           return false;
         }
       } else {
         console.warn('‚ö†Ô∏è Supabase n√£o dispon√≠vel - sistema funcionar√° apenas com Google Sheets');
         supabaseLoaded = false;
         // üöÄ CORRE√á√ÉO: Expor vari√°veis mesmo quando Supabase n√£o est√° dispon√≠vel
         window.supabaseLoaded = false;
         window.sb = null;
         return false;
       }
     } catch (error) {
       console.warn('‚ö†Ô∏è Erro na inicializa√ß√£o do Supabase - sistema funcionar√° apenas com Google Sheets:', error.message);
       supabaseLoaded = false;
       // üöÄ CORRE√á√ÉO: Expor vari√°veis mesmo em caso de erro
       window.supabaseLoaded = false;
       window.sb = null;
       return false;
     }
   }
   
  /* ===== HELPERS GERAIS ===== */
  // üö® CORRE√á√ÉO: Remover logs excessivos de debug que geram spam no console
  // üõ°Ô∏è NORMALIZA√á√ÉO ROBUSTA CROSS-PLATFORM
  const norm  = s => {
    try {
      if (s === null || s === undefined) return '';
      // Garantir que √© string e remover espa√ßos extras
      let result = String(s).trim();
      // Remover caracteres de controle e caracteres invis√≠veis
      result = result.replace(/[\x00-\x1F\x7F-\x9F]/g, '');
      // Normalizar espa√ßos m√∫ltiplos
      result = result.replace(/\s+/g, ' ');
      return result;
    } catch (e) {
      console.warn('‚ö†Ô∏è Erro na normaliza√ß√£o:', e);
      return '';
    }
  };
  const upper = s => {
    try {
      return norm(s).toUpperCase();
    } catch (e) {
      console.warn('‚ö†Ô∏è Erro ao converter para mai√∫scula:', e);
      return '';
    }
  };
  // üõ°Ô∏è REMO√á√ÉO DE ACENTOS ROBUSTA CROSS-PLATFORM
  const noacc = s => {
    try {
      if (!s) return '';
      // Normalizar para NFD (decomposi√ß√£o can√¥nica)
      let result = String(s).normalize('NFD');
      // Remover diacr√≠ticos (acentos)
      result = result.replace(/\p{Diacritic}/gu, '');
      // Fallback para navegadores antigos que n√£o suportam \p{Diacritic}
      if (result === String(s)) {
        result = result
          .replace(/[\u0300-\u036f]/g, '') // Remover combining diacritical marks
          .replace(/[√†√°√¢√£√§√•]/gi, 'a')
          .replace(/[√®√©√™√´]/gi, 'e')
          .replace(/[√¨√≠√Æ√Ø]/gi, 'i')
          .replace(/[√≤√≥√¥√µ√∂]/gi, 'o')
          .replace(/[√π√∫√ª√º]/gi, 'u')
          .replace(/[√ß]/gi, 'c')
          .replace(/[√±]/gi, 'n');
      }
      return result;
    } catch (e) {
      console.warn('‚ö†Ô∏è Erro ao remover acentos:', e);
      return String(s || '');
    }
  };
  const ucase = s => {
    try {
      return noacc(s).toUpperCase();
    } catch (e) {
      console.warn('‚ö†Ô∏è Erro ao converter sem acentos para mai√∫scula:', e);
      return '';
    }
  };
  
  // üõ°Ô∏è FUN√á√ÉO UTILIT√ÅRIA: Compara√ß√£o robusta de comum (cross-platform)
  // Centraliza a l√≥gica de compara√ß√£o de comum para garantir consist√™ncia
  // @param {string} comumRegistro - O valor de comum do registro
  // @param {string} comumBuscado - O valor de comum buscado
  // @param {object} options - Op√ß√µes de debug (opcional)
  // @returns {object} - Objeto com resultado da compara√ß√£o e detalhes para debug
  const compareComum = (comumRegistro, comumBuscado, options = {}) => {
    try {
      // Normaliza√ß√£o pr√©via
      const comumRNormalizado = norm(comumRegistro || '');
      const comumValNormalizado = norm(comumBuscado || '');
      
      // Valores normalizados e sem acentos
      const comumRSemAcento = noacc(comumRNormalizado).toUpperCase().trim();
      const comumRUpper = comumRNormalizado.toUpperCase().trim();
      const comumValSemAcentoUpper = noacc(comumValNormalizado).toUpperCase().trim();
      const comumValUpper = comumValNormalizado.toUpperCase().trim();
      
      // M√∫ltiplas estrat√©gias de compara√ß√£o para garantir robustez
      const match1 = comumRSemAcento.includes(comumValSemAcentoUpper);
      const match2 = comumRUpper.includes(comumValUpper);
      const match3 = comumValSemAcentoUpper.includes(comumRSemAcento);
      const match4 = comumValUpper.includes(comumRUpper);
      const match5 = comumRNormalizado.toUpperCase().trim() === comumValNormalizado.toUpperCase().trim();
      
      const match = match1 || match2 || match3 || match4 || match5;
      
      // Retorna objeto com resultado e detalhes para debug (se solicitado)
      const result = {
        match,
        comumRegistro: comumRNormalizado,
        comumBuscado: comumValNormalizado,
        matchDetails: options.debug ? {
          match1,
          match2,
          match3,
          match4,
          match5,
          comumRSemAcento,
          comumRUpper,
          comumValSemAcentoUpper,
          comumValUpper
        } : undefined
      };
      
      // üìä Monitoramento autom√°tico (se dispon√≠vel)
      if (window.monitorarComparacaoComum) {
        try {
          window.monitorarComparacaoComum.registrar(comumRegistro, comumBuscado, match, null);
        } catch (monitorError) {
          // Ignorar erros de monitoramento para n√£o quebrar a fun√ß√£o principal
          console.warn('‚ö†Ô∏è Erro no monitoramento:', monitorError);
        }
      }
      
      return result;
    } catch (e) {
      console.warn('‚ö†Ô∏è Erro na compara√ß√£o de comum:', e);
      const errorResult = {
        match: false,
        error: e.message
      };
      
      // üìä Registrar erro no monitoramento
      if (window.monitorarComparacaoComum) {
        try {
          window.monitorarComparacaoComum.registrar(comumRegistro, comumBuscado, false, e.message);
        } catch (monitorError) {
          // Ignorar erros de monitoramento
        }
      }
      
      return errorResult;
    }
  };
   
   // Fun√ß√£o espec√≠fica para normalizar instrumentos
  const normalizeInstrument = s => {
    let result = norm(s).toUpperCase();
    
    // Se a string est√° vazia, retorna vazio sem tentar normalizar
    if (!result || result.trim() === '') {
      console.log('üîç DEBUG - normalizeInstrument(): entrada vazia, retornando vazio');
      return '';
    }
    
    // üîß CORRE√á√ÉO: Normaliza varia√ß√µes do clarinete baixo (clarone)
    if (result.includes('CLARONE') || result.includes('CLARINETE BAIXO')) {
      // Se cont√©m CLARONE ou CLARINETE BAIXO, garante que usa o nome completo padronizado
      if (result.includes('CLARONE') && !result.includes('CLARINETE BAIXO')) {
        // Se s√≥ tem CLARONE, converte para o nome completo
        result = 'CLARINETE BAIXO (CLARONE)';
      } else if (result.includes('CLARINETE BAIXO')) {
        // Garante que tenha os par√™nteses corretos
        if (!result.includes('(CLARONE)')) {
          result = result.replace(/CLARINETE\s*BAIXO.*/i, 'CLARINETE BAIXO (CLARONE)');
        } else {
          // Normaliza espa√ßos extras nos par√™nteses
          result = result.replace(/CLARINETE\s*BAIXO\s*\(\s*CLARONE\s*\)/i, 'CLARINETE BAIXO (CLARONE)');
        }
      }
    }
    
    // üö® CORRE√á√ÉO CR√çTICA: Normalizar "SAXOFONE SOPRANO (RETO)" para "SAXOFONE SOPRANO RET"
    // No banco de dados est√° armazenado como "SAXOFONE SOPRANO RET" (sem par√™nteses e sem "O")
    // Por isso precisamos normalizar para fazer match com o banco
    if (result.includes('SAXOFONE SOPRANO (RETO)')) {
      result = result.replace('SAXOFONE SOPRANO (RETO)', 'SAXOFONE SOPRANO RET');
    }
    if (result.includes('SAXOFONE SOPRANO (RET)')) {
      result = result.replace('SAXOFONE SOPRANO (RET)', 'SAXOFONE SOPRANO RET');
    }
    if (result.includes('SAXOFONE SOPRANO RETO') && !result.includes('SAXOFONE SOPRANO RET')) {
      // Se tem "SAXOFONE SOPRANO RETO" sem par√™nteses, normalizar para "SAXOFONE SOPRANO RET"
      result = result.replace('SAXOFONE SOPRANO RETO', 'SAXOFONE SOPRANO RET');
    }
    
    // Verifica se o resultado est√° na lista de instrumentos v√°lidos
    // üö® CORRE√á√ÉO CR√çTICA: Para SAXOFONE SOPRANO RET, n√£o verificar na lista
    // O formato normalizado "SAXOFONE SOPRANO RET" n√£o est√° na lista, mas est√° no banco
    // Por isso, se for SAXOFONE SOPRANO RET, manter como est√° para a busca funcionar
    if (!INSTRUMENTS_FIXED.includes(result)) {
      // Se for SAXOFONE SOPRANO RET, manter como est√° (est√° no banco assim)
      if (result.includes('SAXOFONE SOPRANO RET')) {
        console.log('üîç SAXOFONE SOPRANO RET detectado - mantendo formato para busca (est√° no banco assim):', result);
        // N√£o alterar result, manter como est√° para a busca funcionar
      } else {
        console.warn('‚ö†Ô∏è Instrumento normalizado n√£o encontrado na lista:', result);
        // Tenta encontrar um instrumento similar (apenas se result n√£o for vazio)
        if (result && result.length > 0) {
          let similar = INSTRUMENTS_FIXED.find(inst => {
            // Busca exata
            if (inst === result) return true;
            // Busca por includes (ambas dire√ß√µes)
            if (inst.includes(result) || result.includes(inst)) return true;
            return false;
          });
          
          if (similar) {
            console.log('üîç Instrumento similar encontrado:', similar, '(original:', result, ')');
            result = similar;
          }
        }
      }
    }
    
    console.log('üîç DEBUG - normalizeInstrument():', { input: s, output: result });
    return result;
  };
  
  // üîß FUN√á√ÉO AUXILIAR: Compara instrumentos de forma robusta (especialmente para clarinete baixo e saxofone soprano)
  const matchInstrument = (instrumentoBusca, instrumentoBanco) => {
    if (!instrumentoBusca || !instrumentoBanco) return false;
    
    // Normaliza ambos os instrumentos
    const instBuscaNorm = normalizeInstrument(instrumentoBusca);
    const instBancoNorm = normalizeInstrument(instrumentoBanco);
    
    // Se ambos s√£o vazios ap√≥s normaliza√ß√£o, n√£o faz match
    if (!instBuscaNorm || !instBancoNorm) return false;
    
    // Compara√ß√£o direta
    if (instBuscaNorm === instBancoNorm) return true;
    
    // üîß CORRE√á√ÉO ESPECIAL: Para clarinete baixo, aceita qualquer varia√ß√£o
    if (instBuscaNorm.includes('CLARINETE BAIXO') || instBuscaNorm.includes('CLARONE') ||
        instBancoNorm.includes('CLARINETE BAIXO') || instBancoNorm.includes('CLARONE')) {
      const isClaroneBusca = instBuscaNorm.includes('CLARINETE BAIXO') || instBuscaNorm.includes('CLARONE');
      const isClaroneBanco = instBancoNorm.includes('CLARINETE BAIXO') || instBancoNorm.includes('CLARONE');
      if (isClaroneBusca && isClaroneBanco) {
        console.log('‚úÖ Match CLARINETE BAIXO (CLARONE):', { instBuscaNorm, instBancoNorm });
        return true;
      }
    }
    
    // üö® CORRE√á√ÉO ESPEC√çFICA SAXOFONE SOPRANO: Aceita varia√ß√µes com/sem par√™nteses e RETO/RET
    if (instBuscaNorm.includes('SAXOFONE SOPRANO') && instBancoNorm.includes('SAXOFONE SOPRANO')) {
      const buscaTemReto = instBuscaNorm.includes('RETO') || instBuscaNorm.includes('RET');
      const bancoTemReto = instBancoNorm.includes('RETO') || instBancoNorm.includes('RET');
      if (buscaTemReto && bancoTemReto) {
        console.log('‚úÖ Match SAXOFONE SOPRANO (RETO):', { instBuscaNorm, instBancoNorm });
        return true;
      }
    }
    
    // Compara√ß√£o usando includes (fallback)
    return instBancoNorm.includes(instBuscaNorm) || instBuscaNorm.includes(instBancoNorm);
  };
   
   // Fun√ß√£o para padronizar dados em mai√∫scula
   function padronizarDadosMaiuscula(dados) {
     if (!dados || typeof dados !== 'object') return dados;
     
     const dadosPadronizados = { ...dados };
     
     // üõ°Ô∏è PROTE√á√ÉO: Preserva o UUID original (NUNCA modificar UUID)
     const uuidOriginal = dados.uuid;
     
     // Campos que devem ser convertidos para mai√∫scula
     const camposMaiuscula = [
       'nome', 'nome_completo', 'comum', 'cidade', 'cargo', 'instrumento', 
       'naipe', 'naipe_instrumento', 'classe_organista', 'local_ensaio',
       'NOME COMPLETO', 'COMUM', 'CIDADE', 'CARGO', 'INSTRUMENTO', 
       'NAIPE_INSTRUMENTO', 'CLASSE_ORGANISTA', 'LOCAL_ENSAIO'
     ];
     
     // üõ°Ô∏è SEGURAN√áA: Valida√ß√£o de comprimento m√°ximo para campos de texto
     const MAX_FIELD_LENGTH = {
       nome: 255,
       comum: 255,
       cidade: 255,
       cargo: 100,
       instrumento: 100,
       anotacoes: 1000
     };
     
     camposMaiuscula.forEach(campo => {
       // Preserva null e undefined, s√≥ converte strings
       if (dadosPadronizados[campo] !== null && dadosPadronizados[campo] !== undefined && typeof dadosPadronizados[campo] === 'string') {
         // üõ°Ô∏è SEGURAN√áA: Truncar campos que excedem comprimento m√°ximo
         const campoKey = campo.toLowerCase().replace(/[_\s]/g, '');
         const maxLength = MAX_FIELD_LENGTH[campoKey] || 255;
         
         if (dadosPadronizados[campo].length > maxLength) {
           if (window.safeLog) {
             window.safeLog.warn(`‚ö†Ô∏è Campo ${campo} excedeu comprimento m√°ximo (${maxLength}), truncando...`);
           }
           dadosPadronizados[campo] = dadosPadronizados[campo].substring(0, maxLength);
         }
         
         // üõ°Ô∏è SEGURAN√áA: Remover caracteres de controle e normalizar
         dadosPadronizados[campo] = dadosPadronizados[campo]
           .replace(/[\x00-\x1F\x7F-\x9F]/g, '') // Remove caracteres de controle
           .trim();
         
         dadosPadronizados[campo] = upper(dadosPadronizados[campo]);
       }
     });
     
     // üõ°Ô∏è SEGURAN√áA: Validar e sanitizar anota√ß√µes
     if (dadosPadronizados.anotacoes && typeof dadosPadronizados.anotacoes === 'string') {
       if (dadosPadronizados.anotacoes.length > MAX_FIELD_LENGTH.anotacoes) {
         if (window.safeLog) {
           window.safeLog.warn(`‚ö†Ô∏è Campo anotacoes excedeu comprimento m√°ximo, truncando...`);
         }
         dadosPadronizados.anotacoes = dadosPadronizados.anotacoes.substring(0, MAX_FIELD_LENGTH.anotacoes);
       }
       // Remover caracteres de controle
       dadosPadronizados.anotacoes = dadosPadronizados.anotacoes.replace(/[\x00-\x1F\x7F-\x9F]/g, '').trim();
     }
     
     // üõ°Ô∏è RESTAURA UUID ORIGINAL: Garante que o UUID nunca seja modificado
     if (uuidOriginal) {
       dadosPadronizados.uuid = uuidOriginal;
     }
     
     console.log('üîÑ Dados padronizados em mai√∫scula:', dadosPadronizados);
     return dadosPadronizados;
   }
   
   // Fun√ß√£o para obter o naipe do instrumento (PADRONIZADA)
   function getInstrumentNaipe(instrumento) {
     if (!instrumento) return null;
     const instrumentoUpper = upper(instrumento);
     const naipe = INSTRUMENT_NAIPES[instrumentoUpper];
     
     if (naipe) {
       console.log(`üéµ getInstrumentNaipe: ${instrumento} ‚Üí ${naipe}`);
       return naipe;
     }
     
     // Busca parcial para instrumentos com varia√ß√µes
     for (const [instrumentoKey, naipeValue] of Object.entries(INSTRUMENT_NAIPES)) {
       if (instrumentoUpper.includes(instrumentoKey) || instrumentoKey.includes(instrumentoUpper)) {
         console.log(`üéµ getInstrumentNaipe (parcial): ${instrumento} ‚Üí ${naipeValue}`);
         return naipeValue;
       }
     }
     
     console.log(`‚ö†Ô∏è getInstrumentNaipe: Naipe n√£o encontrado para ${instrumento}`);
     return null;
   }
   
   // Fun√ß√£o para normalizar cargos (remove varia√ß√µes de g√™nero)
   function normalizeCargo(cargo) {
     if (!cargo) return '';
     return upper(cargo)
       .replace(/\(A\)/g, '') // Remove (A)
       .replace(/\(O\)/g, '') // Remove (O)
       .replace(/\s+/g, ' ')  // Remove espa√ßos extras
       .trim();
   }
   
   // Fun√ß√£o para expandir busca de cargos (inclui varia√ß√µes de g√™nero)
   function expandCargoSearch(cargo) {
     if (!cargo) return [];
     
     const cargoNormalizado = normalizeCargo(cargo);
     const variacoes = [cargoNormalizado];
     
     // Se cont√©m "SECRET√ÅRIO", adiciona varia√ß√µes
     if (cargoNormalizado.includes('SECRET√ÅRIO')) {
       variacoes.push(cargoNormalizado.replace('SECRET√ÅRIO', 'SECRET√ÅRIO (A)'));
       variacoes.push(cargoNormalizado.replace('SECRET√ÅRIO', 'SECRET√ÅRIO(A)'));
       // Tamb√©m adiciona a busca original com acentos
       variacoes.push(cargo.replace('Secret√°rio', 'Secret√°rio (A)'));
       variacoes.push(cargo.replace('Secret√°rio', 'Secret√°rio(A)'));
     }
     
     // Se cont√©m "M√öSICO", adiciona varia√ß√µes
     if (cargoNormalizado.includes('M√öSICO')) {
       variacoes.push(cargoNormalizado.replace('M√öSICO', 'M√öSICO (A)'));
       variacoes.push(cargoNormalizado.replace('M√öSICO', 'M√öSICO(A)'));
       // Tamb√©m adiciona a busca original com acentos
       variacoes.push(cargo.replace('M√∫sico', 'M√∫sico (A)'));
       variacoes.push(cargo.replace('M√∫sico', 'M√∫sico(A)'));
     }
     
     // Se cont√©m "ORGANISTA", adiciona varia√ß√µes
     if (cargoNormalizado.includes('ORGANISTA')) {
       variacoes.push(cargoNormalizado.replace('ORGANISTA', 'ORGANISTA (A)'));
       variacoes.push(cargoNormalizado.replace('ORGANISTA', 'ORGANISTA(A)'));
       // Tamb√©m adiciona a busca original com acentos
       variacoes.push(cargo.replace('Organista', 'Organista (A)'));
       variacoes.push(cargo.replace('Organista', 'Organista(A)'));
     }
     
     return [...new Set(variacoes)]; // Remove duplicatas
   }
   
   
   /* ===== SISTEMA DE PESQUISA PARA COMUM ===== */
   let comumData = [];
   let searchCache = new Map(); // Cache para resultados de pesquisa
   
  function updateComumData() {
    // Atualiza os dados de pesquisa com as comuns atuais
    const comumInput = document.getElementById('comumInput');
    if (!comumInput) {
      console.error('‚ùå updateComumData: Campo comumInput n√£o encontrado');
      return;
    }
    
    if (comumInput.dataset.comumList) {
      try {
        comumData = JSON.parse(comumInput.dataset.comumList);
        // Limpa o cache quando os dados s√£o atualizados
        searchCache.clear();
        console.log('üìã Dados de comum atualizados:', comumData.length, 'itens');
      } catch (e) {
        console.error('‚ùå updateComumData: Erro ao parsear dados:', e);
        comumData = [];
        searchCache.clear();
      }
    } else {
      console.warn('‚ö†Ô∏è updateComumData: Dataset comumList n√£o encontrado no campo');
      // Tenta buscar novamente ap√≥s um pequeno delay
      setTimeout(() => {
        if (comumInput.dataset.comumList) {
          updateComumData();
        } else {
          console.warn('‚ö†Ô∏è updateComumData: Dataset ainda n√£o dispon√≠vel ap√≥s delay');
        }
      }, 100);
    }
  }
   
   function highlightText(text, searchTerm) {
     if (!searchTerm) return text;
     
     const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
     return text.replace(regex, '<span class="highlight">$1</span>');
   }
   
   function searchComuns(searchTerm) {
     console.log('üîç searchComuns chamada com termo:', searchTerm);
     console.log('üîç comumData.length:', comumData.length);
     
     if (!searchTerm || searchTerm.length < 1) {
       console.log('üîç Termo vazio, retornando TODAS as comuns (', comumData.length, ')');
       return comumData; // Retorna TODAS as comuns, sem limita√ß√£o
     }
     
     const term = ucase(searchTerm);
     console.log('üîç Termo normalizado:', term);
     
     // Cache mais eficiente
     if (searchCache.has(term)) {
       console.log('üîç Resultado encontrado no cache');
       return searchCache.get(term);
     }
     
     // Pesquisa otimizada - busca por in√≠cio primeiro
     let results = comumData.filter(comum => {
       const comumUpper = ucase(comum);
       return comumUpper.startsWith(term);
     });
     
     console.log('üîç Resultados por in√≠cio:', results.length, results);
     
     // üöÄ CORRE√á√ÉO: Sempre busca por cont√©m, independente do n√∫mero de resultados por in√≠cio
     const containsResults = comumData.filter(comum => {
       const comumUpper = ucase(comum);
       return comumUpper.includes(term) && !comumUpper.startsWith(term);
     });
     console.log('üîç Resultados por cont√©m:', containsResults.length, containsResults);
     results = results.concat(containsResults);
     
     // üö® CORRE√á√ÉO CR√çTICA: Remover duplicatas dos resultados
     const resultsAntes = results.length;
     const resultsUnicos = new Set();
     results.forEach(comum => {
       if (comum && typeof comum === 'string') {
         resultsUnicos.add(comum.toUpperCase().trim());
       }
     });
     results = Array.from(resultsUnicos)
       .sort((a,b)=>a.localeCompare(b,'pt-BR'));
     
     if (results.length < resultsAntes) {
       console.warn(`‚ö†Ô∏è searchComuns: ${resultsAntes - results.length} duplicatas removidas dos resultados`);
     }
     
     // üöÄ CORRE√á√ÉO: Remove limita√ß√£o de resultados - retorna TODOS os resultados encontrados (sem duplicatas)
     console.log('üîç Resultados finais (TODOS, sem duplicatas):', results.length, results);
     
     // Cache inteligente
     if (searchCache.size >= 100) {
       const firstKey = searchCache.keys().next().value;
       searchCache.delete(firstKey);
     }
     searchCache.set(term, results);
     
     return results;
   }
   
   function showComumResults(results, searchTerm) {
     const dropdown = document.getElementById('comumResults');
     if (!dropdown) {
       console.error('‚ùå Dropdown comumResults n√£o encontrado!');
       return;
     }
     
     console.log('üîç showComumResults chamada:', { results, searchTerm, resultsLength: results.length });
     
    if (results.length === 0) {
      // CORRE√á√ÉO: Verificar se est√° no modal usando o dropdown
      const isInModal = dropdown.closest('#modalNovaComum');
      if (!isInModal) {
        dropdown.innerHTML = '<div class="suggestion-item no-suggestions">Nenhuma comum encontrada</div>';
        dropdown.classList.add('show');
        console.log('üîç Mostrando "Nenhuma comum encontrada"');
      } else {
        dropdown.classList.remove('show');
        console.log('üîç Modal detectado - n√£o mostrando mensagem');
      }
    } else {
       // üö® CORRE√á√ÉO: Normalizar comuns para mai√∫scula na exibi√ß√£o
       dropdown.innerHTML = results.map(comum => {
         const comumUpper = comum.toUpperCase();
         const searchTermUpper = searchTerm ? searchTerm.toUpperCase() : '';
         return `
         <div class="suggestion-item" data-value="${comum}">
           <i class="fa-solid fa-map-marker-alt"></i>
           <span>${highlightText(comumUpper, searchTermUpper)}</span>
         </div>
       `;
       }).join('');
       
       dropdown.classList.add('show');
       console.log('üîç Mostrando', results.length, 'resultados');
     }
     
     // Ativa anima√ß√£o da seta
     const searchIcon = document.querySelector('.search-icon');
     if (searchIcon) {
       searchIcon.classList.add('active');
     }
     
     console.log('üîç Dropdown deve estar vis√≠vel agora');
   }
   
   function hideComumResults() {
     const dropdown = document.getElementById('comumResults');
     if (dropdown) {
       dropdown.classList.remove('show');
     }
     
     // Desativa anima√ß√£o da seta
     const searchIcon = document.querySelector('.search-icon');
     if (searchIcon) {
       searchIcon.classList.remove('active');
     }
     
     // Remove overlay no mobile (sempre remove para garantir)
     hideMobileOverlay();
   }
   
   // Fun√ß√µes para gerenciar overlay mobile
   function showMobileOverlay() {
     // Usar a vari√°vel global isMobile j√° declarada
     
     // S√≥ usa overlay em mobile
     if (!isMobile) {
       return;
     }
     
     let overlay = document.getElementById('suggestionsOverlay');
     if (!overlay) {
       overlay = document.createElement('div');
       overlay.id = 'suggestionsOverlay';
       overlay.className = 'suggestions-overlay';
       document.body.appendChild(overlay);
       
       // Sistema unificado de eventos para mobile
       // Usar a vari√°vel global isMobile j√° declarada
       
       if (isMobile) {
         // Fecha dropdown ao tocar no overlay
         overlay.addEventListener('touchend', (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (e.target === overlay) {
             hideComumResults();
           }
         }, { passive: false });
         
         // Previne scroll quando overlay est√° ativo
         overlay.addEventListener('touchmove', (e) => {
           e.preventDefault();
         }, { passive: false });
       } else {
         // Para desktop, usa click
         overlay.addEventListener('click', (e) => {
           if (e.target === overlay) {
             hideComumResults();
           }
         });
       }
     }
     overlay.classList.add('show');
   }
   
   function hideMobileOverlay() {
     const overlay = document.getElementById('suggestionsOverlay');
     if (overlay) {
       overlay.classList.remove('show');
     }
     
     // No Android, remove completamente o overlay se existir
     const isAndroid = /Android/.test(navigator.userAgent);
     if (isAndroid && overlay) {
       overlay.remove();
       console.log('ü§ñ Overlay removido do Android');
     }
   }
   
   function selectComumResult(comum) {
     const comumInput = document.getElementById('comumInput');
     if (comumInput) {
       // üö® CORRE√á√ÉO: Normalizar para mai√∫scula ao selecionar
       comumInput.value = comum.toUpperCase();
       
       // Dispara evento de mudan√ßa para atualizar depend√™ncias
       const event = new Event('change', { bubbles: true });
       comumInput.dispatchEvent(event);
       
       // No mobile, remove o foco para fechar o teclado
       // Usar a vari√°vel global isMobile j√° declarada
       if (isMobile) {
         comumInput.blur();
         
         // Foca no pr√≥ximo campo ap√≥s um pequeno delay
         setTimeout(() => {
           const cargoField = document.getElementById('cargo');
           if (cargoField) {
             cargoField.focus();
             // Scroll suave para o campo de cargo
             cargoField.scrollIntoView({ behavior: 'smooth', block: 'center' });
           }
         }, 200);
       } else {
         // No desktop, foca no pr√≥ximo campo imediatamente
         const cargoField = document.getElementById('cargo');
         if (cargoField) {
           setTimeout(() => cargoField.focus(), 100);
         }
       }
     }
     
     hideComumResults();
     
     // Log para debug
     console.log('‚úÖ Comum selecionada:', comum);
   }
   
   function initComumSearch() {
     const comumInput = document.getElementById('comumInput');
     const comumResults = document.getElementById('comumResults');
     
     if (!comumInput || !comumResults) return;
     
     let searchTimeout;
     let isOpen = false;
     let highlightedIndex = -1;
     let currentResults = [];
     
     // Fun√ß√£o para mostrar resultados apenas quando necess√°rio
     function showResultsIfNeeded(searchTerm) {
       const hasResults = currentResults.length > 0;
       const hasSearchTerm = searchTerm && searchTerm.length > 0;
       
       console.log('üîç showResultsIfNeeded:', { searchTerm, hasResults, hasSearchTerm, currentResults });
       
       // CORRE√á√ÉO: Sempre mostra dropdown se houver termo de pesquisa
       if (hasSearchTerm) {
         showComumResults(currentResults, searchTerm);
         isOpen = true;
       } else {
         hideComumResults();
         isOpen = false;
       }
     }
     
     // Evento de digita√ß√£o - OTIMIZADO PARA EFICI√äNCIA
     comumInput.addEventListener('input', (e) => {
       const searchTerm = e.target.value.trim();
       highlightedIndex = -1; // Reset sele√ß√£o
       
       clearTimeout(searchTimeout);
       
       // Timeout mais r√°pido para melhor responsividade
       searchTimeout = setTimeout(() => {
         // CORRE√á√ÉO: Garante que os dados estejam carregados
         if (comumData.length === 0) {
           console.log('üîç Dados de comum vazios, tentando carregar...');
           updateComumData();
           
           // Se ainda estiver vazio, for√ßa carregamento
           if (comumData.length === 0) {
             console.log('üîç For√ßando carregamento de comuns...');
             loadComunsFromCatalog().then(() => {
               currentResults = searchComuns(searchTerm);
               showResultsIfNeeded(searchTerm);
             });
             return;
           }
         }
         
         currentResults = searchComuns(searchTerm);
         
         // üöÄ CORRE√á√ÉO: Mostra dropdown apenas quando h√° texto digitado
         if (searchTerm && searchTerm.length > 0) {
           showResultsIfNeeded(searchTerm);
           isOpen = true;
         } else {
           hideComumResults();
           isOpen = false;
         }
       }, 150); // Aumentado para 150ms para melhor UX
     });
     
     // Evento de foco - N√ÉO mostra dropdown automaticamente quando vazio
     comumInput.addEventListener('focus', (e) => {
       const searchTerm = comumInput.value.trim();
       updateComumData();
       
       if (searchTerm && searchTerm.length > 0) {
         // Se h√° texto, busca normalmente
         currentResults = searchComuns(searchTerm);
         showResultsIfNeeded(searchTerm);
       } else {
         // üöÄ CORRE√á√ÉO: N√£o mostra dropdown automaticamente quando vazio
         console.log('üîç Campo vazio - dropdown n√£o ser√° mostrado automaticamente');
         hideComumResults();
         isOpen = false;
       }
     });
     
     // Evento de clique no campo - N√ÉO mostra dropdown automaticamente quando vazio
     comumInput.addEventListener('click', (e) => {
       const searchTerm = comumInput.value.trim();
       updateComumData();
       
       if (searchTerm && searchTerm.length > 0) {
         // Se h√° texto, busca normalmente
         currentResults = searchComuns(searchTerm);
         showResultsIfNeeded(searchTerm);
       } else {
         // üöÄ CORRE√á√ÉO: N√£o mostra dropdown automaticamente quando vazio
         console.log('üîç Campo vazio - dropdown n√£o ser√° mostrado automaticamente');
         hideComumResults();
         isOpen = false;
       }
     });
     
     // Evento de clique na seta do dropdown
     const searchIcon = document.querySelector('.search-icon');
     if (searchIcon) {
       searchIcon.addEventListener('click', (e) => {
         e.preventDefault();
         e.stopPropagation();
         
         if (!isOpen) {
           updateComumData();
           const searchTerm = comumInput.value.trim();
           
           if (searchTerm && searchTerm.length > 0) {
             currentResults = searchComuns(searchTerm);
             showResultsIfNeeded(searchTerm);
           } else {
             // üöÄ CORRE√á√ÉO: Clique na seta mostra todas as comuns quando vazio
             console.log('üîç Campo vazio - mostrando TODAS as comuns via clique na seta');
             currentResults = searchComuns(''); // Busca vazia retorna todas
             showComumResults(currentResults, '');
             isOpen = true;
           }
         } else {
           hideComumResults();
           isOpen = false;
           highlightedIndex = -1;
         }
       });
     }
     
     // Evento de clique nos resultados - SIMPLES E FUNCIONAL
     comumResults.addEventListener('click', (e) => {
       const item = e.target.closest('.suggestion-item');
       if (item) {
         e.preventDefault();
         e.stopPropagation();
         const value = item.dataset.value;
         selectComumResult(value);
         hideComumResults();
         isOpen = false;
         highlightedIndex = -1;
       }
     });
     
     // Evento de clique fora para fechar
     document.addEventListener('click', (e) => {
       if (!comumInput.contains(e.target) && !comumResults.contains(e.target)) {
         hideComumResults();
         isOpen = false;
         highlightedIndex = -1;
       }
     });
     
     // Navega√ß√£o por teclado - MELHORADA
     comumInput.addEventListener('keydown', (e) => {
       const items = comumResults.querySelectorAll('.suggestion-item');
       
       switch (e.key) {
         case 'ArrowDown':
           e.preventDefault();
           if (items.length > 0) {
             highlightedIndex = Math.min(highlightedIndex + 1, items.length - 1);
             updateHighlight(items, highlightedIndex);
             scrollToSelected(items[highlightedIndex]);
           }
           break;
           
         case 'ArrowUp':
           e.preventDefault();
           if (items.length > 0) {
             highlightedIndex = Math.max(highlightedIndex - 1, 0);
             updateHighlight(items, highlightedIndex);
             scrollToSelected(items[highlightedIndex]);
           }
           break;
           
         case 'Enter':
           e.preventDefault();
           if (highlightedIndex >= 0 && items[highlightedIndex]) {
             const item = items[highlightedIndex];
             const value = item.dataset.value;
             selectComumResult(value);
             highlightedIndex = -1;
             isOpen = false;
           } else if (items.length > 0) {
             // Se n√£o h√° item destacado, seleciona o primeiro
             const firstItem = items[0];
             const value = firstItem.dataset.value;
             selectComumResult(value);
             highlightedIndex = -1;
             isOpen = false;
           }
           break;
           
         case 'Escape':
           e.preventDefault();
           hideComumResults();
           highlightedIndex = -1;
           isOpen = false;
           comumInput.blur(); // Remove foco do campo
           break;
           
         case 'Tab':
           // Permite tab normal, mas fecha dropdown
           if (isOpen) {
             hideComumResults();
             isOpen = false;
             highlightedIndex = -1;
           }
           break;
       }
     });
     
     // Previne que o dropdown abra ap√≥s envio do formul√°rio
     comumInput.addEventListener('blur', (e) => {
       // üîß CORRE√á√ÉO: Converte para mai√∫scula quando o campo perde o foco
       if (comumInput.value) {
         comumInput.value = comumInput.value.toUpperCase();
       }
       
       // Delay para permitir clique nos resultados
       setTimeout(() => {
         if (!comumResults.contains(document.activeElement)) {
           hideComumResults();
           isOpen = false;
           highlightedIndex = -1;
         }
       }, 150);
     });
     
     // CORRE√á√ÉO: Inicializa√ß√£o for√ßada dos dados de comum
     console.log('üîç Inicializando dados de comum...');
     updateComumData();
     
     // Se n√£o h√° dados, for√ßa carregamento
     if (comumData.length === 0) {
       console.log('üîç Dados vazios, for√ßando carregamento...');
       loadComunsFromCatalog().then(() => {
         console.log('üîç Dados de comum carregados:', comumData.length, 'itens');
       });
     } else {
       console.log('üîç Dados de comum j√° dispon√≠veis:', comumData.length, 'itens');
     }
     
     function updateHighlight(items, index) {
       items.forEach((item, i) => {
         item.classList.toggle('selected', i === index);
         item.classList.toggle('highlighted', i === index);
       });
     }
     
     // Fun√ß√£o auxiliar para scroll at√© item selecionado
     function scrollToSelected(item) {
       if (item) {
         item.scrollIntoView({
           behavior: 'smooth',
           block: 'nearest'
         });
       }
     }
   }
   
   /* ===== SISTEMA DE NOTIFICA√á√ïES COM FALLBACK ===== */
   // üé® SISTEMA DE NOTIFICA√á√ÉO ELEGANTE E MODERNO
   function showFastAlert(type, title, message, duration = 800) {
     // üöÄ OTIMIZA√á√ÉO: Mobile - design moderno e r√°pido
     const notification = createElegantNotification(type, title, message, duration);
     
     // Adiciona ao DOM IMEDIATAMENTE
     document.body.appendChild(notification);
     
     // Posiciona IMEDIATAMENTE
     positionNotification(notification);
     
     // Anima√ß√£o de entrada INSTANT√ÇNEA (sem requestAnimationFrame para mobile)
     if (isMobile) {
       notification.classList.add('notification-enter');
     } else {
       requestAnimationFrame(() => {
         notification.classList.add('notification-enter');
       });
     }
     
     // Remove automaticamente (dura√ß√£o otimizada)
     setTimeout(() => {
       removeNotification(notification);
     }, duration);
   }
   
   function positionNotification(notification) {
     const existingNotifications = document.querySelectorAll('.elegant-notification');
     const index = existingNotifications.length;
     
     if (isMobile) {
       // üöÄ MOBILE: Design moderno centralizado com anima√ß√£o r√°pida
       notification.style.position = 'fixed';
       notification.style.top = '50%';
       notification.style.left = '50%';
       notification.style.right = 'auto';
       notification.style.bottom = 'auto';
       notification.style.transform = 'translate(-50%, -50%)';
       notification.style.width = 'calc(100vw - 32px)';
       notification.style.maxWidth = '380px';
       notification.style.margin = '0';
       notification.style.zIndex = '99999';
       notification.style.borderRadius = '20px';
       notification.style.boxShadow = '0 20px 60px rgba(0,0,0,0.3), 0 0 0 1px rgba(255,255,255,0.1)';
       notification.style.backdropFilter = 'blur(20px)';
     } else {
       // Para desktop: posicionamento no canto superior direito
       const topOffset = 20 + (index * 80); // 80px de espa√ßamento entre notifica√ß√µes
       notification.style.top = `${topOffset}px`;
       notification.style.right = '20px';
       notification.style.left = 'auto';
     }
   }
   
   function createElegantNotification(type, title, message, duration) {
     const notification = document.createElement('div');
     notification.className = 'elegant-notification';
     
     const icons = {
       success: '‚úì',
       error: '‚úï',
       warning: '‚ö†',
       info: '‚Ñπ',
       queue: 'üöÄ'
     };
     
     const colors = {
       success: {
         bg: 'linear-gradient(135deg, #10b981 0%, #059669 50%, #047857 100%)',
         border: '#10b981',
         icon: '#ffffff',
         glow: 'rgba(16, 185, 129, 0.3)'
       },
       error: {
         bg: 'linear-gradient(135deg, #ef4444 0%, #dc2626 50%, #b91c1c 100%)',
         border: '#ef4444',
         icon: '#ffffff',
         glow: 'rgba(239, 68, 68, 0.3)'
       },
       warning: {
         bg: 'linear-gradient(135deg, #f59e0b 0%, #d97706 50%, #b45309 100%)',
         border: '#f59e0b',
         icon: '#ffffff',
         glow: 'rgba(245, 158, 11, 0.3)'
       },
       info: {
         bg: 'linear-gradient(135deg, #3b82f6 0%, #2563eb 50%, #1d4ed8 100%)',
         border: '#3b82f6',
         icon: '#ffffff',
         glow: 'rgba(59, 130, 246, 0.3)'
       },
       queue: {
         bg: 'linear-gradient(135deg, #8b5cf6 0%, #7c3aed 50%, #6d28d9 100%)',
         border: '#8b5cf6',
         icon: '#ffffff',
         glow: 'rgba(139, 92, 246, 0.3)'
       }
     };
     
     const config = colors[type] || colors.info;
     
     notification.innerHTML = `
       <div class="notification-content">
         <div class="notification-icon" style="background: ${config.bg}; color: ${config.icon}; box-shadow: 0 8px 20px ${config.glow};">
           ${icons[type] || icons.info}
         </div>
         <div class="notification-text">
           <div class="notification-title">${title}</div>
           <div class="notification-message">${message}</div>
         </div>
         <button class="notification-close" onclick="removeNotification(this.parentElement.parentElement)">
           √ó
         </button>
       </div>
       <div class="notification-progress" style="background: linear-gradient(90deg, ${config.border}, ${config.border}dd); animation-duration: ${duration}ms;"></div>
       <div class="notification-glow" style="background: radial-gradient(circle, ${config.glow} 0%, transparent 70%);"></div>
     `;
     
     // Adiciona evento de clique para fechar
     notification.addEventListener('click', (e) => {
       if (!e.target.classList.contains('notification-close')) {
         removeNotification(notification);
       }
     });
     
     return notification;
   }
   
   function removeNotification(notification) {
     if (!notification) return;
     
     notification.classList.add('notification-exit');
     
     setTimeout(() => {
       if (notification.parentNode) {
         notification.parentNode.removeChild(notification);
         // Reposiciona as notifica√ß√µes restantes
         repositionRemainingNotifications();
       }
     }, 300);
   }
   
   function repositionRemainingNotifications() {
     const notifications = document.querySelectorAll('.elegant-notification');
     notifications.forEach((notification, index) => {
       const topOffset = 20 + (index * 80);
       notification.style.top = `${topOffset}px`;
     });
   }
   
   function removeAllNotifications() {
     const notifications = document.querySelectorAll('.elegant-notification');
     notifications.forEach(removeNotification);
   }
   
   // Sistema de alertas profissional e elegante
   // üö® CORRE√á√ÉO: Simplificar para usar API padr√£o do SweetAlert2 (conforme documenta√ß√£o)
   function showToast(type, title, message = '', duration = 1500) {
     if (typeof Swal === 'undefined') {
       alert(`${title}: ${message}`);
       return;
     }
     
     // üö® CORRE√á√ÉO: Usar API padr√£o do SweetAlert2 - simples e funcional
     // Conforme documenta√ß√£o: https://sweetalert2.github.io/#examples
     try {
       Swal.fire({
         icon: type || 'success',
         title: title,
         text: message,
         toast: true,
         position: 'top-end',
         showConfirmButton: false,
         timer: duration,
         timerProgressBar: true
       });
     } catch (error) {
       console.error('‚ùå Erro ao exibir SweetAlert2:', error);
       alert(`${title}: ${message}`);
     }
   }
   
   // üö® CORRE√á√ÉO: Simplificar para usar API padr√£o do SweetAlert2
   function showConfirmAlert(title, text, confirmText = 'Sim', cancelText = 'Cancelar') {
     if (typeof Swal === 'undefined') {
       return Promise.resolve({ isConfirmed: confirm(text) });
     }
     
     return Swal.fire({
       title: title,
       text: text,
       icon: 'warning',
       showCancelButton: true,
       confirmButtonText: confirmText,
       cancelButtonText: cancelText
     });
   }
   
   // üö® CORRE√á√ÉO: Simplificar para usar API padr√£o do SweetAlert2
   function showLoadingAlert(title = 'Carregando...', text = 'Aguarde um momento') {
     if (typeof Swal === 'undefined') {
       return;
     }
     
     return Swal.fire({
       title: title,
       text: text,
       allowOutsideClick: false,
       allowEscapeKey: false,
       showConfirmButton: false,
       didOpen: () => {
         Swal.showLoading();
       }
     });
   }
   
   // Fun√ß√£o para fechar alertas de loading
   function hideLoadingAlert() {
     Swal.close();
   }
   
   // üö® CORRE√á√ÉO: Simplificar para usar API padr√£o do SweetAlert2
   function showLoading(title = 'Processando...', message = 'Aguarde um momento') {
     if (typeof Swal === 'undefined') {
       return;
     }
     
     return Swal.fire({
       title: title,
       text: message,
       allowOutsideClick: false,
       allowEscapeKey: false,
       showConfirmButton: false,
       didOpen: () => {
         Swal.showLoading();
       }
     });
   }
   
   // Fun√ß√£o para esconder loading
   function hideLoading() {
     if (typeof Swal !== 'undefined') {
       Swal.close();
     }
   }
   
   /* ===== SISTEMA DE EDI√á√ÉO DE REGISTROS ===== */
   
   // Fun√ß√£o para verificar se o usu√°rio pode editar um registro espec√≠fico
   async function podeEditarRegistro(registro) {
     try {
       console.log('üîç Verificando permiss√£o para editar registro:', registro);
       
       // 1. Verificar se √© usu√°rio master
       const isMaster = await verificarStatusMaster();
       if (!isMaster) {
         console.log('‚ùå Usu√°rio n√£o √© master - sem permiss√£o para editar');
         return { pode: false, motivo: 'Usu√°rio n√£o √© master' };
       }
       
       // 2. Verificar se o registro pertence ao local do usu√°rio
       const sessionLocal = localStorage.getItem('session_local');
       const registroLocal = registro.local_ensaio || registro.LOCAL_ENSAIO || '';
       
       console.log('üîç Comparando locais:', { sessionLocal, registroLocal });
       
       if (!sessionLocal) {
         console.log('‚ùå Usu√°rio n√£o tem local definido');
         return { pode: false, motivo: 'Usu√°rio n√£o tem local definido' };
       }
       
       // Verificar se os locais coincidem (case insensitive)
       const locaisCoincidem = sessionLocal.toLowerCase().trim() === registroLocal.toLowerCase().trim();
       
       if (!locaisCoincidem) {
         console.log('‚ùå Registro n√£o pertence ao local do usu√°rio');
         return { 
           pode: false, 
           motivo: `Registro pertence a "${registroLocal}" mas usu√°rio √© de "${sessionLocal}"` 
         };
       }
       
       console.log('‚úÖ Usu√°rio pode editar o registro');
       return { pode: true, motivo: 'Permiss√£o concedida' };
       
     } catch (error) {
       console.error('‚ùå Erro ao verificar permiss√£o de edi√ß√£o:', error);
       return { pode: false, motivo: 'Erro na verifica√ß√£o' };
     }
   }
   
   // Fun√ß√£o para buscar registros edit√°veis pelo usu√°rio
   async function buscarRegistrosEditaveis() {
     try {
       console.log('üîç Buscando registros edit√°veis...');
       
       if (!supabaseLoaded || !sb) {
         console.log('‚ùå Supabase n√£o dispon√≠vel');
         return { sucesso: false, dados: [], erro: 'Supabase n√£o dispon√≠vel' };
       }
       
       const sessionLocal = localStorage.getItem('session_local');
       if (!sessionLocal) {
         console.log('‚ùå Usu√°rio n√£o tem local definido');
         return { sucesso: false, dados: [], erro: 'Usu√°rio n√£o tem local definido' };
       }
       
       // Buscar registros do local do usu√°rio
       const { data, error } = await sb
         .from(TABLE_PRESENCAS)
         .select('*')
         .ilike('local_ensaio', `%${sessionLocal}%`)
         .order('created_at', { ascending: false })
         .limit(100); // Limitar a 100 registros mais recentes
       
       if (error) {
         console.error('‚ùå Erro ao buscar registros:', error);
         return { sucesso: false, dados: [], erro: error.message };
       }
       
       console.log(`‚úÖ Encontrados ${data.length} registros edit√°veis`);
       return { sucesso: true, dados: data, erro: null };
       
     } catch (error) {
       console.error('‚ùå Erro geral ao buscar registros:', error);
       return { sucesso: false, dados: [], erro: error.message };
     }
   }
   
   // Fun√ß√£o para abrir modal de edi√ß√£o
   async function abrirModalEdicao(registro) {
     try {
       console.log('üìù Abrindo modal de edi√ß√£o para:', registro);
       
       // Verificar permiss√£o
       const permissao = await podeEditarRegistro(registro);
       if (!permissao.pode) {
         showToast('error', 'Sem permiss√£o', permissao.motivo, 4000);
         return;
       }
       
       // Criar modal de edi√ß√£o
       const modalHtml = `
         <div class="modal fade" id="modalEdicao" tabindex="-1" aria-labelledby="modalEdicaoLabel" aria-hidden="true">
           <div class="modal-dialog modal-lg">
             <div class="modal-content">
               <div class="modal-header">
                 <h5 class="modal-title" id="modalEdicaoLabel">
                   üìù Editar Registro - ${registro.nome_completo || registro.NOME_COMPLETO || 'N/A'}
                 </h5>
                 <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
               </div>
               <div class="modal-body">
                 <form id="formEdicao">
                   <div class="row">
                     <div class="col-md-6">
                       <div class="mb-3">
                         <label for="editNome" class="form-label">Nome Completo</label>
                         <input type="text" class="form-control" id="editNome" value="${registro.nome_completo || registro.NOME_COMPLETO || ''}" required>
                       </div>
                     </div>
                     <div class="col-md-6">
                       <div class="mb-3">
                         <label for="editComum" class="form-label">Comum</label>
                         <input type="text" class="form-control" id="editComum" value="${registro.comum || registro.COMUM || ''}" required>
                       </div>
                     </div>
                   </div>
                   
                   <div class="row">
                     <div class="col-md-6">
                       <div class="mb-3">
                         <label for="editCidade" class="form-label">Cidade</label>
                         <input type="text" class="form-control" id="editCidade" value="${registro.cidade || registro.CIDADE || ''}">
                       </div>
                     </div>
                     <div class="col-md-6">
                       <div class="mb-3">
                         <label for="editCargo" class="form-label">Cargo</label>
                         <input type="text" class="form-control" id="editCargo" value="${registro.cargo || registro.CARGO || ''}" required>
                       </div>
                     </div>
                   </div>
                   
                   <div class="row">
                     <div class="col-md-6">
                       <div class="mb-3">
                         <label for="editInstrumento" class="form-label">Instrumento</label>
                         <input type="text" class="form-control" id="editInstrumento" value="${registro.instrumento || registro.INSTRUMENTO || ''}">
                       </div>
                     </div>
                     <div class="col-md-6">
                       <div class="mb-3">
                         <label for="editNaipe" class="form-label">Naipe do Instrumento</label>
                         <input type="text" class="form-control" id="editNaipe" value="${registro.naipe_instrumento || registro.NAIPE_INSTRUMENTO || ''}">
                       </div>
                     </div>
                   </div>
                   
                   <div class="row">
                     <div class="col-md-6">
                       <div class="mb-3">
                         <label for="editClasse" class="form-label">Classe do Organista</label>
                         <input type="text" class="form-control" id="editClasse" value="${registro.classe_organista || registro.CLASSE_ORGANISTA || ''}">
                       </div>
                     </div>
                     <div class="col-md-6">
                       <div class="mb-3">
                         <label for="editLocalEnsaio" class="form-label">Local do Ensaio</label>
                         <input type="text" class="form-control" id="editLocalEnsaio" value="${registro.local_ensaio || registro.LOCAL_ENSAIO || ''}" readonly>
                       </div>
                     </div>
                   </div>
                   
                   <div class="row">
                     <div class="col-md-6">
                       <div class="mb-3">
                         <label for="editDataEnsaio" class="form-label">Data do Ensaio</label>
                         <input type="text" class="form-control" id="editDataEnsaio" value="${registro.data_ensaio || registro.DATA_ENSAIO || ''}">
                       </div>
                     </div>
                     <div class="col-md-6">
                       <div class="mb-3">
                         <label for="editRegistradoPor" class="form-label">Registrado Por</label>
                         <input type="text" class="form-control" id="editRegistradoPor" value="${registro.registrado_por || registro.REGISTRADO_POR || ''}" readonly>
                       </div>
                     </div>
                   </div>
                   
                   <div class="mb-3">
                     <label for="editAnotacoes" class="form-label">Anota√ß√µes</label>
                     <textarea class="form-control" id="editAnotacoes" rows="3">${registro.anotacoes || registro.ANOTACOES || ''}</textarea>
                   </div>
                   
                   <input type="hidden" id="editUuid" value="${registro.uuid || registro.UUID || ''}">
                 </form>
               </div>
               <div class="modal-footer">
                 <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                 <button type="button" class="btn btn-primary" id="btnSalvarEdicao">
                   üíæ Salvar Altera√ß√µes
                 </button>
               </div>
             </div>
           </div>
         </div>
       `;
       
       // Remover modal existente se houver
       const modalExistente = document.getElementById('modalEdicao');
       if (modalExistente) {
         modalExistente.remove();
       }
       
       // Adicionar modal ao DOM
       document.body.insertAdjacentHTML('beforeend', modalHtml);
       
       // Mostrar modal
       const modal = new bootstrap.Modal(document.getElementById('modalEdicao'));
       modal.show();
       
       // Adicionar event listener para salvar
       document.getElementById('btnSalvarEdicao').addEventListener('click', () => {
         salvarEdicaoRegistro(registro);
       });
       
     } catch (error) {
       console.error('‚ùå Erro ao abrir modal de edi√ß√£o:', error);
       showToast('error', 'Erro', 'Falha ao abrir modal de edi√ß√£o', 3000);
     }
   }
   
   // Fun√ß√£o para salvar edi√ß√£o do registro
   async function salvarEdicaoRegistro(registroOriginal) {
     try {
       console.log('üíæ Salvando edi√ß√£o do registro...');
       
       // Coletar dados do formul√°rio
       const dadosEditados = {
         uuid: document.getElementById('editUuid').value,
         nome_completo: document.getElementById('editNome').value.trim(),
         comum: document.getElementById('editComum').value.trim(),
         cidade: document.getElementById('editCidade').value.trim(),
         cargo: document.getElementById('editCargo').value.trim(),
         instrumento: document.getElementById('editInstrumento').value.trim(),
         naipe_instrumento: document.getElementById('editNaipe').value.trim(),
         classe_organista: document.getElementById('editClasse').value.trim(),
         local_ensaio: document.getElementById('editLocalEnsaio').value.trim(),
         data_ensaio: document.getElementById('editDataEnsaio').value.trim(),
         registrado_por: document.getElementById('editRegistradoPor').value.trim(),
         anotacoes: document.getElementById('editAnotacoes').value.trim()
       };
       
       // Valida√ß√£o b√°sica
       if (!dadosEditados.nome_completo || !dadosEditados.comum || !dadosEditados.cargo) {
         showToast('error', 'Campos obrigat√≥rios', 'Nome, Comum e Cargo s√£o obrigat√≥rios', 3000);
         return;
       }
       
       // Loading removido para acelerar processamento
       
       // Verificar permiss√£o novamente
       const permissao = await podeEditarRegistro(registroOriginal);
       if (!permissao.pode) {
         showToast('error', 'Sem permiss√£o', permissao.motivo, 4000);
         return;
       }
       
       // Atualizar no Supabase
       if (supabaseLoaded && sb) {
         const { data, error } = await sb
           .from(TABLE_PRESENCAS)
           .update(dadosEditados)
           .eq('uuid', dadosEditados.uuid);
         
         if (error) {
           console.error('‚ùå Erro ao atualizar registro:', error);
           showToast('error', 'Erro', 'Falha ao salvar altera√ß√µes', 3000);
           return;
         }
         
         showToast('success', 'Sucesso', 'Registro atualizado com sucesso!', 3000);
         
         // Fechar modal
         const modal = bootstrap.Modal.getInstance(document.getElementById('modalEdicao'));
         if (modal) {
           modal.hide();
         }
         
         // Atualizar lista se estiver vis√≠vel
         if (typeof atualizarListaRegistros === 'function') {
           atualizarListaRegistros();
         }
         
       } else {
         showToast('error', 'Erro', 'Sistema n√£o dispon√≠vel', 3000);
       }
       
     } catch (error) {
       console.error('‚ùå Erro ao salvar edi√ß√£o:', error);
       showToast('error', 'Erro', 'Falha ao salvar altera√ß√µes', 3000);
     }
   }
   
   // Vari√°vel global para armazenar registros carregados
   let registrosCarregados = [];
   
   // Fun√ß√£o auxiliar para abrir modal de edi√ß√£o por √≠ndice
   window.abrirModalEdicaoPorIndex = function(index) {
     if (registrosCarregados[index]) {
       abrirModalEdicao(registrosCarregados[index]);
     } else {
       showToast('error', 'Erro', 'Registro n√£o encontrado', 3000);
     }
   };
   
   // Fun√ß√£o para listar registros edit√°veis
   async function listarRegistrosEditaveis() {
     try {
       console.log('üìã Listando registros edit√°veis...');
       
       const resultado = await buscarRegistrosEditaveis();
       
       if (!resultado.sucesso) {
         showToast('error', 'Erro', resultado.erro, 4000);
         return;
       }
       
       if (resultado.dados.length === 0) {
         showToast('info', 'Nenhum registro', 'Nenhum registro encontrado para edi√ß√£o', 3000);
         return;
       }
       
       // Armazenar registros globalmente para acesso por √≠ndice
       registrosCarregados = resultado.dados;
       
       // Criar modal de lista
       const modalHtml = `
         <div class="modal fade" id="modalListaEdicao" tabindex="-1" aria-labelledby="modalListaEdicaoLabel" aria-hidden="true">
           <div class="modal-dialog modal-xl">
             <div class="modal-content">
               <div class="modal-header">
                 <h5 class="modal-title" id="modalListaEdicaoLabel">
                   üìù Registros Edit√°veis - ${localStorage.getItem('session_local') || 'Local'}
                 </h5>
                 <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
               </div>
               <div class="modal-body">
                 <div class="table-responsive">
                   <table class="table table-striped table-hover">
                     <thead>
                       <tr>
                         <th>Nome</th>
                         <th>Comum</th>
                         <th>Cargo</th>
                         <th>Instrumento</th>
                         <th>Data</th>
                         <th>A√ß√µes</th>
                       </tr>
                     </thead>
                     <tbody id="tabelaRegistros">
                       ${resultado.dados.map((registro, index) => `
                         <tr>
                           <td>${registro.nome_completo || 'N/A'}</td>
                           <td>${registro.comum || 'N/A'}</td>
                           <td>${registro.cargo || 'N/A'}</td>
                           <td>${registro.instrumento || 'N/A'}</td>
                           <td>${new Date(registro.created_at).toLocaleDateString('pt-BR')}</td>
                           <td>
                             <button class="btn btn-sm btn-primary" onclick="abrirModalEdicaoPorIndex(${index})">
                               ‚úèÔ∏è Editar
                             </button>
                           </td>
                         </tr>
                       `).join('')}
                     </tbody>
                   </table>
                 </div>
               </div>
               <div class="modal-footer">
                 <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
                 <button type="button" class="btn btn-primary" onclick="listarRegistrosEditaveis()">
                   üîÑ Atualizar Lista
                 </button>
               </div>
             </div>
           </div>
         </div>
       `;
       
       // Remover modal existente se houver
       const modalExistente = document.getElementById('modalListaEdicao');
       if (modalExistente) {
         modalExistente.remove();
       }
       
       // Adicionar modal ao DOM
       document.body.insertAdjacentHTML('beforeend', modalHtml);
       
       // Mostrar modal
       const modal = new bootstrap.Modal(document.getElementById('modalListaEdicao'));
       modal.show();
       
     } catch (error) {
       console.error('‚ùå Erro ao listar registros:', error);
       showToast('error', 'Erro', 'Falha ao carregar lista de registros', 3000);
     }
   }
   
   /* ===== ESTILOS CSS ELEGANTES PARA NOTIFICA√á√ïES MODERNAS ===== */
   const elegantNotificationStyles = `
   <style>
   .elegant-notification {
     position: fixed;
     top: 20px;
     right: 20px;
     z-index: 10000;
     min-width: 340px;
     max-width: 420px;
     background: linear-gradient(135deg, rgba(255, 255, 255, 0.98) 0%, rgba(255, 255, 255, 0.95) 100%);
     backdrop-filter: blur(25px) saturate(180%);
     border-radius: 20px;
     box-shadow: 
       0 25px 50px rgba(0, 0, 0, 0.12),
       0 0 0 1px rgba(255, 255, 255, 0.4),
       inset 0 1px 0 rgba(255, 255, 255, 0.6);
     border: 1px solid rgba(255, 255, 255, 0.5);
     overflow: hidden;
     transform: translateX(100%) scale(0.95);
     opacity: 0;
     transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
     font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
     cursor: pointer;
   }
   
   .elegant-notification.notification-enter {
     transform: translateX(0) scale(1);
     opacity: 1;
   }
   
   .elegant-notification.notification-exit {
     transform: translateX(100%) scale(0.9);
     opacity: 0;
   }
   
   .notification-content {
     display: flex;
     align-items: flex-start;
     padding: 24px 28px;
     gap: 16px;
     position: relative;
   }
   
   .notification-icon {
     width: 52px;
     height: 52px;
     border-radius: 50%;
     display: flex;
     align-items: center;
     justify-content: center;
     font-size: 22px;
     font-weight: bold;
     flex-shrink: 0;
     box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(255, 255, 255, 0.2);
     position: relative;
     overflow: hidden;
   }
   
   .notification-icon::before {
     content: '';
     position: absolute;
     top: -3px;
     left: -3px;
     right: -3px;
     bottom: -3px;
     border-radius: 50%;
     background: linear-gradient(45deg, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0.1));
     z-index: -1;
   }
   
   .notification-text {
     flex: 1;
     min-width: 0;
     padding-top: 4px;
   }
   
   .notification-title {
     font-size: 18px;
     font-weight: 700;
     color: #1f2937;
     margin-bottom: 6px;
     line-height: 1.3;
     letter-spacing: -0.02em;
   }
   
   .notification-message {
     font-size: 15px;
     color: #4b5563;
     line-height: 1.5;
     font-weight: 500;
   }
   
   .notification-close {
     background: none;
     border: none;
     font-size: 20px;
     color: #9ca3af;
     cursor: pointer;
     padding: 4px;
     border-radius: 4px;
     transition: all 0.2s ease;
     flex-shrink: 0;
     width: 28px;
     height: 28px;
     display: flex;
     align-items: center;
     justify-content: center;
   }
   
   .notification-close:hover {
     background: rgba(0, 0, 0, 0.05);
     color: #6b7280;
   }
   
   .elegant-notification:hover {
     transform: translateX(-4px);
     box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2), 0 0 0 1px rgba(255, 255, 255, 0.3);
   }
   
   .elegant-notification:hover .notification-progress {
     animation-play-state: paused;
   }
   
   .notification-progress {
     height: 4px;
     width: 100%;
     transform: scaleX(1);
     transform-origin: left;
     animation: notificationProgress 2s linear forwards;
     border-radius: 0 0 20px 20px;
     box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
   }
   
   .notification-glow {
     position: absolute;
     top: 50%;
     left: 50%;
     width: 200px;
     height: 200px;
     transform: translate(-50%, -50%);
     border-radius: 50%;
     pointer-events: none;
     z-index: -1;
     opacity: 0.6;
     animation: glowPulse 3s ease-in-out infinite;
   }
   
   @keyframes notificationProgress {
     from {
       transform: scaleX(1);
     }
     to {
       transform: scaleX(0);
     }
   }
   
   @keyframes glowPulse {
     0%, 100% {
       opacity: 0.3;
       transform: translate(-50%, -50%) scale(0.8);
     }
     50% {
       opacity: 0.6;
       transform: translate(-50%, -50%) scale(1.1);
     }
   }
   
   /* Estilos personalizados para SweetAlert2 de fila - SIMPLES */
   .swal2-popup-queue {
     border-radius: 20px !important;
   }
   
   .swal2-title-queue {
     color: #1f2937 !important;
     font-weight: 700 !important;
     font-size: 24px !important;
   }
   
   .swal2-content-queue {
     color: #6b7280 !important;
     font-size: 16px !important;
   }
   
   
   /* Modo escuro */
   @media (prefers-color-scheme: dark) {
     .elegant-notification {
       background: rgba(31, 41, 55, 0.95);
       border: 1px solid rgba(75, 85, 99, 0.3);
     }
     
     .notification-title {
       color: #f9fafb;
     }
     
     .notification-message {
       color: #d1d5db;
     }
     
     .notification-close {
       color: #9ca3af;
     }
     
     .notification-close:hover {
       background: rgba(255, 255, 255, 0.1);
       color: #d1d5db;
     }
   }
   
   /* Responsivo para mobile - DESIGN MODERNO E R√ÅPIDO */
   @media (max-width: 768px) {
     .elegant-notification {
       position: fixed !important;
       top: 50% !important;
       left: 50% !important;
       right: auto !important;
       bottom: auto !important;
       transform: translate(-50%, -50%) !important;
       min-width: 320px !important;
       max-width: calc(100vw - 32px) !important;
       width: auto !important;
       z-index: 99999 !important;
       margin: 0 !important;
       border-radius: 20px !important;
       box-shadow: 
         0 20px 60px rgba(0, 0, 0, 0.3),
         0 0 0 1px rgba(255, 255, 255, 0.2),
         inset 0 1px 0 rgba(255, 255, 255, 0.3) !important;
       backdrop-filter: blur(20px) saturate(180%) !important;
       border: 1px solid rgba(255, 255, 255, 0.3) !important;
       transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1) !important;
     }
     
     .elegant-notification.notification-enter {
       transform: translate(-50%, -50%) scale(1) !important;
       opacity: 1 !important;
     }
     
     .elegant-notification.notification-exit {
       transform: translate(-50%, -50%) scale(0.95) !important;
       opacity: 0 !important;
       transition: all 0.2s ease-out !important;
     }
     
     .notification-content {
       padding: 20px 24px !important;
       text-align: center !important;
       flex-direction: column !important;
       align-items: center !important;
       gap: 12px !important;
     }
     
     .notification-icon {
       width: 64px !important;
       height: 64px !important;
       margin: 0 auto 16px !important;
       display: flex !important;
       align-items: center !important;
       justify-content: center !important;
       border-radius: 50% !important;
       font-size: 28px !important;
       box-shadow: 0 12px 24px rgba(0, 0, 0, 0.2) !important;
     }
     
     .notification-title {
       font-size: 20px !important;
       font-weight: 700 !important;
       margin-bottom: 10px !important;
       line-height: 1.3 !important;
       letter-spacing: -0.02em !important;
     }
     
     .notification-message {
       font-size: 16px !important;
       line-height: 1.5 !important;
       font-weight: 500 !important;
       opacity: 0.9 !important;
     }
   }
   
   @keyframes notificationSlideIn {
     0% {
       transform: translate(-50%, -50%) scale(0.9);
       opacity: 0;
     }
     100% {
       transform: translate(-50%, -50%) scale(1);
       opacity: 1;
     }
   }
   
   @keyframes notificationSlideOut {
     0% {
       transform: translate(-50%, -50%) scale(1);
       opacity: 1;
     }
     100% {
       transform: translate(-50%, -50%) scale(0.9);
       opacity: 0;
     }
   }
     
     .notification-icon {
       width: 36px;
       height: 36px;
       font-size: 16px;
     }
     
     .notification-title {
       font-size: 15px;
     }
     
     .notification-message {
       font-size: 13px;
     }
     
     /* Estilos espec√≠ficos para mobile */
     .mobile-focused {
       transform: scale(1.02);
       box-shadow: 0 0 0 2px #3b82f6;
       transition: all 0.2s ease;
     }
     
     /* Melhorar bot√µes para mobile */
     button {
       min-height: 44px !important;
       min-width: 44px !important;
       font-size: 16px !important;
       touch-action: manipulation;
     }
     
     /* Melhorar inputs para mobile */
     input, select, textarea {
       min-height: 44px !important;
       font-size: 16px !important;
       touch-action: manipulation;
     }
     
     /* Melhorar selects para mobile */
     select {
       background-size: 20px 20px;
       background-position: right 12px center;
       padding-right: 40px;
     }
     
     /* Indicador de status mobile */
     #mobile-status-indicator {
       position: fixed !important;
       top: 10px !important;
       right: 10px !important;
       width: 12px !important;
       height: 12px !important;
       border-radius: 50% !important;
       z-index: 9999 !important;
       transition: all 0.3s ease !important;
       box-shadow: 0 2px 4px rgba(0,0,0,0.2);
     }
     
     /* Melhorar formul√°rios para mobile */
     form {
       padding: 16px;
     }
     
     .form-group, .mb-3 {
       margin-bottom: 20px;
     }
     
     /* Melhorar dropdowns para mobile */
     .suggestions-overlay {
       position: fixed !important;
       top: 0 !important;
       left: 0 !important;
       right: 0 !important;
       bottom: 0 !important;
       background: rgba(0,0,0,0.5) !important;
       z-index: 1000 !important;
     }
     
     .suggestions-list {
       position: fixed !important;
       top: 50% !important;
       left: 16px !important;
       right: 16px !important;
       transform: translateY(-50%) !important;
       max-height: 60vh !important;
       overflow-y: auto !important;
       background: white !important;
       border-radius: 8px !important;
       box-shadow: 0 4px 12px rgba(0,0,0,0.3) !important;
     }
   }
   
   /* Anima√ß√£o de entrada mais suave */
   @keyframes slideInRight {
     from {
       transform: translateX(100%);
       opacity: 0;
     }
     to {
       transform: translateX(0);
       opacity: 1;
     }
   }
   
   @keyframes slideOutRight {
     from {
       transform: translateX(0);
       opacity: 1;
     }
     to {
       transform: translateX(100%);
       opacity: 0;
     }
   }
   </style>
   `;
   
   /* ===== ESTILOS CSS PARA AMPULHETA E ALERTAS PROFISSIONAIS ===== */
   const professionalAlertStyles = `
   <style>
   /* Estilos para alertas profissionais */
   .swal2-popup-professional {
     border-radius: 16px !important;
     box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15), 0 0 0 1px rgba(255, 255, 255, 0.2) !important;
     border: 1px solid rgba(255, 255, 255, 0.3) !important;
     backdrop-filter: blur(20px) !important;
     font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;
   }
   
   .swal2-title-professional {
     font-weight: 600 !important;
     font-size: 1.1rem !important;
     margin-bottom: 0.5rem !important;
   }
   
   .swal2-content-professional {
     font-size: 0.9rem !important;
     line-height: 1.5 !important;
   }
   
   .swal2-timer-progress-bar-professional {
     background: linear-gradient(90deg, #1e40af, #3b82f6) !important;
     border-radius: 0 0 16px 16px !important;
   }
   
   /* Estilos para loading com ampulheta */
   .swal2-popup-loading {
     border-radius: 20px !important;
     box-shadow: 0 25px 50px rgba(0, 0, 0, 0.2), 0 0 0 1px rgba(255, 255, 255, 0.3) !important;
     border: 1px solid rgba(255, 255, 255, 0.3) !important;
     backdrop-filter: blur(20px) !important;
     background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%) !important;
     font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;
     min-width: 320px !important;
     max-width: 400px !important;
   }
   
   .swal2-html-container-loading {
     padding: 2rem !important;
     text-align: center !important;
   }
   
   /* Container da ampulheta */
   .loading-container {
     display: flex;
     flex-direction: column;
     align-items: center;
     gap: 1rem;
   }
   
   /* Ampulheta animada */
   .hourglass {
     position: relative;
     width: 60px;
     height: 60px;
     margin: 0 auto;
   }
   
   .hourglass-top,
   .hourglass-bottom {
     position: absolute;
     width: 0;
     height: 0;
     border-left: 30px solid transparent;
     border-right: 30px solid transparent;
     animation: hourglass 2s ease-in-out infinite;
   }
   
   .hourglass-top {
     top: 0;
     border-top: 30px solid #1e40af;
     animation-delay: 0s;
   }
   
   .hourglass-bottom {
     bottom: 0;
     border-bottom: 30px solid #e5e7eb;
     animation-delay: 1s;
   }
   
   .sand {
     position: absolute;
     top: 50%;
     left: 50%;
     width: 4px;
     height: 4px;
     background: #1e40af;
     border-radius: 50%;
     transform: translate(-50%, -50%);
     animation: sand-fall 2s ease-in-out infinite;
   }
   
   /* Anima√ß√µes da ampulheta */
   @keyframes hourglass {
     0%, 50% {
       opacity: 1;
       transform: scale(1);
     }
     25%, 75% {
       opacity: 0.7;
       transform: scale(0.95);
     }
     100% {
       opacity: 1;
       transform: scale(1);
     }
   }
   
   @keyframes sand-fall {
     0% {
       top: 50%;
       opacity: 1;
       transform: translate(-50%, -50%) scale(1);
     }
     25% {
       top: 60%;
       opacity: 0.8;
       transform: translate(-50%, -50%) scale(0.8);
     }
     50% {
       top: 70%;
       opacity: 0.6;
       transform: translate(-50%, -50%) scale(0.6);
     }
     75% {
       top: 80%;
       opacity: 0.4;
       transform: translate(-50%, -50%) scale(0.4);
     }
     100% {
       top: 90%;
       opacity: 0;
       transform: translate(-50%, -50%) scale(0);
     }
   }
   
   /* Texto de loading */
   .loading-text h3 {
     font-weight: 600;
     color: #1e40af;
     margin: 1rem 0 0.5rem 0;
     font-size: 1.1rem;
   }
   
   .loading-text p {
     color: #6b7280;
     font-size: 0.9rem;
     margin: 0;
     line-height: 1.4;
   }
   
   /* Responsividade para mobile */
   @media (max-width: 640px) {
     .swal2-popup-loading {
       min-width: 280px !important;
       max-width: 320px !important;
       margin: 0 1rem !important;
     }
     
     /* Corre√ß√£o para toasts SweetAlert2 no mobile */
     .swal2-container-mobile {
       padding: 16px !important;
       position: fixed !important;
       top: 0 !important;
       left: 0 !important;
       right: 0 !important;
       bottom: auto !important;
       width: 100% !important;
       height: auto !important;
     }
     
     .swal2-popup-mobile {
       margin: 0 !important;
       width: 100% !important;
       max-width: none !important;
       position: relative !important;
     }
     
     .swal2-toast.swal2-show {
       margin: 0 0 8px 0 !important;
       position: relative !important;
       left: 0 !important;
       right: 0 !important;
       transform: none !important;
     }
     
     /* CENTRALIZAR toasts SweetAlert2 no CENTRO DA TELA */
     .swal2-container.swal2-top {
       top: 50% !important;
       left: 50% !important;
       right: auto !important;
       bottom: auto !important;
       transform: translate(-50%, -50%) !important;
       width: 90vw !important;
       max-width: 400px !important;
       padding: 0 !important;
       margin: 0 !important;
     }
     
     .swal2-container.swal2-top .swal2-popup {
       margin: 0 !important;
       width: 100% !important;
       max-width: none !important;
       position: relative !important;
     }
     
     /* For√ßar centraliza√ß√£o absoluta */
     .swal2-container {
       display: flex !important;
       align-items: center !important;
       justify-content: center !important;
     }
   }
     
     .hourglass {
       width: 50px;
       height: 50px;
     }
     
     .hourglass-top,
     .hourglass-bottom {
       border-left-width: 25px;
       border-right-width: 25px;
     }
     
     .hourglass-top {
       border-top-width: 25px;
     }
     
     .hourglass-bottom {
       border-bottom-width: 25px;
     }
     
     .loading-text h3 {
       font-size: 1rem;
     }
     
     .loading-text p {
       font-size: 0.85rem;
     }
   }
   
   /* Efeito de brilho sutil na ampulheta */
   .hourglass::before {
     content: '';
     position: absolute;
     top: -5px;
     left: -5px;
     right: -5px;
     bottom: -5px;
     background: linear-gradient(45deg, transparent, rgba(30, 64, 175, 0.1), transparent);
     border-radius: 50%;
     animation: glow 3s ease-in-out infinite;
     z-index: -1;
   }
   
   @keyframes glow {
     0%, 100% {
       opacity: 0;
       transform: scale(1);
     }
     50% {
       opacity: 1;
       transform: scale(1.1);
     }
   }
   </style>
   `;
   
   // Injeta os estilos elegantes
   if (!document.getElementById('elegant-notification-styles')) {
     const styleElement = document.createElement('div');
     styleElement.id = 'elegant-notification-styles';
     styleElement.innerHTML = elegantNotificationStyles;
     document.head.appendChild(styleElement);
   }
   
   // Injeta os estilos profissionais
   if (!document.getElementById('professional-alert-styles')) {
     const styleElement = document.createElement('div');
     styleElement.id = 'professional-alert-styles';
     styleElement.innerHTML = professionalAlertStyles;
     document.head.appendChild(styleElement);
   }
   
   /* ===== ESTILOS PARA MODAL - CORES UNIFORMES ===== */
   const modalStyles = `
   <style>
   /* Estilos para o modal - cores uniformes */
   #modalNovaComum .modal-content {
     background: var(--card) !important;
     border: 1px solid var(--border) !important;
     color: var(--ink) !important;
   }
   
  #modalNovaComum .modal-header {
    background: var(--card) !important;
    border-bottom: 1px solid var(--border) !important;
    color: var(--ink) !important;
    text-align: center !important;
  }
   
   #modalNovaComum .modal-body {
     background: var(--card) !important;
     color: var(--ink) !important;
   }
   
  #modalNovaComum .modal-footer {
    background: var(--card) !important;
    border-top: 1px solid var(--border) !important;
    display: flex !important;
    justify-content: center !important;
    align-items: center !important;
    gap: 15px !important;
    padding: 20px 15px !important;
    text-align: center !important;
  }
  
  /* CSS espec√≠fico para mobile */
  @media (max-width: 768px) {
    #modalNovaComum .modal-footer {
      display: flex !important;
      justify-content: center !important;
      align-items: center !important;
      gap: 15px !important;
      padding: 20px 15px !important;
      text-align: center !important;
    }
    
    #modalNovaComum .modal-footer .btn {
      flex: 0 0 auto !important;
      min-width: 130px !important;
      margin: 0 !important;
      display: inline-flex !important;
      align-items: center !important;
      justify-content: center !important;
    }
  }
   
   /* Campos do modal - cores uniformes */
   #modalNovaComum input,
   #modalNovaComum select,
   #modalNovaComum textarea {
     background: var(--card) !important;
     border: 1px solid var(--border) !important;
     color: var(--ink) !important;
   }
   
   #modalNovaComum input:focus,
   #modalNovaComum select:focus,
   #modalNovaComum textarea:focus {
     background: var(--card) !important;
     border-color: var(--primary) !important;
     color: var(--ink) !important;
     box-shadow: 0 0 0 0.2rem rgba(var(--primary-rgb), 0.25) !important;
   }
   
   /* Labels do modal */
   #modalNovaComum label {
     color: var(--ink) !important;
   }
   
   /* Bot√µes do modal */
   #modalNovaComum .btn {
     padding: 6px 12px !important;
     font-size: 12px !important;
     font-weight: 600 !important;
     text-transform: uppercase !important;
     border-radius: 3px !important;
     min-height: auto !important;
     width: auto !important;
     min-width: auto !important;
     max-width: 140px !important;
     display: inline-flex !important;
     align-items: center !important;
     justify-content: center !important;
     gap: 4px !important;
   }
   
   #modalNovaComum .btn:hover {
     transform: translateY(-1px) !important;
     box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15) !important;
   }
   
   #modalNovaComum .btn:focus {
     outline: none !important;
     box-shadow: 0 0 0 2px rgba(26, 179, 148, 0.25) !important;
   }
   
   #modalNovaComum .btn-secondary,
   #modalNovaComum .btn-white {
     background: #f5f5f5 !important;
     border: 1px solid #e5e5e5 !important;
     color: #676a6c !important;
   }
   
   #modalNovaComum .btn-secondary:hover,
   #modalNovaComum .btn-white:hover {
     background: #e8e8e8 !important;
     border-color: #d5d5d5 !important;
     color: #555 !important;
   }
   
   /* Bot√£o Enviar espec√≠fico - verde Inspinia */
   #modalNovaComum #btnSalvarGS,
   #modalNovaComum .btn-primary {
     background: #1ab394 !important;
     border: 1px solid #1ab394 !important;
     color: white !important;
   }
   
   #modalNovaComum #btnSalvarGS:hover,
   #modalNovaComum .btn-primary:hover {
     background: #18a085 !important;
     border-color: #18a085 !important;
     color: white !important;
   }
   
   #modalNovaComum #btnSalvarGS:focus,
   #modalNovaComum .btn-primary:focus {
     background: #1ab394 !important;
     border-color: #1ab394 !important;
     box-shadow: 0 0 0 2px rgba(26, 179, 148, 0.25) !important;
   }
   
   #modalNovaComum #btnSalvarGS:active,
   #modalNovaComum .btn-primary:active {
     background: #15967a !important;
     border-color: #15967a !important;
   }
   
  /* T√≠tulo do modal */
  #modalNovaComum .modal-title {
    color: var(--ink) !important;
    text-align: center !important;
  }
   
  /* √çcone do modal */
  #modalNovaComum .modal-icon {
    font-size: 84px !important;
    color: #e2e3e3 !important;
    display: block !important;
    margin-bottom: 10px !important;
  }
  
  /* Subt√≠tulo do modal */
  #modalNovaComum .modal-header .font-bold {
    text-align: center !important;
  }
   
   /* √çcones dos bot√µes do modal */
   #modalNovaComum .btn i {
     font-size: 11px !important;
     margin-right: 0 !important;
     display: inline-block !important;
     visibility: visible !important;
     opacity: 1 !important;
     background: transparent !important;
     border: none !important;
     padding: 0 !important;
     width: auto !important;
     height: auto !important;
   }
   
   /* Cor espec√≠fica do √≠cone do bot√£o fechar */
   #modalNovaComum .btn-white i {
     color: #676a6c !important;
     background: transparent !important;
   }
   
   /* Cor espec√≠fica do √≠cone do bot√£o salvar */
   #modalNovaComum .btn-primary i {
     color: white !important;
     background: transparent !important;
   }
   
   /* Bot√£o principal de envio */
   #btnSubmit {
     padding: 8px 16px !important;
     font-size: 12px !important;
     font-weight: 600 !important;
     text-transform: uppercase !important;
     border-radius: 3px !important;
     min-height: auto !important;
     width: auto !important;
     min-width: 180px !important;
     max-width: 200px !important;
     display: inline-flex !important;
     align-items: center !important;
     justify-content: center !important;
     gap: 6px !important;
     background: #1ab394 !important;
     border: 1px solid #1ab394 !important;
     color: white !important;
     margin: 0 auto !important;
   }
   
   #btnSubmit:hover {
     background: #18a085 !important;
     border-color: #18a085 !important;
     transform: translateY(-1px) !important;
     box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15) !important;
   }
   
   #btnSubmit:focus {
     background: #1ab394 !important;
     border-color: #1ab394 !important;
     box-shadow: 0 0 0 2px rgba(26, 179, 148, 0.25) !important;
   }
   
   #btnSubmit i {
     font-size: 12px !important;
     margin-right: 0 !important;
     display: inline-block !important;
     visibility: visible !important;
     opacity: 1 !important;
   }
   
   /* Centralizar bot√£o na action-bar */
   .action-bar {
     display: flex !important;
     flex-direction: column !important;
     align-items: center !important;
     text-align: center !important;
   }
   
   /* Ajustar cores do queue-badge para tema Inspinia */
   .queue-badge {
     padding: 4px 8px !important;
     font-size: 11px !important;
     font-weight: 600 !important;
     text-transform: uppercase !important;
     border-radius: 3px !important;
     display: inline-flex !important;
     align-items: center !important;
     gap: 4px !important;
   }
   
   .queue-badge.empty {
     background: #f5f5f5 !important;
     color: #676a6c !important;
     border: 1px solid #e5e5e5 !important;
   }
   
  .queue-badge.pending {
    background: #f0ad4e !important;
    color: white !important;
    border: 1px solid #f0ad4e !important;
  }
   
   .queue-badge.syncing {
     background: #18a085 !important;
     color: white !important;
     border: 1px solid #18a085 !important;
   }
   
   /* Bot√£o de fechar */
   #modalNovaComum .btn-close {
     filter: invert(1) !important;
   }
   
   /* Dropdown do modal */
   #modalNovaComum .dropdown-menu {
     background: var(--card) !important;
     border: 1px solid var(--border) !important;
   }
   
   #modalNovaComum .dropdown-item {
     color: var(--ink) !important;
   }
   
   #modalNovaComum .dropdown-item:hover {
     background: var(--hover) !important;
     color: var(--ink) !important;
   }
   
   /* Form groups */
   #modalNovaComum .form-group {
     margin-bottom: 1rem;
   }
   
   /* Texto de ajuda */
   #modalNovaComum .form-text {
     color: var(--muted) !important;
   }
   
   /* Valida√ß√£o */
   #modalNovaComum .is-invalid {
     border-color: var(--danger) !important;
   }
   
   #modalNovaComum .invalid-feedback {
     color: var(--danger) !important;
   }
   
   #modalNovaComum .is-valid {
     border-color: var(--success) !important;
   }
   
   #modalNovaComum .valid-feedback {
     color: var(--success) !important;
   }
   </style>
   `;
   
   // Injeta os estilos do modal
   if (!document.getElementById('modal-styles')) {
     const modalStyleElement = document.createElement('div');
     modalStyleElement.id = 'modal-styles';
     modalStyleElement.innerHTML = modalStyles;
     document.head.appendChild(modalStyleElement);
   }
   
   /* ===== MODO ESCURO ===== */
   function initTheme() {
     let savedTheme = localStorage.getItem('theme') || 'light';
     
     const themeToggle = document.getElementById('themeToggle');
     const themeIcon = document.getElementById('themeIcon');
     
     function setTheme(theme) {
       document.documentElement.setAttribute('data-theme', theme);
       
       // Chrome iOS: tentar salvar no localStorage com fallback
       try {
         localStorage.setItem('theme', theme);
       } catch (e) {
         console.warn('‚ö†Ô∏è Chrome iOS: N√£o foi poss√≠vel salvar tema no localStorage');
       }
       
       if (themeIcon) {
         themeIcon.className = theme === 'dark' ? 'fa-solid fa-sun' : 'fa-solid fa-moon';
       }
     }
     
     setTheme(savedTheme);
     
     if (themeToggle) {
       themeToggle.addEventListener('click', () => {
         const currentTheme = document.documentElement.getAttribute('data-theme');
         const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
         setTheme(newTheme);
         showToast('info', 'Tema alterado', `Modo ${newTheme === 'dark' ? 'escuro' : 'claro'} ativado`, 2000);
       });
     }
   }
   
  // CORRE√á√ÉO: Fun√ß√£o duplicada removida - usando a primeira defini√ß√£o
   function findInstrumentField() {
     const element = document.querySelector('#instrumento');
     console.log('üîç DEBUG - findInstrumentField():', { 
       element: element, 
       value: element?.value, 
       tagName: element?.tagName,
       id: element?.id 
     });
     return element;
   }
   function findCargoField() {
     const element = document.querySelector('#cargo');
     console.log('üîç DEBUG - findCargoField():', { 
       element: element, 
       value: element?.value, 
       tagName: element?.tagName,
       id: element?.id 
     });
     return element;
   }
   function findNomeField() {
     const element = document.querySelector('#nome');
     console.log('üîç DEBUG - findNomeField():', { 
       element: element, 
       value: element?.value, 
       tagName: element?.tagName,
       id: element?.id 
     });
     return element;
   }
   function getSubmitButton() {
     const all = Array.from(document.querySelectorAll('button'));
     const byText = all.find(b => /enviar/i.test((b.textContent || '').trim()));
     if (byText) return byText;
     return document.querySelector('#btnEnviar, button[type="submit"], button[type="button"]');
   }
   
   
   /* ===== CACHE OFFLINE ===== */
   const CACHE_KEYS = {
     COMUNS: 'cache_comuns',
     INSTRUMENTOS: 'cache_instrumentos',
     CARGOS: 'cache_cargos',
     NOMES: 'cache_nomes',
     LAST_UPDATE: 'cache_last_update'
   };
   
   function getCacheKey(key, params = {}) {
     // Cria uma chave mais espec√≠fica e limpa
     const cleanParams = {};
     if (params.comumVal) cleanParams.comum = params.comumVal.toLowerCase().replace(/\s+/g, '_');
     if (params.instVal) cleanParams.inst = params.instVal.toLowerCase().replace(/\s+/g, '_');
     if (params.cargoVal) cleanParams.cargo = params.cargoVal.toLowerCase().replace(/\s+/g, '_');
     
     return `${key}_${JSON.stringify(cleanParams)}`;
   }
   
   function setCache(key, data, ttl = 24 * 60 * 60 * 1000) {
     const cacheData = {
       data,
       timestamp: Date.now(),
       ttl
     };
     localStorage.setItem(key, JSON.stringify(cacheData));
   }
   
   function getCache(key) {
     try {
       const cached = localStorage.getItem(key);
       if (!cached) return null;
       
       const { data, timestamp, ttl } = JSON.parse(cached);
       const now = Date.now();
       
       if (now - timestamp > ttl) {
         localStorage.removeItem(key);
         return null;
       }
       
       return data;
     } catch (e) {
       localStorage.removeItem(key);
       return null;
     }
   }
   
   function clearCache() {
     Object.values(CACHE_KEYS).forEach(key => {
       localStorage.removeItem(key);
     });
     Object.keys(localStorage).forEach(key => {
       if (key.startsWith('cache_')) {
         localStorage.removeItem(key);
       }
     });
   }
   
   /* ===== INDICADOR DE CONEX√ÉO ===== */
   function setStatus(ok, msg){
     const statusIcon = document.getElementById('statusIcon');
     const statusText = document.getElementById('statusText');
     const connectionStatus = document.getElementById('connectionStatus');
     
     if (statusIcon && statusText && connectionStatus) {
       if (ok) {
         statusIcon.className = 'fa-solid fa-wifi status-icon online';
         statusText.textContent = 'Online';
         connectionStatus.className = 'connection-status online';
         connectionStatus.title = 'Conectado ao Supabase';
       } else {
         statusIcon.className = 'fa-solid fa-wifi-slash status-icon offline';
         statusText.textContent = 'Offline';
         connectionStatus.className = 'connection-status offline';
         connectionStatus.title = 'Sem conex√£o - Modo offline';
       }
     }
   }
   
   // üöÄ FUN√á√ÉO EST√ÅVEL: Verifica√ß√£o de conectividade robusta e confi√°vel
   // üöÄ OTIMIZA√á√ÉO: Cache de resultados para evitar verifica√ß√µes repetidas
   let lastSupabaseCheck = 0;
   let cachedSupabaseResult = null;
   const SUPABASE_CACHE_DURATION = 2000; // 2 segundos de cache
   
   async function checkSupabaseConnection(){
     try {
       // üöÄ OTIMIZA√á√ÉO: Usar cache se a verifica√ß√£o foi feita recentemente
       const now = Date.now();
       if (cachedSupabaseResult !== null && (now - lastSupabaseCheck) < SUPABASE_CACHE_DURATION) {
         return cachedSupabaseResult;
       }
       
       // Verifica√ß√£o b√°sica do navegador (r√°pida)
       if (!navigator.onLine) {
         console.log('üì¥ Navegador reporta offline');
         setStatus(false, 'Offline');
         cachedSupabaseResult = false;
         lastSupabaseCheck = now;
         return false;
       }
       
      // üö® CORRE√á√ÉO: Timeout aumentado para 8 segundos (era 2s - muito curto quebrava a l√≥gica)
      const timeout = 8000; // 8 segundos (timeout muito curto cancelava requisi√ß√µes)
       
       // M√âTODO 1: Teste de conectividade b√°sica (compat√≠vel com file://)
       try {
         // Se estiver em file://, usar teste diferente
         if (window.location.protocol === 'file:') {
           console.log('üìÅ Protocolo file:// detectado - usando teste b√°sico');
           // Para file://, apenas verificar se o navegador est√° online
           if (navigator.onLine) {
             console.log('‚úÖ Navegador online (file://)');
             setStatus(true, 'Online (Local)');
             return true;
           } else {
             console.log('üì¥ Navegador offline (file://)');
             setStatus(false, 'Offline');
             return false;
           }
         }
         
         // Para http/https, tentar ping.json (com compatibilidade total)
         const pingResponse = await fetchWithTimeout('./ping.json', {
           method: 'HEAD',
           cache: 'no-cache'
         }, 3000);
         
         if (!pingResponse.ok) {
           console.log('üì¥ Teste de ping falhou');
           setStatus(false, 'Offline');
           return false;
         }
         
         console.log('‚úÖ Conectividade b√°sica confirmada');
         // üöÄ OTIMIZA√á√ÉO: Cachear resultado positivo
         cachedSupabaseResult = true;
         lastSupabaseCheck = Date.now();
         setStatus(true, 'Online');
         return true;
       } catch (pingError) {
         // üöÄ OTIMIZA√á√ÉO: Se falhar o ping, mas o navegador est√° online, assumir online (mais r√°pido)
         if (navigator.onLine) {
           console.log('‚ö†Ô∏è Ping falhou, mas navegador online - assumindo conectividade');
           // üöÄ OTIMIZA√á√ÉO: Cachear resultado positivo
           cachedConnectivityResult = true;
           lastConnectivityCheck = Date.now();
           setStatus(true, 'Online (B√°sico)');
           return true;
         }
         console.log('üì¥ Teste de ping falhou:', pingError.message);
         // üöÄ OTIMIZA√á√ÉO: Cachear resultado negativo se navegador offline
         cachedSupabaseResult = false;
         lastSupabaseCheck = Date.now();
         setStatus(false, 'Offline');
         return false;
       }
       
       // M√âTODO 2: Teste do Supabase (se dispon√≠vel e habilitado)
       const supabaseDisabled = localStorage.getItem('supabase_disabled') === 'true';
       
       if (!supabaseDisabled && supabaseLoaded && sb) {
         try {
           const controller = new AbortController();
           const timeoutId = setTimeout(() => controller.abort(), timeout);
           
           const { error } = await sb.from(TABLE_PRESENCAS).select('uuid').limit(1);
           clearTimeout(timeoutId);
           
           if (!error) {
             console.log('‚úÖ Supabase conectado');
             // üöÄ OTIMIZA√á√ÉO: Cachear resultado positivo
             cachedConnectivityResult = true;
             lastConnectivityCheck = Date.now();
             setStatus(true, 'Online');
             return true;
           } else {
             console.log('‚ö†Ô∏è Supabase com erro, mas conectividade b√°sica OK');
             // üöÄ OTIMIZA√á√ÉO: Cachear resultado positivo
             cachedConnectivityResult = true;
             lastConnectivityCheck = Date.now();
             setStatus(true, 'Online (B√°sico)');
             return true; // Retorna true mesmo com erro do Supabase
           }
         } catch (e) {
           console.log('‚ö†Ô∏è Erro no Supabase, mas conectividade b√°sica OK:', e.message);
           // üöÄ OTIMIZA√á√ÉO: Cachear resultado positivo
           cachedConnectivityResult = true;
           lastConnectivityCheck = Date.now();
           setStatus(true, 'Online (B√°sico)');
           return true; // Retorna true mesmo com erro do Supabase
         }
       } else if (supabaseDisabled) {
         console.log('‚ÑπÔ∏è Supabase desabilitado - usando apenas conectividade b√°sica');
       }
       
       // Se chegou at√© aqui, conectividade b√°sica est√° OK
       console.log('‚úÖ Conectividade b√°sica confirmada - sistema online');
       // üöÄ OTIMIZA√á√ÉO: Cachear resultado positivo
       cachedConnectivityResult = true;
       lastConnectivityCheck = Date.now();
       setStatus(true, 'Online');
       return true;
       
     } catch (e) {
       console.log('‚ùå Erro geral na verifica√ß√£o de conectividade:', e.message);
       
       // Em caso de erro, verificar se pelo menos o navegador est√° online
       if (navigator.onLine) {
         console.log('‚ö†Ô∏è Erro na verifica√ß√£o, mas navegador reporta online');
         // üöÄ OTIMIZA√á√ÉO: Cachear resultado positivo
         cachedSupabaseResult = true;
         lastSupabaseCheck = Date.now();
         setStatus(true, 'Online (Verifica√ß√£o)');
         return true;
       } else {
         setStatus(false, 'Offline');
         return false;
       }
     }
   }
   
   // Fun√ß√£o para testar conectividade real com timeout
   async function testRealConnectivity() {
     try {
       // Testa com um endpoint simples e r√°pido
       const controller = new AbortController();
       const timeoutId = setTimeout(() => controller.abort(), 10000); // üö® CORRE√á√ÉO: Timeout aumentado para 10 segundos (era 3s - muito curto)
       
       const response = await fetch('https://www.google.com/favicon.ico', {
         method: 'HEAD',
         mode: 'no-cors',
         signal: controller.signal,
         cache: 'no-cache'
       });
       
       clearTimeout(timeoutId);
       console.log('‚úÖ Conectividade real confirmada');
       return true;
       
     } catch (error) {
       console.log('‚ùå Sem conectividade real:', error.message);
       return false;
     }
   }
   
   /* ===== CARREGAR COMUNS (do cat√°logo) ===== */
   async function loadComunsFromCatalog(){
     // üöÄ OTIMIZA√á√ÉO: Log reduzido para melhor performance
     
     const input = findComumField();
     if (!input) {
       console.error('‚ùå Campo de comum n√£o encontrado');
       return;
     }
   
     // üö® CORRE√á√ÉO CR√çTICA: Verificar offline ANTES de qualquer coisa
     // Isso garante que o cache seja usado imediatamente quando a internet cai
     const isOfflineNow = !navigator.onLine;
     
     if (isOfflineNow) {
       console.log('üìµ Internet caiu - carregando comuns do cache imediatamente');
       
       // Tenta carregar do cache primeiro
       const cachedComuns = getCache(CACHE_KEYS.COMUNS);
       if (cachedComuns && cachedComuns.length > 0) {
         console.log(`‚úÖ ${cachedComuns.length} comuns carregadas do cache`);
         if (cachedComuns.length < 179) {
           console.warn(`‚ö†Ô∏è ATEN√á√ÉO: Cache tem apenas ${cachedComuns.length} comuns (esperado: 179)`);
         } else {
           console.log(`‚úÖ Cache completo: ${cachedComuns.length} comuns (esperado: 179)`);
         }
         populateComunsInput(input, cachedComuns);
         return;
       }
       
       // Dados padr√£o como √∫ltimo recurso
       console.log('‚ö†Ô∏è Cache vazio - usando lista padr√£o de comuns');
       const defaultComuns = [
         'Apache', 'Aguassa√≠', 'Caucaia do Alto', 'Cotia', 'Itapevi', 'Jandira', 
         'Vargem Grande Paulista', 'Fazendinha', 'Pirapora', 'Jardim Miranda',
         'Vila S√£o Francisco', 'Granja Viana', 'Embu das Artes', 'Tabo√£o da Serra',
         'Central', 'Alphaville', 'Alto da Colina', 'Alto do Bela Vista', 'Alto do Paulista'
       ];
       populateComunsInput(input, defaultComuns);
       return;
     }
     
     // Aguarda um pouco para o Supabase carregar antes de assumir offline
     if (!supabaseLoaded && navigator.onLine) {
       console.log('üìö Aguardando Supabase carregar...');
       await new Promise(resolve => setTimeout(resolve, 2000)); // Aguarda 2 segundos
     }
   
     // Verifica se Supabase n√£o est√° dispon√≠vel (mas internet pode estar)
     const isSupabaseUnavailable = !supabaseLoaded || !sb || typeof sb.from !== 'function';
     
     if (isSupabaseUnavailable) {
       console.log('üìµ Supabase indispon√≠vel - carregando comuns do cache');
       
       // Tenta carregar do cache primeiro
       const cachedComuns = getCache(CACHE_KEYS.COMUNS);
       if (cachedComuns && cachedComuns.length > 0) {
         console.log(`‚úÖ ${cachedComuns.length} comuns carregadas do cache (Supabase indispon√≠vel)`);
         populateComunsInput(input, cachedComuns);
         return;
       }
       
       // Dados padr√£o como √∫ltimo recurso
       console.log('‚ö†Ô∏è Cache vazio - usando lista padr√£o de comuns');
       const defaultComuns = [
         'Apache', 'Aguassa√≠', 'Caucaia do Alto', 'Cotia', 'Itapevi', 'Jandira', 
         'Vargem Grande Paulista', 'Fazendinha', 'Pirapora', 'Jardim Miranda',
         'Vila S√£o Francisco', 'Granja Viana', 'Embu das Artes', 'Tabo√£o da Serra',
         'Central', 'Alphaville', 'Alto da Colina', 'Alto do Bela Vista', 'Alto do Paulista'
       ];
       populateComunsInput(input, defaultComuns);
       return;
     }
   
     try {
       // Sempre tenta carregar do Supabase primeiro
       console.log('üìö Tentando carregar comuns do Supabase...');
       console.log('üìö TABLE_CATALOGO:', TABLE_CATALOGO);
       console.log('üìö COL_COMUM:', COL_COMUM);
       
       // üö® CORRE√á√ÉO CR√çTICA: Buscar TODOS os registros com pagina√ß√£o para garantir 183 comuns
       // O Supabase retorna apenas 1000 registros por padr√£o - precisamos paginar para buscar todos
       // üöÄ OTIMIZA√á√ÉO: Sempre tentar buscar do Supabase quando online para atualizar cache
       
       let allComunsData = [];
       let hasMore = true;
       let currentPage = 0;
       const pageSize = 1000; // Supabase permite at√© 1000 por p√°gina
       let finalError = null;
       
       while (hasMore) {
         const from = currentPage * pageSize;
         const to = from + pageSize - 1;
         
         try {
           
           const { data: pageData, error: pageError } = await sb
             .from(TABLE_CATALOGO)
             .select(COL_COMUM)
             .eq('ativo', true) // Apenas registros ativos
             .not(COL_COMUM, 'is', null) // Excluir NULLs
             .neq(COL_COMUM, '') // Excluir strings vazias
             .order(COL_COMUM, { ascending: true })
             .range(from, to);
           
           // üö® CORRE√á√ÉO CR√çTICA PRODU√á√ÉO: Logs detalhados do resultado
           if (pageError) {
             console.error('‚ùå Erro ao buscar p√°gina:', pageError);
             console.error('‚ùå C√≥digo do erro:', pageError.code);
             console.error('‚ùå Mensagem do erro:', pageError.message);
             console.error('‚ùå Detalhes do erro:', pageError.details);
             console.error('‚ùå Hint do erro:', pageError.hint);
             finalError = pageError;
             // Se for a primeira p√°gina, tentar fallback sem filtros
             if (currentPage === 0) {
               console.log('üîÑ Tentando fallback sem filtros...');
               try {
                 const { data: fallbackData, error: fallbackError } = await sb
                   .from(TABLE_CATALOGO)
                   .select(COL_COMUM);
                 if (!fallbackError && fallbackData) {
                   console.log(`‚úÖ Fallback retornou ${fallbackData.length} registros`);
                   allComunsData = fallbackData;
                   finalError = null;
                   break;
                 } else if (fallbackError) {
                   console.error('‚ùå Fallback tamb√©m falhou:', fallbackError);
                 } else {
                   console.warn('‚ö†Ô∏è Fallback retornou dados vazios');
                 }
               } catch (fallbackErr) {
                 console.error('‚ùå Fallback tamb√©m falhou:', fallbackErr);
               }
             }
             break;
           }
           
           // üö® CORRE√á√ÉO CR√çTICA PRODU√á√ÉO: Log quando n√£o h√° dados
           if (!pageData || pageData.length === 0) {
             console.warn(`‚ö†Ô∏è P√°gina ${currentPage + 1} retornou 0 registros`);
             hasMore = false;
             break;
           }
           
           if (pageData && pageData.length > 0) {
             allComunsData = allComunsData.concat(pageData);
             // üöÄ OTIMIZA√á√ÉO MOBILE: Log apenas se n√£o for mobile
             if (!isMobile) {
               console.log(`‚úÖ P√°gina ${currentPage + 1}: ${pageData.length} registros (total: ${allComunsData.length})`);
             }
             
             // Verifica se h√° mais registros
             hasMore = pageData.length === pageSize;
             currentPage++;
             
             // üöÄ OTIMIZA√á√ÉO MOBILE: Delay reduzido para mobile (100ms vs 200ms)
             if (hasMore) {
               await new Promise(resolve => setTimeout(resolve, isMobile ? 100 : 200));
             }
           } else {
             hasMore = false;
           }
         } catch (error) {
           console.error('‚ùå Erro na requisi√ß√£o de pagina√ß√£o:', error);
           finalError = error;
           
           // üö® CORRE√á√ÉO CR√çTICA: Se houver erro de rede, verificar cache imediatamente
           if (error.message && (error.message.includes('Failed to fetch') || error.message.includes('NetworkError') || !navigator.onLine)) {
             console.log('üìµ Erro de rede detectado - verificando cache...');
             const cachedComuns = getCache(CACHE_KEYS.COMUNS);
             if (cachedComuns && cachedComuns.length > 0) {
               console.log(`‚úÖ ${cachedComuns.length} comuns carregadas do cache (erro de rede)`);
               populateComunsInput(input, cachedComuns);
               return;
             }
           }
           
           if (currentPage === 0) {
             // Tentar fallback sem filtros
             try {
               const { data: fallbackData, error: fallbackError } = await sb
                 .from(TABLE_CATALOGO)
                 .select(COL_COMUM);
               if (!fallbackError && fallbackData) {
                 allComunsData = fallbackData;
                 finalError = null;
               } else if (fallbackError) {
                 // Se fallback tamb√©m falhar, verificar cache
                 const cachedComuns = getCache(CACHE_KEYS.COMUNS);
                 if (cachedComuns && cachedComuns.length > 0) {
                   console.log(`‚úÖ ${cachedComuns.length} comuns carregadas do cache (fallback falhou)`);
                   populateComunsInput(input, cachedComuns);
                   return;
                 }
               }
             } catch (fallbackErr) {
               console.error('‚ùå Fallback tamb√©m falhou:', fallbackErr);
               // Verificar cache ap√≥s fallback falhar
               const cachedComuns = getCache(CACHE_KEYS.COMUNS);
               if (cachedComuns && cachedComuns.length > 0) {
                 console.log(`‚úÖ ${cachedComuns.length} comuns carregadas do cache (fallback exception)`);
                 populateComunsInput(input, cachedComuns);
                 return;
               }
             }
           }
           break;
         }
       }
       
       // üöÄ OTIMIZA√á√ÉO MOBILE: Log apenas se n√£o for mobile
       console.log(`‚úÖ Total de registros buscados (com pagina√ß√£o): ${allComunsData.length}`);
       console.log(`‚úÖ Total de p√°ginas processadas: ${currentPage}`);
       
       // Usa os dados paginados
       const finalData = allComunsData;
       
       // üö® VALIDA√á√ÉO: Verificar se buscou registros suficientes
       if (finalData.length < 1000) {
         console.warn(`‚ö†Ô∏è ATEN√á√ÉO: Apenas ${finalData.length} registros foram buscados. Pode haver mais registros no banco.`);
       }
       
       // Verificar se ainda h√° erro ap√≥s fallback
       if (finalError && finalData.length === 0) { 
         console.error('‚ùå Erro ao carregar comuns do Supabase:', finalError); 
         console.log('üìµ Verificando cache devido ao erro...');
         
         // üö® CORRE√á√ÉO CR√çTICA: Sempre verificar cache quando houver erro
         const cachedComuns = getCache(CACHE_KEYS.COMUNS);
         if (cachedComuns && cachedComuns.length > 0) {
           console.log(`‚úÖ ${cachedComuns.length} comuns carregadas do cache (erro final)`);
           populateComunsInput(input, cachedComuns);
           showToast('warning', 'Erro de conex√£o', 'Usando dados em cache', 3000);
           return;
         }
         
         // Se n√£o houver cache, usar dados padr√£o
         console.log('‚ö†Ô∏è Cache vazio - usando lista padr√£o de comuns');
         const defaultComuns = [
           'Apache', 'Aguassa√≠', 'Caucaia do Alto', 'Cotia', 'Itapevi', 'Jandira', 
           'Vargem Grande Paulista', 'Fazendinha', 'Pirapora', 'Jardim Miranda',
           'Vila S√£o Francisco', 'Granja Viana', 'Embu das Artes', 'Tabo√£o da Serra',
           'Central', 'Alphaville', 'Alto da Colina', 'Alto do Bela Vista', 'Alto do Paulista'
         ];
         populateComunsInput(input, defaultComuns);
         showToast('error', 'Erro ao carregar', 'Usando lista padr√£o de comuns', 3000);
         return; 
       }
   
       // üö® CORRE√á√ÉO: Logs de debug removidos para n√£o atrasar carregamento
       // Processa os dados para obter apenas valores √∫nicos de comum
       const rawComuns = (finalData||[]).map(r => r[COL_COMUM]).filter(Boolean);
       
       // üö® CORRE√á√ÉO CR√çTICA: Usar Set para garantir que TODAS as comuns sejam preservadas
       // N√£o usar normaliza√ß√£o agressiva que pode fazer comuns diferentes serem tratadas como iguais
       const comunsSet = new Set();
       
       (finalData || []).forEach(r => {
         const comumOriginal = r[COL_COMUM];
         
         // Pula apenas se realmente n√£o houver valor ou se n√£o for string
         if (!comumOriginal || typeof comumOriginal !== 'string') return;
         
         const comumTrimmed = comumOriginal.trim();
         if (!comumTrimmed) return; // Pula apenas se ap√≥s trim estiver vazio
         
         // üö® CORRE√á√ÉO: Adiciona diretamente ao Set usando o valor original (case-sensitive)
         // Isso garante que comuns com diferen√ßas de mai√∫sculas/min√∫sculas sejam preservadas
         // Mas vamos normalizar para mai√∫scula para consist√™ncia
         const comumNormalizado = comumTrimmed.toUpperCase();
         comunsSet.add(comumNormalizado);
       });
       
       console.log(`üìö Comuns √∫nicas encontradas (Set): ${comunsSet.size}`);
       
       // Se o Set tiver menos que o esperado, tentar uma abordagem mais permissiva
       if (comunsSet.size < 179) {
         console.warn(`‚ö†Ô∏è Set tem apenas ${comunsSet.size} comuns, tentando abordagem alternativa...`);
         
         // Tentar sem normaliza√ß√£o para mai√∫scula (preservar case original)
         const comunsSetOriginal = new Set();
         (finalData || []).forEach(r => {
           const comumOriginal = r[COL_COMUM];
           if (!comumOriginal || typeof comumOriginal !== 'string') return;
           const comumTrimmed = comumOriginal.trim();
           if (comumTrimmed) {
             comunsSetOriginal.add(comumTrimmed);
           }
         });
         
         console.log(`üìö Comuns √∫nicas (preservando case original): ${comunsSetOriginal.size}`);
         
         // Usar o que tiver mais comuns
         if (comunsSetOriginal.size > comunsSet.size) {
           console.log(`‚úÖ Usando comuns com case original (${comunsSetOriginal.size} comuns)`);
           const valoresOriginal = Array.from(comunsSetOriginal)
             .map(s => s.toUpperCase())
             .sort((a,b)=>a.localeCompare(b,'pt-BR'));
           var valores = valoresOriginal;
         } else {
           var valores = Array.from(comunsSet)
             .sort((a,b)=>a.localeCompare(b,'pt-BR'));
         }
       } else {
         var valores = Array.from(comunsSet)
           .sort((a,b)=>a.localeCompare(b,'pt-BR'));
       }
       
       // üö® CORRE√á√ÉO CR√çTICA: Validar se todas as comuns foram encontradas
       console.log(`üìö Total de comuns √∫nicas encontradas: ${valores.length}`);
       console.log(`üìö Total de registros processados: ${finalData.length}`);
       console.log(`üìö Total de comuns brutas (antes de remover duplicatas): ${rawComuns.length}`);
       
       // üö® CORRE√á√ÉO: O usu√°rio informou que s√£o 179 comuns, n√£o 183
       const totalEsperado = 179;
       if (valores.length < totalEsperado) {
         console.error(`üö® ERRO CR√çTICO: Apenas ${valores.length} comuns encontradas (esperado: ${totalEsperado})`);
         console.error(`   FALTANDO: ${totalEsperado - valores.length} comuns`);
         console.error('   Total de registros processados:', finalData.length);
         console.error('   Total de comuns brutas (antes de remover duplicatas):', rawComuns.length);
         
         // Se n√£o encontrou todas, tentar buscar sem filtro de ativo COM PAGINA√á√ÉO
         if (valores.length < totalEsperado && finalData.length < 10000) {
           console.warn('‚ö†Ô∏è Tentando buscar sem filtro de ativo (com pagina√ß√£o)...');
           try {
             console.log('üìö Executando query sem filtro de ativo com pagina√ß√£o...');
             
             // üö® CORRE√á√ÉO CR√çTICA: Buscar TODOS os registros sem filtro de ativo usando pagina√ß√£o
             let allData = [];
             let hasMoreAll = true;
             let currentPageAll = 0;
             const pageSizeAll = 1000;
             
             while (hasMoreAll) {
               const fromAll = currentPageAll * pageSizeAll;
               const toAll = fromAll + pageSizeAll - 1;
               
               const { data: pageDataAll, error: pageErrorAll } = await sb
                 .from(TABLE_CATALOGO)
                 .select(COL_COMUM)
                 .not(COL_COMUM, 'is', null)
                 .neq(COL_COMUM, '')
                 .order(COL_COMUM, { ascending: true })
                 .range(fromAll, toAll);
               
               if (pageErrorAll) {
                 console.error('‚ùå Erro ao buscar p√°gina sem filtro:', pageErrorAll);
                 break;
               }
               
               if (!pageDataAll || pageDataAll.length === 0) {
                 hasMoreAll = false;
                 break;
               }
               
               allData = allData.concat(pageDataAll);
               hasMoreAll = pageDataAll.length === pageSizeAll;
               currentPageAll++;
               
               if (hasMoreAll) {
                 await new Promise(resolve => setTimeout(resolve, isMobile ? 100 : 200));
               }
             }
             
             console.log(`‚úÖ Total de registros buscados sem filtro de ativo: ${allData.length}`);
             
             // üö® CORRE√á√ÉO CR√çTICA PRODU√á√ÉO: Logs detalhados do fallback
             if (allData && allData.length > 0) {
               console.log(`‚úÖ Encontrados ${allData.length} registros sem filtro de ativo`);
               // üö® CORRE√á√ÉO: Reprocessar com todos os dados usando Set (mesma l√≥gica principal)
               const allComunsSet = new Set();
               
               allData.forEach(r => {
                 const comumOriginal = r[COL_COMUM];
                 if (!comumOriginal || typeof comumOriginal !== 'string') return;
                 const comumTrimmed = comumOriginal.trim();
                 if (!comumTrimmed) return;
                 const comumNormalizado = comumTrimmed.toUpperCase();
                 allComunsSet.add(comumNormalizado);
               });
               
               const allValores = Array.from(allComunsSet)
                 .sort((a,b)=>a.localeCompare(b,'pt-BR'));
               
               console.log(`‚úÖ Total de comuns √∫nicas (sem filtro ativo): ${allValores.length}`);
               
               if (allValores.length > valores.length) {
                 console.log(`‚úÖ Usando dados sem filtro de ativo (${allValores.length} comuns encontradas vs ${valores.length} anteriores)`);
                 valores = allValores;
               } else {
                 console.log(`‚ö†Ô∏è Dados sem filtro n√£o trouxeram mais comuns (${allValores.length} vs ${valores.length})`);
               }
             } else {
               console.error('‚ùå Query sem filtro de ativo retornou 0 registros');
               console.error('‚ùå Verificando se Supabase est√° configurado corretamente...');
               console.error('‚ùå TABLE_CATALOGO:', TABLE_CATALOGO);
               console.error('‚ùå COL_COMUM:', COL_COMUM);
               console.error('‚ùå sb dispon√≠vel:', !!sb);
               console.error('‚ùå supabaseLoaded:', supabaseLoaded);
             }
           } catch (err) {
             console.error('‚ùå Erro ao buscar sem filtro de ativo:', err);
             console.error('‚ùå Stack trace:', err.stack);
           }
         }
       } else if (valores.length >= totalEsperado) {
         console.log(`‚úÖ SUCESSO: ${valores.length} comuns encontradas (esperado: ${totalEsperado})!`);
       } else {
         console.warn(`‚ö†Ô∏è ATEN√á√ÉO: ${valores.length} comuns encontradas (esperado: ${totalEsperado})`);
       }
       
       // üö® CORRE√á√ÉO: Logs de debug removidos para n√£o atrasar carregamento
       // O sistema processa todos os registros para obter todas as comuns √∫nicas
   
       // üö® CORRE√á√ÉO CR√çTICA: Validar antes de salvar no cache
       console.log(`üìö VALIDA√á√ÉO FINAL: ${valores.length} comuns ser√£o salvas no cache`);
       if (valores.length < 179) {
         console.error(`üö® ATEN√á√ÉO: Apenas ${valores.length} comuns ser√£o salvas (esperado: 179)`);
       } else {
         console.log(`‚úÖ SUCESSO: ${valores.length} comuns ser√£o salvas no cache (esperado: 179)`);
       }
       
       // üö® CORRE√á√ÉO CR√çTICA: Remover duplicatas antes de salvar no cache
       // Garantir que n√£o h√° duplicatas exatas (case-insensitive)
       const comunsUnicasFinais = new Set();
       valores.forEach(comum => {
         if (comum && typeof comum === 'string') {
           comunsUnicasFinais.add(comum.toUpperCase().trim());
         }
       });
       const valoresSemDuplicatas = Array.from(comunsUnicasFinais)
         .sort((a,b)=>a.localeCompare(b,'pt-BR'));
       
       console.log(`üìö Comuns antes de remover duplicatas: ${valores.length}`);
       console.log(`üìö Comuns ap√≥s remover duplicatas: ${valoresSemDuplicatas.length}`);
       
       if (valoresSemDuplicatas.length < valores.length) {
         console.warn(`‚ö†Ô∏è ${valores.length - valoresSemDuplicatas.length} duplicatas removidas das comuns`);
       }
       
       // Salva no cache para uso offline
       setCache(CACHE_KEYS.COMUNS, valoresSemDuplicatas);
       console.log(`‚úÖ Cache de comuns atualizado com ${valoresSemDuplicatas.length} comuns (sem duplicatas)`);
       populateComunsInput(input, valoresSemDuplicatas);
       // showToast('success', 'Dados atualizados', 'Comuns carregadas com sucesso', 2000);
     } catch (e) {
       console.error('‚ùå Erro geral ao carregar comuns:', e);
       console.log('üìµ Verificando cache devido ao erro geral...');
       
       // üö® CORRE√á√ÉO CR√çTICA: Sempre verificar cache quando houver erro
       const cachedComuns = getCache(CACHE_KEYS.COMUNS);
       if (cachedComuns && cachedComuns.length > 0) {
         console.log(`‚úÖ ${cachedComuns.length} comuns carregadas do cache (erro geral)`);
         populateComunsInput(input, cachedComuns);
         showToast('warning', 'Erro de conex√£o', 'Usando dados em cache', 3000);
         return;
       }
       
       // Se n√£o houver cache, usar dados padr√£o
       console.log('‚ö†Ô∏è Cache vazio - usando lista padr√£o de comuns');
       const defaultComuns = [
         'Apache', 'Aguassa√≠', 'Caucaia do Alto', 'Cotia', 'Itapevi', 'Jandira', 
         'Vargem Grande Paulista', 'Fazendinha', 'Pirapora', 'Jardim Miranda',
         'Vila S√£o Francisco', 'Granja Viana', 'Embu das Artes', 'Tabo√£o da Serra',
         'Central', 'Alphaville', 'Alto da Colina', 'Alto do Bela Vista', 'Alto do Paulista'
       ];
       populateComunsInput(input, defaultComuns);
       showToast('error', 'Erro de conex√£o', 'Usando lista padr√£o de comuns', 3000);
     }
   }
   
  function populateComunsInput(input, valores) {
    if (!input) {
      console.error('‚ùå populateComunsInput: Campo de comum n√£o encontrado');
      return;
    }
    
    if (!valores || !Array.isArray(valores) || valores.length === 0) {
      console.warn('‚ö†Ô∏è populateComunsInput: Valores inv√°lidos ou vazios:', valores);
      return;
    }
    
    // üö® CORRE√á√ÉO CR√çTICA: Remover duplicatas antes de armazenar
    const comunsUnicas = new Set();
    valores.forEach(comum => {
      if (comum && typeof comum === 'string') {
        const comumNormalizado = comum.toUpperCase().trim();
        if (comumNormalizado) {
          comunsUnicas.add(comumNormalizado);
        }
      }
    });
    
    const valoresSemDuplicatas = Array.from(comunsUnicas)
      .sort((a,b)=>a.localeCompare(b,'pt-BR'));
    
    if (valoresSemDuplicatas.length < valores.length) {
      console.warn(`‚ö†Ô∏è populateComunsInput: ${valores.length - valoresSemDuplicatas.length} duplicatas removidas`);
    }
    
    console.log(`‚úÖ populateComunsInput: ${valoresSemDuplicatas.length} comuns √∫nicas ser√£o armazenadas`);
    
    // Armazena os dados no dataset para o sistema de pesquisa (sem duplicatas)
    input.dataset.comumList = JSON.stringify(valoresSemDuplicatas);
    
    // Atualiza dados de pesquisa
    updateComumData();
    
    // üö® CORRE√á√ÉO CR√çTICA: Garantir que os dados foram realmente armazenados
    const dadosVerificacao = input.dataset.comumList;
    if (dadosVerificacao) {
      try {
        const dadosParseados = JSON.parse(dadosVerificacao);
        console.log('‚úÖ populateComunsInput: Dados armazenados com sucesso:', dadosParseados.length, 'comuns (sem duplicatas)');
        
        // Verificar se h√° duplicatas nos dados armazenados
        const duplicatasEncontradas = dadosParseados.length !== new Set(dadosParseados.map(c => c.toUpperCase())).size;
        if (duplicatasEncontradas) {
          console.error('üö® ERRO: Duplicatas detectadas nos dados armazenados!');
        }
      } catch (e) {
        console.error('‚ùå populateComunsInput: Erro ao verificar dados armazenados:', e);
      }
    } else {
      console.error('‚ùå populateComunsInput: Dados n√£o foram armazenados no dataset!');
    }
  }
   
   /* ===== CONTROLE DE VISIBILIDADE DO INSTRUMENTO ===== */
   function toggleInstrumentFieldVisibility() {
     console.log('üîß toggleInstrumentFieldVisibility() chamada');
     const cargoEl = findCargoField();
     const instrumentoEl = findInstrumentField();
     
     console.log('üîß Elementos encontrados:', { cargoEl: !!cargoEl, instrumentoEl: !!instrumentoEl });
     
     if (!cargoEl || !instrumentoEl) {
       console.log('‚ùå Elementos n√£o encontrados, retornando');
       return;
     }
     
     const cargo = cargoEl.value.trim();
     const cargoUP = ucase(cargo);
     
     console.log('üîß Cargo detectado:', { cargo, cargoUP });
     
     // Cargos que n√£o precisam de instrumento (n√£o tocam) - usando vers√£o sem acentos
     const cargosSemInstrumento = [
       'IRMANDADE',     // Irmandade
       'ANCIAO',        // Anci√£o
       'DIACONO',       // Di√°cono
       'COOPERADOR DO OFICIO',  // Cooperador do Of√≠cio
       'COOPERADOR DE JOVENS',  // Cooperador de Jovens
       'PORTEIRO (A)',  // Porteiro (a)
       'BOMBEIRO (A)',  // Bombeiro (a)
       'MEDICO (A)',    // M√©dico (a)
       'ENFERMEIRO (A)' // Enfermeiro (a)
     ];
     
     const deveOcultarInstrumento = cargosSemInstrumento.includes(cargoUP);
     const isOrganista = cargoUP === 'ORGANISTA';
     const isExaminadora = cargoUP === 'EXAMINADORA';
     const isInstrutor = cargoUP === 'INSTRUTOR' || cargoUP === 'INSTRUTORA';
     const isSecretariaMusica = cargo.toLowerCase().includes('secret√°ria') && cargo.toLowerCase().includes('m√∫sica');
     const isOrganistaOuRelacionado = isOrganista || isExaminadora || isSecretariaMusica; // Removido isInstrutor
     
     console.log('üîß L√≥gica de visibilidade:', {
       deveOcultarInstrumento,
       isOrganista,
       isExaminadora,
       isInstrutor,
       isSecretariaMusica,
       isOrganistaOuRelacionado
     });
     
     // üõ°Ô∏è MOBILE FIX: Encontra o container do campo instrumento com m√∫ltiplos seletores
     let instrumentoContainer = instrumentoEl.closest('.mb-3');
     
     // Se n√£o encontrar com .mb-3, tenta outros seletores
     if (!instrumentoContainer) {
       instrumentoContainer = instrumentoEl.closest('.form-group');
     }
     if (!instrumentoContainer) {
       instrumentoContainer = instrumentoEl.closest('.field-container');
     }
     if (!instrumentoContainer) {
       instrumentoContainer = instrumentoEl.parentElement;
     }
     
     console.log('üîß Container encontrado:', { instrumentoContainer: !!instrumentoContainer, mobile: isMobile });
     
     if (deveOcultarInstrumento) {
       console.log('üîß Ocultando instrumento para cargo n√£o musical (Mobile:', isMobile, ')');
       // üõ°Ô∏è MOBILE FIX: Oculta o campo instrumento com !important
       if (instrumentoContainer) {
         instrumentoContainer.style.setProperty('display', 'none', 'important');
         instrumentoContainer.style.setProperty('visibility', 'hidden', 'important');
         instrumentoContainer.style.setProperty('height', '0', 'important');
         instrumentoContainer.style.setProperty('overflow', 'hidden', 'important');
         instrumentoContainer.style.setProperty('margin', '0', 'important');
         instrumentoContainer.style.setProperty('padding', '0', 'important');
         console.log('üîß CSS aplicado: display: none !important');
       } else {
         console.log('‚ùå Container n√£o encontrado para ocultar');
       }
       // Limpa o valor do instrumento
       instrumentoEl.value = '';
     } else if (isOrganistaOuRelacionado) {
       console.log('üîß Ocultando instrumento e preenchendo √ìRG√ÉO para organista/examinadora (Mobile:', isMobile, ')');
       // üõ°Ô∏è MOBILE FIX: Para Organista ou Examinadora: oculta o campo com !important
       if (instrumentoContainer) {
         instrumentoContainer.style.setProperty('display', 'none', 'important');
         instrumentoContainer.style.setProperty('visibility', 'hidden', 'important');
         instrumentoContainer.style.setProperty('height', '0', 'important');
         instrumentoContainer.style.setProperty('overflow', 'hidden', 'important');
         instrumentoContainer.style.setProperty('margin', '0', 'important');
         instrumentoContainer.style.setProperty('padding', '0', 'important');
         console.log('üîß CSS aplicado: display: none !important (organista)');
       } else {
         console.log('‚ùå Container n√£o encontrado para organista');
       }
       
       // üö® CORRE√á√ÉO CR√çTICA: Garantir que "√ìRG√ÉO" esteja dispon√≠vel como op√ß√£o no SELECT
       // Mesmo que tenha sido filtrado da lista vis√≠vel, precisa estar dispon√≠vel para o valor ser aceito
       if (instrumentoEl.tagName === 'SELECT') {
         // Verifica se "√ìRG√ÉO" j√° existe como op√ß√£o
         const orgaoOption = Array.from(instrumentoEl.options).find(opt => opt.value === '√ìRG√ÉO');
         if (!orgaoOption) {
           // Adiciona "√ìRG√ÉO" como op√ß√£o oculta (ser√° filtrado na exibi√ß√£o, mas dispon√≠vel para valor)
           const option = document.createElement('option');
           option.value = '√ìRG√ÉO';
           option.textContent = '√ìRG√ÉO';
           option.style.display = 'none'; // Oculta da lista, mas mant√©m dispon√≠vel
           instrumentoEl.appendChild(option);
           console.log('üîß Op√ß√£o √ìRG√ÉO adicionada ao SELECT (oculta)');
         }
       }
       
       // Preenche automaticamente com "√ìRG√ÉO"
       instrumentoEl.value = '√ìRG√ÉO';
       console.log(`üéπ ${cargo} detectado - Instrumento preenchido automaticamente: √ìRG√ÉO`);
       
       // DEBUG: Verificar se o valor foi realmente definido
       console.log('üîç DEBUG - Valor do instrumento ap√≥s preenchimento autom√°tico:', instrumentoEl.value);
       
       // üöÄ OTIMIZA√á√ÉO: Removida chamada duplicada de loadNomes()
       // O event listener de 'change' do cargo j√° dispara loadNomes() automaticamente
       // Isso evita carregamento duplo e melhora a performance
       console.log('üéπ Organista detectado - loadNomes ser√° chamado automaticamente pelo event listener de cargo');
     } else {
       console.log('üîß Mostrando instrumento para cargo musical (Mobile:', isMobile, ')');
       // üõ°Ô∏è MOBILE FIX: Mostra o campo instrumento com !important
       if (instrumentoContainer) {
         instrumentoContainer.style.removeProperty('display');
         instrumentoContainer.style.removeProperty('visibility');
         instrumentoContainer.style.removeProperty('height');
         instrumentoContainer.style.removeProperty('overflow');
         instrumentoContainer.style.removeProperty('margin');
         instrumentoContainer.style.removeProperty('padding');
         instrumentoContainer.style.setProperty('display', 'block', 'important');
         console.log('üîß CSS aplicado: display: block !important');
       } else {
         console.log('‚ùå Container n√£o encontrado para mostrar');
       }
     }
   }
   
   /* ===== INSTRUMENTOS E CARGOS (fixos) ===== */
   function loadInstrumentosFixed() {
     const sel = findInstrumentField();
     if (!sel) return;
     
     // üöÄ OTIMIZA√á√ÉO: Verificar cache antes de limpar (evita opera√ß√£o desnecess√°ria)
     const cached = getCache(CACHE_KEYS.INSTRUMENTOS);
     if (!cached || !Array.isArray(cached) || cached.length === 0) {
       localStorage.removeItem(CACHE_KEYS.INSTRUMENTOS);
     }
     
     const items = INSTRUMENTS_FIXED.slice();
     setCache(CACHE_KEYS.INSTRUMENTOS, items);
     
     // üì± MOBILE: Filtrar "√ìRG√ÉO" apenas da exibi√ß√£o (n√£o remove do array original)
     // A l√≥gica continua funcionando normalmente, apenas oculta da lista para n√£o confundir o usu√°rio
     const isMobileDevice = window.innerWidth <= 768 || /Mobile|Android|iPhone|iPad/.test(navigator.userAgent);
     const itemsParaExibir = isMobileDevice 
       ? items.filter(item => item !== '√ìRG√ÉO')
       : items;
   
     if (sel.tagName === 'SELECT') {
       sel.innerHTML =
         '<option value="">Selecione uma op√ß√£o</option>' +
         itemsParaExibir.map(v => `<option value="${v}">${v}</option>`).join('');
       
       // üö® CORRE√á√ÉO CR√çTICA: Adicionar "√ìRG√ÉO" como op√ß√£o oculta no mobile
       // Isso garante que o valor possa ser definido programaticamente mesmo que n√£o esteja vis√≠vel
       if (isMobileDevice && items.includes('√ìRG√ÉO')) {
         const orgaoOption = document.createElement('option');
         orgaoOption.value = '√ìRG√ÉO';
         orgaoOption.textContent = '√ìRG√ÉO';
         orgaoOption.style.display = 'none'; // Oculta da lista, mas mant√©m dispon√≠vel para valor
         sel.appendChild(orgaoOption);
       }
     } else {
       let dl = document.getElementById('dlInstrumentos');
       if (!dl) { dl = document.createElement('datalist'); dl.id = 'dlInstrumentos'; document.body.appendChild(dl); }
       dl.innerHTML = itemsParaExibir.map(v => `<option value="${v}">`).join('');
       sel.setAttribute('list', 'dlInstrumentos');
     }
     
   }
   
   function loadCargosFixed() {
     const cargoEl = findCargoField();
     if (!cargoEl) return;
     
     // üöÄ OTIMIZA√á√ÉO: Verificar cache antes de limpar (evita opera√ß√£o desnecess√°ria)
     const cached = getCache(CACHE_KEYS.CARGOS);
     if (!cached || !Array.isArray(cached) || cached.length === 0) {
       localStorage.removeItem(CACHE_KEYS.CARGOS);
     }
     
     const items = CARGOS_FIXED.slice();
     setCache(CACHE_KEYS.CARGOS, items);
     
     if (cargoEl.tagName === 'SELECT') {
       cargoEl.innerHTML = '<option value="">Selecione o cargo‚Ä¶</option>' +
         items.map(v => `<option value="${v}">${v}</option>`).join('');
     }
   }
   
   // üöÄ FUN√á√ÉO PARA CARREGAR CARGOS E INSTRUMENTOS OFFLINE
   function loadCargosInstrumentosOffline() {
     console.log('üì¥ Carregando cargos e instrumentos para modo offline...');
     
     // Carregar cargos
     loadCargosFixed();
     console.log('‚úÖ Cargos carregados para modo offline');
     
     // Carregar instrumentos
     loadInstrumentosFixed();
     console.log('‚úÖ Instrumentos carregados para modo offline');
     
     // Verificar se os campos foram populados
     const cargoEl = findCargoField();
     const instEl = findInstrumentField();
     
     if (cargoEl && cargoEl.options.length > 1) {
       console.log('‚úÖ Campo de cargo populado com', cargoEl.options.length - 1, 'op√ß√µes');
     } else {
       console.warn('‚ö†Ô∏è Campo de cargo n√£o foi populado corretamente');
     }
     
     if (instEl && (instEl.options?.length > 1 || instEl.getAttribute('list'))) {
       console.log('‚úÖ Campo de instrumento populado');
     } else {
       console.warn('‚ö†Ô∏è Campo de instrumento n√£o foi populado corretamente');
     }
   }
   
   // üéØ FUN√á√ÉO ESPEC√çFICA PARA MODAL: Carrega todos os cargos
   function loadCargosCompletosModal() {
     const modalCargoEl = document.querySelector('#modalCargo, [name="modalCargo"], #cargoModal');
     if (!modalCargoEl) {
       console.log('‚ö†Ô∏è Campo de cargo do modal n√£o encontrado');
       return;
     }
     
     console.log('üéØ Carregando cargos completos para modal...');
     
     // Mant√©m a ordem original dos cargos (cargos musicais primeiro)
     const cargosOrdenados = CARGOS_COMPLETOS_MODAL.slice();
     
     if (modalCargoEl.tagName === 'SELECT') {
       modalCargoEl.innerHTML = '<option value="">Selecione o cargo‚Ä¶</option>' +
         cargosOrdenados.map(v => `<option value="${v}">${v}</option>`).join('');
     }
     
     console.log('‚úÖ Cargos completos carregados no modal:', cargosOrdenados.length, 'cargos');
   }
   
   /* ===== CACHE OFFLINE ===== */
   function loadNomesFromCache(comumVal, instVal, cargoVal, cargoUP, precisaInst) {
     try {
       console.log('üîç Buscando dados no cache offline...');
       
       // Log espec√≠fico para mobile
       if (isMobile) {
         console.log('üì± MOBILE: Buscando nomes no cache offline:', {
           comum: comumVal,
           instrumento: instVal,
           cargo: cargoVal,
           precisaInstrumento: precisaInst
         });
       }
       
       // Busca dados em diferentes chaves de cache
       const cacheKeys = [
         'cache_nomes_all', // Cache geral de todos os nomes
         'cache_nomes_' + comumVal.toLowerCase().replace(/\s+/g, '_'),
         'cache_nomes_' + cargoVal.toLowerCase().replace(/\s+/g, '_'),
         'cache_nomes_' + instVal.toLowerCase().replace(/\s+/g, '_')
       ];
       
       let allCachedData = [];
       
       // Coleta dados de todas as chaves de cache
       cacheKeys.forEach(key => {
         const cached = localStorage.getItem(key);
         if (cached) {
           try {
             const data = JSON.parse(cached);
             if (Array.isArray(data)) {
               allCachedData = allCachedData.concat(data);
               
               // Log espec√≠fico para mobile
               if (isMobile) {
                 console.log(`üì± MOBILE: Cache encontrado em ${key}:`, data.length, 'itens');
               }
             }
           } catch (e) {
             console.warn('‚ö†Ô∏è Erro ao parsear cache:', key, e.message);
             
             // Log espec√≠fico para mobile
             if (isMobile) {
               console.warn(`üì± MOBILE: Erro ao parsear cache ${key}:`, e.message);
             }
           }
         } else {
           // Log espec√≠fico para mobile
           if (isMobile) {
             console.log(`üì± MOBILE: Cache n√£o encontrado em ${key}`);
           }
         }
       });
       
       if (allCachedData.length === 0) {
         console.log('üì≠ Nenhum dado encontrado no cache');
         return [];
       }
       
       // Remove duplicatas
       const uniqueData = allCachedData.filter((item, index, self) => 
         index === self.findIndex(t => t.nome === item.nome && t.comum === item.comum)
       );
       
       console.log('üìä Dados √∫nicos no cache:', uniqueData.length);
       
      // Filtra dados baseado nos crit√©rios
      const filtered = uniqueData.filter(r => {
        const comumR = upper(r[COL_COMUM] || '');
        const cargoR = upper(r.cargo || '');
        // üîß CORRE√á√ÉO: Normaliza o instrumento do registro da mesma forma que o valor buscado
        const instR = normalizeInstrument(r.instrumento || '');
        const comumBusca = upper(comumVal);
         
        // Filtro por comum - usar fun√ß√£o utilit√°ria para compara√ß√£o robusta
        if (comumVal) {
          const comparaResult = compareComum(r[COL_COMUM], comumVal);
          if (!comparaResult.match) {
            return false;
          }
        }
         
         // Filtro por cargo
         if (cargoVal) {
          if (cargoUP === 'ORGANISTA') {
            // üõ°Ô∏è CORRE√á√ÉO: Para organista, busca por instrumento √ìRG√ÉO OU por cargo ORGANISTA, SECRET√ÅRIA DA M√öSICA (feminino), INSTRUTORA ou EXAMINADORA
            // üö® SECRET√ÅRIO DA M√öSICA (masculino) N√ÉO deve ser inclu√≠do na verifica√ß√£o de organistas
            // üö® INSTRUTOR (masculino) N√ÉO deve ser inclu√≠do na verifica√ß√£o de organistas
            // üö® CORRE√á√ÉO CR√çTICA: Verificar tanto o instrumento √ìRG√ÉO quanto o cargo ORGANISTA
            const isOrganistaPorInstrumento = instR.includes('√ìRG√ÉO');
            const isOrganistaPorCargo = cargoR.includes('ORGANISTA');
            const isOrganista = isOrganistaPorInstrumento || isOrganistaPorCargo;
            // üîß CORRE√á√ÉO: Busca por varia√ß√µes de SECRET√ÅRIA DA M√öSICA (com e sem acentos)
            const isSecretariaMusica = cargoR.includes('SECRET√ÅRIA DA M√öSICA') || cargoR.includes('SECRETARIA DA MUSICA');
            const isInstrutora = cargoR.includes('INSTRUTORA');
            const isExaminadora = cargoR.includes('EXAMINADORA');
            // üö® FILTRO CR√çTICO: Remove cargos masculinos que n√£o devem aparecer na lista de organistas
            const isSecretarioMusica = cargoR.includes('SECRET√ÅRIO') && cargoR.includes('M√öSICA') && !cargoR.includes('SECRET√ÅRIA');
            const isInstrutor = cargoR.includes('INSTRUTOR') && !cargoR.includes('INSTRUTORA');
            const isCargoMasculino = isSecretarioMusica || isInstrutor;
            return (isOrganista || isSecretariaMusica || isInstrutora || isExaminadora) && !isCargoMasculino;
          } else if (cargoUP === 'INSTRUTOR') {
            // Para instrutor, busca por instrumento espec√≠fico
            // üîß CORRE√á√ÉO: Usa fun√ß√£o matchInstrument para compara√ß√£o robusta
            const match = matchInstrument(instVal, r.instrumento);
            return cargoR.includes('INSTRUTOR') && match;
          } else if (precisaInst) {
            // Para m√∫sicos, busca por instrumento (seguindo l√≥gica das organistas)
            // üîß CORRE√á√ÉO: Usa fun√ß√£o matchInstrument para compara√ß√£o robusta
            const match = matchInstrument(instVal, r.instrumento);
            
            console.log('üéµ DEBUG CACHE - Verificando m√∫sico:', {
              nome: r.nome,
              instrumentoOriginal: r.instrumento,
              instrumentoNormalizado: instR,
              instValBuscado: instVal,
              match
            });
            return match;
           } else {
             // Outros cargos
             const cargoBusca = upper(cargoVal);
             return cargoR.includes(cargoBusca);
           }
         }
         
         return true;
       });
       
       console.log('‚úÖ Dados filtrados do cache:', filtered.length);
       
       // Log espec√≠fico para mobile
       if (isMobile) {
         console.log('üì± MOBILE: Dados filtrados do cache offline:', {
           total: allCachedData.length,
           filtrados: filtered.length,
           dados: filtered.map(item => ({
             nome: item.nome,
             comum: item.comum,
             cargo: item.cargo
           }))
         });
       }
       
       return filtered;
       
     } catch (error) {
       console.error('‚ùå Erro ao carregar cache offline:', error);
       return [];
     }
   }
   
   function saveNomesToCache(data, comumVal, instVal, cargoVal) {
     try {
       console.log('üíæ Salvando dados no cache offline...');
       
       // Salva cache geral
       const existingAll = JSON.parse(localStorage.getItem('cache_nomes_all') || '[]');
       const combinedAll = [...existingAll, ...data];
       const uniqueAll = combinedAll.filter((item, index, self) => 
         index === self.findIndex(t => t.nome === item.nome && t.comum === item.comum)
       );
       localStorage.setItem('cache_nomes_all', JSON.stringify(uniqueAll));
       
       // Salva cache espec√≠fico por comum
       if (comumVal) {
         const key = 'cache_nomes_' + comumVal.toLowerCase().replace(/\s+/g, '_');
         localStorage.setItem(key, JSON.stringify(data));
       }
       
       // Salva cache espec√≠fico por cargo
       if (cargoVal) {
         const key = 'cache_nomes_' + cargoVal.toLowerCase().replace(/\s+/g, '_');
         localStorage.setItem(key, JSON.stringify(data));
       }
       
       // Salva cache espec√≠fico por instrumento
       if (instVal) {
         const key = 'cache_nomes_' + instVal.toLowerCase().replace(/\s+/g, '_');
         localStorage.setItem(key, JSON.stringify(data));
       }
       
       console.log('‚úÖ Cache offline atualizado com', data.length, 'nomes');
       
     } catch (error) {
       console.error('‚ùå Erro ao salvar cache offline:', error);
     }
   }
   
   // Fun√ß√£o para limpar cache espec√≠fico do instrumento anterior
   function clearInstrumentCache() {
     try {
       const instEl = findInstrumentField();
       const comumEl = findComumField();
       const cargoEl = findCargoField();
       
       if (!instEl) return;
       
       const currentInstrument = instEl.value;
       const currentComum = comumEl ? comumEl.value : '';
       const currentCargo = cargoEl ? cargoEl.value : '';
       
       console.log('üßπ LIMPEZA AGRESSIVA - Instrumento alterado para:', currentInstrument);
       
       // üöÄ LIMPEZA AGRESSIVA: Remove todos os caches relacionados a nomes
       const cacheKeys = Object.keys(localStorage);
       cacheKeys.forEach(key => {
         if (key.includes('nomes') || key.includes('cache_nomes') || key.includes('nomesData')) {
           localStorage.removeItem(key);
           console.log('üóëÔ∏è Cache removido:', key);
         }
       });
       
       // Limpa vari√°veis globais
       if (window.nomesData) {
         window.nomesData = null;
         console.log('üóëÔ∏è Vari√°vel global nomesData limpa');
       }
       
       // üöÄ NOVA LIMPEZA: Remove cache espec√≠fico por instrumento
       if (currentComum && currentCargo) {
         const cacheKeyBase = `cache_nomes_${norm(currentComum)}_${norm(currentCargo)}`;
         const cacheKeyWithData = `${cacheKeyBase}_dados`;
         
         localStorage.removeItem(cacheKeyBase);
         localStorage.removeItem(cacheKeyWithData);
         console.log('üóëÔ∏è Cache espec√≠fico removido:', cacheKeyBase, cacheKeyWithData);
       }
       
       // Usa a fun√ß√£o de invalida√ß√£o inteligente
       invalidateCacheOnFilterChange(currentComum, currentInstrument, currentCargo);
       
       console.log('‚úÖ Cache de instrumentos limpo com sucesso - Lista ser√° recarregada');
       
     } catch (error) {
       console.error('‚ùå Erro ao limpar cache de instrumentos:', error);
     }
   }
   
   // üîß CONTROLE DE REQUISI√á√ïES PENDENTES - Apenas para identificar a mais recente
   let loadNomesRequestId = null;
   let lastLoadNomesTime = 0;
   const LOAD_NOMES_DEBOUNCE_MS = 300; // Tempo m√≠nimo entre carregamentos (300ms)
   
   // Fun√ß√£o de debounce para otimizar performance
   function debounce(func, wait) {
     let timeout;
     return function executedFunction(...args) {
       const later = () => {
         clearTimeout(timeout);
         func(...args);
       };
       clearTimeout(timeout);
       timeout = setTimeout(later, wait);
     };
   }
   
   // üöÄ OTIMIZA√á√ÉO MOBILE: Debounce otimizado para mobile (150ms) e desktop (200ms)
   // Timeout balanceado para n√£o cancelar requisi√ß√µes mas tamb√©m n√£o atrasar muito
   const debouncedLoadNomes = debounce(loadNomes, isMobile ? 150 : 200);
   
   // üîß FUN√á√ÉO: Limpa imediatamente o campo de nomes
   function limparCampoNomes() {
     const nomeEl = findNomeField();
     if (!nomeEl) return;
     
    console.log('üßπ Limpando campo de nomes imediatamente...');
    
    // Limpa o campo de forma imediata e vis√≠vel
    // üö® CORRE√á√ÉO CR√çTICA: N√ÉO limpar SELECT se j√° foi populado (para Chrome iOS e Android)
    if (nomeEl.tagName === 'SELECT') {
      // Se SELECT j√° tem op√ß√µes OU est√° marcado como populado, N√ÉO limpar
      if (nomeEl.options.length > 1 || nomeEl.getAttribute('data-populado') === 'true') {
        console.log('‚úÖ SELECT j√° populado - n√£o limpando (op√ß√µes:', nomeEl.options.length, ', data-populado:', nomeEl.getAttribute('data-populado'), ')');
        return;
      }
      nomeEl.innerHTML = '<option value="">Carregando nomes...</option>';
    } else {
       nomeEl.value = '';
       nomeEl.placeholder = 'Carregando nomes...';
       nomeEl.removeAttribute('list');
       // Remove o datalist se existir
       const existingDatalist = document.getElementById('dlNomes');
       if (existingDatalist) {
         existingDatalist.innerHTML = '';
       }
     }
   }
   
   // Fun√ß√£o para limpar registros antigos do cache de envios
   function cleanOldSentRecords() {
     try {
       const sentRecords = JSON.parse(localStorage.getItem('sent_records') || '{}');
       const now = Date.now();
       const maxAge = 24 * 60 * 60 * 1000; // 24 horas
       
       let cleaned = 0;
       Object.keys(sentRecords).forEach(key => {
         if (now - sentRecords[key] > maxAge) {
           delete sentRecords[key];
           cleaned++;
         }
       });
       
       if (cleaned > 0) {
         localStorage.setItem('sent_records', JSON.stringify(sentRecords));
         console.log(`üßπ Limpeza de cache: ${cleaned} registros antigos removidos`);
       }
       
     } catch (error) {
       console.error('‚ùå Erro ao limpar cache de envios:', error);
     }
   }
   
   // Fun√ß√£o para invalidar cache quando h√° mudan√ßas nos filtros
   function invalidateCacheOnFilterChange(newComum, newInstrument, newCargo) {
     try {
       console.log('üîÑ Invalidando cache devido a mudan√ßa nos filtros...');
       
       // Remove caches espec√≠ficos que n√£o correspondem aos novos filtros
       Object.keys(localStorage).forEach(key => {
         if (key.startsWith('cache_nomes_')) {
           let shouldRemove = false;
           
           // Se mudou o instrumento, remove caches de outros instrumentos
           if (newInstrument && key.includes('_')) {
             const parts = key.split('_');
             if (parts.length >= 3) {
               const instrumentFromKey = parts.slice(2).join('_').toUpperCase();
               const newInstrumentUpper = newInstrument.toUpperCase();
               
               if (instrumentFromKey !== newInstrumentUpper && 
                   instrumentFromKey !== '' && 
                   INSTRUMENTS_FIXED.includes(instrumentFromKey)) {
                 shouldRemove = true;
               }
             }
           }
           
           if (shouldRemove) {
             console.log('üóëÔ∏è Removendo cache inv√°lido:', key);
             localStorage.removeItem(key);
           }
         }
       });
       
       console.log('‚úÖ Cache invalidado com sucesso');
       
     } catch (error) {
       console.error('‚ùå Erro ao invalidar cache:', error);
     }
   }
   
   // Fun√ß√£o para mostrar indicador de carregamento
   function showLoadingIndicator() {
     try {
       const nomeEl = findNomeField();
       if (!nomeEl) return;
       
       // Se √© um SELECT, adiciona op√ß√£o de carregamento
       if (nomeEl.tagName === 'SELECT') {
         // Remove op√ß√µes existentes exceto a primeira
         while (nomeEl.children.length > 1) {
           nomeEl.removeChild(nomeEl.lastChild);
         }
         
         // Adiciona op√ß√£o de carregamento
         const loadingOption = document.createElement('option');
         loadingOption.value = '';
         loadingOption.textContent = 'üîÑ Carregando nomes...';
         loadingOption.disabled = true;
         nomeEl.appendChild(loadingOption);
       }
       
       // Adiciona classe de carregamento ao campo
       nomeEl.classList.add('loading');
       
     } catch (error) {
       console.error('‚ùå Erro ao mostrar indicador de carregamento:', error);
     }
   }
   
   // Fun√ß√£o para esconder indicador de carregamento
   function hideLoadingIndicator() {
     try {
       const nomeEl = findNomeField();
       if (!nomeEl) return;
       
       // Remove classe de carregamento
       nomeEl.classList.remove('loading');
       
       // Remove op√ß√£o de carregamento se existir
       if (nomeEl.tagName === 'SELECT') {
         const loadingOption = nomeEl.querySelector('option[disabled]');
         if (loadingOption) {
           loadingOption.remove();
         }
       }
       
     } catch (error) {
       console.error('‚ùå Erro ao esconder indicador de carregamento:', error);
     }
   }
   
   /* ===== CONSULTA DE NOMES OTIMIZADA ===== */
   async function loadNomes() {
     // üöÄ OTIMIZA√á√ÉO: Prevenir carregamentos duplicados muito pr√≥ximos no tempo
     const now = Date.now();
     const timeSinceLastLoad = now - lastLoadNomesTime;
     
     if (timeSinceLastLoad < LOAD_NOMES_DEBOUNCE_MS) {
       console.log(`‚è≠Ô∏è OTIMIZA√á√ÉO: Ignorando loadNomes() - carregamento muito recente (${timeSinceLastLoad}ms atr√°s)`);
       return;
     }
     
     // üîß CORRE√á√ÉO: Gera ID √∫nico para esta requisi√ß√£o e marca como a mais recente
     const currentRequestId = now;
     loadNomesRequestId = currentRequestId;
     lastLoadNomesTime = now;
     
     // üöÄ OTIMIZA√á√ÉO: Log reduzido para melhor performance
     // Removido stack trace que √© custoso e desnecess√°rio
     
     try {
       // Mostra indicador de carregamento melhorado (apenas desktop)
       if (!isMobile) {
         showLoadingIndicator();
       }
       
       const comumEl = findComumField();
       const instEl  = findInstrumentField();
       const cargoEl = findCargoField();
       const nomeEl  = findNomeField();
       
       if (!comumEl || !instEl || !cargoEl || !nomeEl) {
         console.error('‚ùå Elementos n√£o encontrados:', { comumEl: !!comumEl, instEl: !!instEl, cargoEl: !!cargoEl, nomeEl: !!nomeEl });
         if (isMobile) {
           hideLoadingAlert();
         } else {
           hideLoadingIndicator();
         }
         return;
       }
   
       // üö® CORRE√á√ÉO CR√çTICA: SEMPRE resetar estado de digita√ß√£o manual ao iniciar loadNomes
       // Isso garante que ao mudar cargo/instrumento/comum, o campo volte a funcionar normalmente
       if (nomeEl) {
         nomeEl.removeAttribute('data-nome-manual');
         nomeEl.removeAttribute('data-selected-from-list');
         // Restaurar estilo normal
         if (nomeEl.style) {
           nomeEl.style.backgroundColor = '';
           nomeEl.style.borderColor = '';
         }
         // Se for INPUT, restaurar datalist (ser√° adicionado novamente se houver dados)
         if (nomeEl.tagName === 'INPUT' && nomeEl.type === 'text') {
           // üö® CORRE√á√ÉO: N√£o usar datalist - remover atributo list
          nomeEl.removeAttribute('list');
         }
       }
   
      // üö® CORRE√á√ÉO CR√çTICA: Normalizar comum removendo acentos para busca funcionar corretamente
      // Exemplo: "Jardim Honoria" deve encontrar "Jardim Hon√≥ria" no banco
      const comumVal = norm(comumEl.value);
      const comumValSemAcento = noacc(comumVal); // Remove acentos para busca
      
      // üö® CORRE√á√ÉO CR√çTICA: Garantir que o valor do instrumento seja lido corretamente
      // Se for SELECT, usar selectedOptions, sen√£o usar value direto
      let instrumentoValue = '';
      if (instEl.tagName === 'SELECT') {
        instrumentoValue = instEl.options[instEl.selectedIndex]?.value || instEl.value || '';
      } else {
        instrumentoValue = instEl.value || '';
      }
      
      const instVal = normalizeInstrument(instrumentoValue);
      
      // üö® DEBUG: Log para verificar valores
      if (instrumentoValue && instrumentoValue.includes('SAXOFONE')) {
        console.log('üîç DEBUG SAXOFONE - Valores capturados:', {
          instrumentoValue: instrumentoValue,
          instVal: instVal,
          instElValue: instEl.value,
          tagName: instEl.tagName,
          selectedIndex: instEl.tagName === 'SELECT' ? instEl.selectedIndex : 'N/A'
        });
      }
      const cargoVal = norm(cargoEl.value);
      const cargoUP  = ucase(cargoVal);
      
      // üõ°Ô∏è DETEC√á√ÉO ROBUSTA CROSS-PLATFORM: Detectar cargos espec√≠ficos de forma mais robusta
      // Isso garante que funciona mesmo se a normaliza√ß√£o falhar no Android
      const cargoLower = cargoVal.toLowerCase().trim();
      const cargoUpper = cargoVal.toUpperCase().trim();
      const cargoSemAcento = noacc(cargoVal).toUpperCase().trim();
      
      // Detec√ß√£o robusta para INSTRUTORA
      const isInstrutora = cargoUP === 'INSTRUTORA' || 
                          cargoUpper.includes('INSTRUTORA') ||
                          cargoSemAcento.includes('INSTRUTORA') ||
                          (cargoLower.includes('instrutora') && !cargoLower.includes('instrutor') && !cargoLower.includes('instrutores'));
      
      // Detec√ß√£o robusta para EXAMINADORA
      const isExaminadora = cargoUP === 'EXAMINADORA' ||
                           cargoUpper.includes('EXAMINADORA') ||
                           cargoSemAcento.includes('EXAMINADORA') ||
                           cargoLower.includes('examinadora');
      
      // Detec√ß√£o robusta para SECRET√ÅRIA DA M√öSICA
      const isSecretariaMusica = (cargoLower.includes('secret√°ria') || cargoLower.includes('secretaria')) &&
                                 (cargoLower.includes('m√∫sica') || cargoLower.includes('musica')) &&
                                 !cargoLower.includes('secret√°rio') && !cargoLower.includes('secretario');
      
      // üöÄ OTIMIZA√á√ÉO: Logs reduzidos para melhor performance (apenas em modo debug)
       
      // üõ°Ô∏è DETEC√á√ÉO ROBUSTA: Verificar se precisa instrumento (usando detec√ß√£o robusta)
      const precisaInst = ['MUSICO','MUSICO(A)','M√öSICO','M√öSICO(A)'].includes(cargoUP) || 
                          ['M√öSICO','M√öSICO(A)'].includes(upper(cargoVal)) ||
                          cargoUP === 'ORGANISTA' ||
                          isExaminadora ||
                          cargoUP === 'INSTRUTOR' ||
                          isInstrutora ||
                          isSecretariaMusica;
  
      const cargoNormalizado = normalizeCargo(cargoVal);
       const variacoesCargo = expandCargoSearch(cargoVal);
   
      // Valida√ß√£o r√°pida: exige comum + cargo + instrumento (quando necess√°rio)
      // ORGANISTA sempre toca √≥rg√£o, ent√£o n√£o precisa selecionar instrumento
      // EXAMINADORA pode ter instrumento ou n√£o - n√£o √© obrigat√≥rio
      // INSTRUTORA e SECRET√ÅRIA DA M√öSICA tamb√©m podem ter instrumento ou n√£o
      const precisaInstrumento = precisaInst && !instVal && 
                                  cargoUP !== 'ORGANISTA' && 
                                  !isExaminadora && 
                                  !isInstrutora && 
                                  !isSecretariaMusica;
      const condicaoFalhou = !comumVal || !cargoVal || precisaInstrumento;
       
      if (condicaoFalhou) {
        // Limpa o campo de nomes rapidamente se n√£o tiver os campos obrigat√≥rios
        // üö® CORRE√á√ÉO CR√çTICA: N√ÉO limpar SELECT se j√° foi populado
        if (nomeEl.tagName === 'SELECT') {
          // Se SELECT j√° tem op√ß√µes OU est√° marcado como populado, N√ÉO limpar
          if (nomeEl.options.length > 1 || nomeEl.getAttribute('data-populado') === 'true') {
            console.log('‚úÖ SELECT j√° populado - n√£o limpando (op√ß√µes:', nomeEl.options.length, ', data-populado:', nomeEl.getAttribute('data-populado'), ')');
            return;
          }
          nomeEl.innerHTML = '<option value="">Selecione um nome da lista (ou digite, se offline)</option>';
        } else {
           nomeEl.placeholder = 'Selecione um nome da lista (ou digite, se offline)';
           nomeEl.removeAttribute('list');
         }
         if (isMobile) {
           hideLoadingAlert();
         } else {
           hideLoadingIndicator();
         }
         return;
       }
       
       // Campos obrigat√≥rios preenchidos, prosseguindo com carregamento
       
       // Verifica se n√£o h√° conex√£o de internet
       if (!navigator.onLine) {
         console.log('üìµ Sem conex√£o de internet, tentando carregar do cache offline...');
         
         // Tenta carregar dados do cache offline primeiro
         try {
           const cachedData = loadNomesFromCache(comumVal, instVal, cargoVal, cargoUP, precisaInst);
           if (cachedData.length > 0) {
             console.log('‚úÖ Dados carregados do cache offline:', cachedData.length);
             populateNomesInput(nomeEl, cachedData);
             // showToast('info', 'Dados carregados offline', `Encontrados ${cachedData.length} nomes no cache`, 3000); // Removido - alerta desnecess√°rio
             return;
           }
         } catch (cacheError) {
           console.error('‚ùå Erro ao carregar cache offline:', cacheError);
         }
         
         // Se n√£o conseguiu carregar do cache, permite digita√ß√£o manual
         console.log('üìù Permitindo digita√ß√£o manual offline...');
         populateNomesInput(nomeEl, []);
         // showToast('info', 'Sem internet', 'Digite o nome completo para cadastrar offline', 2000); // Removido - alerta desnecess√°rio
         return;
       }
   
      // üöÄ OTIMIZA√á√ÉO CR√çTICA PRODU√á√ÉO: Carregar do cache IMEDIATAMENTE (sem logs ou verifica√ß√µes desnecess√°rias)
      const cacheKey = getCacheKey(CACHE_KEYS.NOMES, { comumVal, instVal, cargoVal });
      const cachedNomes = getCache(cacheKey);
      
      // üöÄ OTIMIZA√á√ÉO ESPEC√çFICA ORGANISTA: Verificar cache espec√≠fico para organistas ANTES de qualquer busca
      if (cargoUP === 'ORGANISTA' && comumVal) {
        // Cache espec√≠fico para organistas (mais amplo, n√£o depende de instrumento)
        const organistaCacheKey = `cache_organistas_${comumVal.toLowerCase().replace(/\s+/g, '_')}`;
        const organistaCached = getCache(organistaCacheKey);
        
        if (organistaCached && Array.isArray(organistaCached) && organistaCached.length > 0) {
          // üö® DEBUG CR√çTICO: Verificar se INSTRUTORA est√° no cache
          const instrutorasNoCache = organistaCached.filter(r => 
            r.cargo && (r.cargo.toUpperCase().includes('INSTRUTORA') || r.cargo.toUpperCase().includes('INSTRUTORAS'))
          );
          if (instrutorasNoCache.length > 0) {
            console.log('‚úÖ INSTRUTORAS encontradas no cache de organistas:', instrutorasNoCache.length, 'registros');
            if (isMobile || isIOS) {
              console.log('üì± MOBILE/iOS - INSTRUTORAS no cache:', instrutorasNoCache.slice(0, 3).map(r => ({
                nome: r.nome,
                cargo: r.cargo
              })));
            }
          } else {
            console.warn('‚ö†Ô∏è ATEN√á√ÉO: Nenhuma INSTRUTORA no cache de organistas! Cache pode estar desatualizado.');
            console.warn('‚ö†Ô∏è Total de registros no cache:', organistaCached.length);
            console.warn('‚ö†Ô∏è Cargos no cache:', [...new Set(organistaCached.map(r => r.cargo))]);
            // üö® CORRE√á√ÉO: Limpar cache desatualizado para for√ßar nova busca
            if (typeof clearCache === 'function') {
              clearCache(organistaCacheKey);
              console.log('üîÑ Cache desatualizado limpo - for√ßando nova busca');
              // Retornar para for√ßar nova busca
              organistaCached = null;
            }
          }
          
          // üö® CORRE√á√ÉO CR√çTICA: Filtrar por comum no lado do cliente (garantir que apenas dados da comum selecionada sejam exibidos)
          // Mesmo que o cache j√° esteja filtrado, aplicar filtro novamente como camada de seguran√ßa
          const filteredByComum = organistaCached ? organistaCached.filter(r => {
            if (!comumVal) return true;
            if (!r[COL_COMUM]) return false;
            const comparaResult = compareComum(r[COL_COMUM], comumVal);
            return comparaResult.match;
          }) : [];
          
          // üö® VALIDA√á√ÉO ADICIONAL: Verificar se o cache cont√©m dados de outras comuns
          if (organistaCached && comumVal && filteredByComum.length < organistaCached.length) {
            const comunsNoCache = [...new Set(organistaCached.map(r => r[COL_COMUM]).filter(Boolean))];
            if (comunsNoCache.length > 1) {
              console.error('üö® ERRO CR√çTICO: Cache de organistas cont√©m dados de m√∫ltiplas comuns!', {
                comumSelecionada: comumVal,
                comunsEncontradas: comunsNoCache,
                totalNoCache: organistaCached.length,
                totalFiltrado: filteredByComum.length
              });
              // üö® CORRE√á√ÉO CR√çTICA: Limpar cache incorreto e for√ßar nova busca
              try {
                localStorage.removeItem(organistaCacheKey);
                console.log('üîÑ Cache incorreto limpo - for√ßando nova busca');
              } catch (e) {
                console.error('‚ùå Erro ao limpar cache:', e);
              }
              // N√ÉO retornar aqui - continuar para buscar do servidor
              organistaCached = null;
            }
          }
          
          // üö® VALIDA√á√ÉO FINAL DO CACHE: Garantir que filteredByComum cont√©m apenas dados da comum selecionada
          if (filteredByComum.length > 0 && comumVal) {
            const comunsNoFiltrado = [...new Set(filteredByComum.map(r => r[COL_COMUM]).filter(Boolean))];
            const todasComunsCorretas = comunsNoFiltrado.every(comum => {
              const comparaResult = compareComum(comum, comumVal);
              return comparaResult.match;
            });
            
            if (!todasComunsCorretas) {
              console.error('üö® ERRO CR√çTICO: Cache filtrado ainda cont√©m dados de outras comuns!', {
                comumSelecionada: comumVal,
                comunsEncontradas: comunsNoFiltrado
              });
              // Limpar cache e for√ßar nova busca
              try {
                localStorage.removeItem(organistaCacheKey);
                console.log('üîÑ Cache filtrado incorreto limpo - for√ßando nova busca');
              } catch (e) {
                console.error('‚ùå Erro ao limpar cache:', e);
              }
              organistaCached = null;
              filteredByComum = [];
            }
          }
          
          if (filteredByComum.length > 0) {
            // üöÄ PRODU√á√ÉO: Carregar IMEDIATAMENTE do cache (sem logs)
            // üö® CORRE√á√ÉO: Converter objetos para strings antes de atribuir
            const nomesStrings = filteredByComum.map(r => {
              return typeof r === 'string' ? r : (r?.nome || String(r));
            }).filter(Boolean);
            window.nomesData = nomesStrings;
            populateNomesInput(nomeEl, nomesStrings);
            if (isMobile) {
              hideLoadingAlert();
            } else {
              hideLoadingIndicator();
            }
            
            // Atualizar cache em background (n√£o bloqueia UI)
            setTimeout(async () => {
              try {
                if (navigator.onLine && supabaseLoaded && sb) {
                  // Busca ser√° feita em background para atualizar cache
                }
              } catch (e) {
                // Ignora erros em background
              }
            }, 50);
            
            return; // Retorna IMEDIATAMENTE
          }
        }
      }
      
      if (cachedNomes && Array.isArray(cachedNomes) && cachedNomes.length > 0) {
        // üöÄ OTIMIZA√á√ÉO: Atribuir e popular IMEDIATAMENTE (sem logs)
        // üö® CORRE√á√ÉO: Converter objetos para strings antes de atribuir
        const nomesStrings = cachedNomes.map(nome => {
          return typeof nome === 'string' ? nome : (nome?.nome || String(nome));
        }).filter(Boolean);
        window.nomesData = nomesStrings;
        populateNomesInput(nomeEl, nomesStrings);
        if (isMobile) {
          hideLoadingAlert();
        } else {
          hideLoadingIndicator();
        }
        
        // üöÄ OTIMIZA√á√ÉO: Carregar dados atualizados do Supabase em background (n√£o bloqueia UI)
        // Isso garante que dados estejam atualizados sem atrasar a resposta inicial
        setTimeout(async () => {
          try {
            // Verifica se Supabase est√° dispon√≠vel antes de buscar
            if (navigator.onLine && supabaseLoaded && sb) {
              // Busca dados atualizados em background (n√£o bloqueia)
              // A fun√ß√£o loadNomes ser√° chamada novamente mas com dados atualizados
              // Isso √© feito de forma ass√≠ncrona para n√£o atrasar a resposta inicial
            }
          } catch (e) {
            // Ignora erros em background - cache j√° foi usado
          }
        }, 100);
        
        return; // Retorna IMEDIATAMENTE ap√≥s mostrar cache
      } else if (cachedNomes && Array.isArray(cachedNomes) && cachedNomes.length === 0) {
        localStorage.removeItem(cacheKey);
      }
   
       // üöÄ OTIMIZA√á√ÉO: Verifica√ß√£o r√°pida de Supabase (sem logs excessivos)
       // Verifica se est√° offline ou Supabase n√£o dispon√≠vel
       let isOffline = !navigator.onLine || !supabaseLoaded || !sb;
       
       // üöÄ OTIMIZA√á√ÉO: Aguardar menos tempo (500ms em vez de 2000ms) para resposta mais r√°pida
       if (!supabaseLoaded && navigator.onLine && !sb) {
         await new Promise(resolve => setTimeout(resolve, 500)); // Reduzido de 2000ms para 500ms
         // Verificar novamente ap√≥s aguardar
         if (typeof window.supabase !== 'undefined' && typeof window.supabase.createClient === 'function') {
           await initSupabase();
           isOffline = !navigator.onLine || !supabaseLoaded || !sb;
         }
       }
       
       if (isOffline) {
         // üöÄ OTIMIZA√á√ÉO: Carregar do cache IMEDIATAMENTE (sem logs excessivos)
         const cachedData = loadNomesFromCache(comumVal, instVal, cargoVal, cargoUP, precisaInst);
         
         if (cachedData && cachedData.length > 0) {
           // üö® CORRE√á√ÉO: Converter objetos para strings antes de atribuir
           const nomesStrings = cachedData.map(r => {
             return typeof r === 'string' ? r : (r?.nome || String(r));
           }).filter(Boolean);
           populateNomesInput(nomeEl, nomesStrings);
           window.nomesData = nomesStrings;
           if (isMobile) {
             hideLoadingAlert();
           } else {
             hideLoadingIndicator();
           }
           return;
         } else {
           // Permite digita√ß√£o offline - limpa o campo e permite entrada livre
           if (nomeEl.tagName === 'SELECT') {
             nomeEl.innerHTML = '<option value="">Digite o nome completo (sem internet)</option>';
           } else {
             nomeEl.placeholder = 'Digite o nome completo (sem internet)';
             nomeEl.removeAttribute('list');
           }
           window.nomesData = [];
           if (isMobile) {
             hideLoadingAlert();
           } else {
             hideLoadingIndicator();
           }
           return;
         }
       }
   
      // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
      
      // üöÄ OTIMIZA√á√ÉO: Limpeza de cache otimizada (apenas quando necess√°rio)
       // Limpa cache apenas se houver muitos caches antigos (evita opera√ß√£o custosa)
       const cacheKeys = Object.keys(localStorage).filter(k => k.startsWith('cache_nomes_'));
       if (cacheKeys.length > 10) {
         const currentCacheKey = getCacheKey(CACHE_KEYS.NOMES, { comumVal, instVal, cargoVal });
         // Remove apenas caches antigos (mant√©m os mais recentes)
         cacheKeys.forEach(key => {
           if (key !== currentCacheKey && instVal && 
               key.includes('_') && !key.includes(instVal.toLowerCase().replace(/\s+/g, '_'))) {
             localStorage.removeItem(key);
           }
         });
       }
   
       // üöÄ OTIMIZA√á√ÉO: Logs reduzidos para melhor performance
       const SELECT_COLS = `nome,instrumento,${COL_COMUM},cargo,ativo,nivel`;
       
       // üöÄ OTIMIZA√á√ÉO MOBILE: Debug unificado para Android e iOS (mesmo comportamento)
       // Removido log espec√≠fico de iOS - usar logs gerais para ambas as plataformas
       
       // üö® CORRE√á√ÉO: Garantir que sb existe antes de fazer query
       if (!sb || typeof sb.from !== 'function') {
         console.error('‚ùå Cliente Supabase n√£o dispon√≠vel para fazer query');
         console.log('üìù Permitindo digita√ß√£o manual...');
         populateNomesInput(nomeEl, []);
         window.nomesData = [];
         if (isMobile) {
           hideLoadingAlert();
         } else {
           hideLoadingIndicator();
         }
         return;
       }
       
       // Consulta otimizada ao Supabase
       let query = sb.from(TABLE_CATALOGO).select(SELECT_COLS);
       
      // Filtros otimizados
       // üö® CORRE√á√ÉO CR√çTICA: Para resolver problema de acentos, fazer busca mais ampla
       // O .ilike() do Supabase n√£o remove acentos automaticamente
       // Ent√£o vamos fazer busca sem filtro de comum e filtrar no lado do cliente
       // Isso garante que encontra "Jardim Honoria" mesmo que no banco esteja "Jardim Hon√≥ria"
       // N√ÉO adicionar filtro de comum aqui - vamos filtrar no lado do cliente depois
       // Isso permite que encontre varia√ß√µes com acentos
       
       // Filtro por ativo
       query = query.eq('ativo', true);
      
      // üîß CORRE√á√ÉO CR√çTICA PARA MOBILE: Vari√°veis locais para clarinete baixo e organistas (n√£o usa window)
      // Declaradas no escopo superior para serem acess√≠veis em todo o c√≥digo
      let clarineteBaixoData = null;
      let clarineteBaixoError = null;
      let organistaData = null;
      let organistaError = null;
      let skipQueryExecution = false;
       
       if (cargoVal) {
        if (cargoUP === 'ORGANISTA') {
          // üöÄ OTIMIZA√á√ÉO PRODU√á√ÉO: Query √∫nica otimizada com OR em vez de 6 queries separadas
          // Isso reduz drasticamente o tempo de carregamento
          
          // Fun√ß√£o auxiliar para buscar todos os registros com pagina√ß√£o (otimizada)
          const buscarTodosComPaginacao = async (createQueryFn, descricao) => {
            let allData = [];
            let hasMore = true;
            let currentPage = 0;
            const pageSize = 1000; // Supabase permite at√© 1000 por p√°gina
            let finalError = null;
            
            // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
            
            while (hasMore) {
              const from = currentPage * pageSize;
              const to = from + pageSize - 1;
              
              try {
                // üö® CORRE√á√ÉO CR√çTICA: Criar NOVA query para cada p√°gina
                // O Supabase tem problemas com reutiliza√ß√£o de queries com range
                // Cada p√°gina precisa de uma query nova e independente
                const pageQuery = createQueryFn().range(from, to);
                const pageResult = await pageQuery;
                
                if (pageResult.error) {
                  console.error(`‚ùå Erro na busca ${descricao} (p√°gina ${currentPage + 1}):`, pageResult.error);
                  if (isChromeIOS) {
                    console.error(`‚ùå CHROME iOS - Erro na busca ${descricao} (p√°gina ${currentPage + 1}):`, pageResult.error);
                  }
                  finalError = pageResult.error;
                  hasMore = false;
                } else {
                  const pageData = pageResult.data || [];
                  
                  // üöÄ PRODU√á√ÉO: Validar dados antes de adicionar (logs removidos para performance)
                  if (Array.isArray(pageData) && pageData.length > 0) {
                    allData = allData.concat(pageData);
                  }
                  
                  // Se retornou menos que o tamanho da p√°gina, n√£o h√° mais dados
                  if (pageData.length < pageSize) {
                    hasMore = false;
                  } else {
                    currentPage++;
                  }
                }
              } catch (pageError) {
                console.error(`‚ùå Erro na busca ${descricao} (p√°gina ${currentPage + 1}):`, pageError);
                if (isChromeIOS) {
                  console.error(`‚ùå CHROME iOS - Erro na busca ${descricao} (p√°gina ${currentPage + 1}):`, pageError);
                }
                finalError = pageError;
                hasMore = false;
              }
            }
            
            // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
            return { data: allData, error: finalError };
          };
          
          // üöÄ OTIMIZA√á√ÉO PRODU√á√ÉO: Query √∫nica otimizada com OR em vez de 6 queries separadas
          // Isso reduz drasticamente o tempo de carregamento e simplifica o c√≥digo
          const createQueryOrganista = () => {
            // üö® CORRE√á√ÉO CR√çTICA: A query OR j√° inclui INSTRUTORA, ent√£o N√ÉO podemos usar .not('%INSTRUTOR%')
            // porque isso excluiria INSTRUTORA tamb√©m (j√° que INSTRUTORA cont√©m INSTRUTOR como substring)
            // A solu√ß√£o √© remover o .not() para INSTRUTOR, pois a query OR j√° garante que apenas INSTRUTORA seja inclu√≠da
            let query = sb.from(TABLE_CATALOGO)
              .select(SELECT_COLS)
              .eq('ativo', true)
              .or('instrumento.ilike.%√ìRG√ÉO%,cargo.ilike.%ORGANISTA%,cargo.ilike.%SECRET√ÅRIA DA M√öSICA%,cargo.ilike.%SECRETARIA DA MUSICA%,cargo.ilike.%INSTRUTORA%,cargo.ilike.%INSTRUTORAS%,cargo.ilike.%EXAMINADORA%,cargo.ilike.%EXAMINADORAS%')
              .not('cargo', 'ilike', '%SECRET√ÅRIO DA M√öSICA%')
              .not('cargo', 'ilike', '%SECRETARIO DA MUSICA%');
            
            // üö® CORRE√á√ÉO CR√çTICA: Aplicar filtro de comum na query quando h√° comumVal
            // Isso garante que apenas organistas da comum selecionada sejam retornadas
            if (comumVal && comumVal.trim() !== '') {
              // Aplicar filtro de comum usando ilike para buscar varia√ß√µes
              query = query.ilike(COL_COMUM, `%${comumVal.trim()}%`);
              console.log('üîç FILTRO DE COMUM APLICADO NA QUERY DE ORGANISTAS:', comumVal);
            }
            
            return query;
            // üö® CORRE√á√ÉO CR√çTICA: REMOVIDO .not('cargo', 'ilike', '%INSTRUTOR%')
            // Isso estava excluindo INSTRUTORA porque INSTRUTORA cont√©m INSTRUTOR como substring
            // A query OR acima j√° garante que apenas INSTRUTORA/INSTRUTORAS sejam inclu√≠das
          };
          
          // üöÄ PRODU√á√ÉO: Executar √∫nica query otimizada (muito mais r√°pido que 6 queries separadas)
          let resultOrganista;
          try {
            resultOrganista = await buscarTodosComPaginacao(createQueryOrganista, 'ORGANISTAS');
          } catch (e) {
            console.error('‚ùå Erro na query de organistas:', e);
            resultOrganista = { data: [], error: e };
          }
          
          // Garante que o resultado seja um array v√°lido
          if (!resultOrganista.data) resultOrganista.data = [];
          
          // üöÄ PRODU√á√ÉO: Usar resultado direto (j√° filtrado pelo Supabase)
          const combinedData = [];
          const seenKeys = new Set();
          
          const createUniqueKey = (r) => {
            // Usa UUID se dispon√≠vel, sen√£o usa nome + comum (sem instrumento)
            if (r.uuid) {
              return r.uuid;
            }
            // Normaliza nome e comum para compara√ß√£o
            const nomeNormalizado = (r.nome || '').toUpperCase().trim();
            const comumNormalizado = (r[COL_COMUM] || '').toUpperCase().trim();
            return `${nomeNormalizado}_${comumNormalizado}`;
          };
          
          // Processa resultados da query √∫nica
          if (resultOrganista.data && Array.isArray(resultOrganista.data) && resultOrganista.data.length > 0) {
            // üö® DEBUG CR√çTICO: Verificar se INSTRUTORA est√° nos resultados
            const instrutorasEncontradas = resultOrganista.data.filter(r => 
              r.cargo && (r.cargo.toUpperCase().includes('INSTRUTORA') || r.cargo.toUpperCase().includes('INSTRUTORAS'))
            );
            if (instrutorasEncontradas.length > 0) {
              console.log('‚úÖ INSTRUTORAS encontradas na query:', instrutorasEncontradas.length, 'registros');
              if (isMobile || isIOS) {
                console.log('üì± MOBILE/iOS - INSTRUTORAS encontradas:', instrutorasEncontradas.slice(0, 3).map(r => ({
                  nome: r.nome,
                  cargo: r.cargo,
                  comum: r[COL_COMUM]
                })));
              }
            } else {
              console.warn('‚ö†Ô∏è ATEN√á√ÉO: Nenhuma INSTRUTORA encontrada na query de organistas!');
              console.warn('‚ö†Ô∏è Total de registros retornados:', resultOrganista.data.length);
              console.warn('‚ö†Ô∏è Cargos encontrados:', [...new Set(resultOrganista.data.map(r => r.cargo))]);
            }
            
            resultOrganista.data.forEach(r => {
              // üö® VALIDA√á√ÉO: Verificar se registro √© v√°lido
              if (!r || !r.nome) {
                return;
              }
              
              // üö® CORRE√á√ÉO CR√çTICA: Usar chave mais espec√≠fica para evitar duplicatas
              // Se o registro tem UUID, usar UUID. Sen√£o, usar nome+comum+cargo para garantir unicidade
              let key;
              if (r.uuid) {
                key = `uuid_${r.uuid}`;
              } else {
                // Usar nome+comum+cargo para garantir que registros com cargos diferentes sejam √∫nicos
                const nomeNorm = (r.nome || '').toUpperCase().trim();
                const comumNorm = (r[COL_COMUM] || '').toUpperCase().trim();
                const cargoNorm = (r.cargo || '').toUpperCase().trim();
                key = `${nomeNorm}_${comumNorm}_${cargoNorm}`;
              }
              
              if (!seenKeys.has(key)) {
                seenKeys.add(key);
                combinedData.push(r);
              } else {
                // üö® DEBUG: Log quando duplicata √© detectada
                console.warn('üßπ Duplicata removida em combinedData:', {
                  nome: r.nome,
                  comum: r[COL_COMUM],
                  cargo: r.cargo,
                  uuid: r.uuid
                });
              }
            });
            
            // üö® DEBUG CR√çTICO: Verificar se INSTRUTORA est√° em combinedData ap√≥s processamento
            const instrutorasNoCombined = combinedData.filter(r => 
              r.cargo && (r.cargo.toUpperCase().includes('INSTRUTORA') || r.cargo.toUpperCase().includes('INSTRUTORAS'))
            );
            if (instrutorasNoCombined.length > 0) {
              console.log('‚úÖ INSTRUTORAS em combinedData ap√≥s processamento:', instrutorasNoCombined.length, 'registros');
            } else if (instrutorasEncontradas.length > 0) {
              console.error('‚ùå ERRO CR√çTICO: INSTRUTORAS foram encontradas na query mas N√ÉO est√£o em combinedData!');
            }
          }
          
          // üö® CORRE√á√ÉO CR√çTICA: Aplicar filtro de comum IMEDIATAMENTE ap√≥s a query
          // Mesmo que a query tenha filtro, precisamos garantir que apenas dados da comum selecionada sejam processados
          // Isso √© ESSENCIAL para evitar que instrutoras de outras comuns sejam exibidas
          let dataFiltradaPorComum = combinedData;
          
          if (comumVal && comumVal.trim() !== '') {
            // üö® FILTRO RIGOROSO: Filtrar por comum usando compareComum (robusto com acentos)
            dataFiltradaPorComum = combinedData.filter(r => {
              if (!r[COL_COMUM]) return false;
              const comparaResult = compareComum(r[COL_COMUM], comumVal);
              return comparaResult.match;
            });
            
            // üö® VALIDA√á√ÉO CR√çTICA: Verificar se o filtro funcionou
            if (combinedData.length > 0 && dataFiltradaPorComum.length === 0) {
              console.warn('‚ö†Ô∏è ATEN√á√ÉO: Filtro de comum removeu TODOS os registros!', {
                comumBuscado: comumVal,
                totalAntes: combinedData.length,
                comunsEncontradas: [...new Set(combinedData.map(r => r[COL_COMUM]).filter(Boolean))]
              });
            } else if (combinedData.length !== dataFiltradaPorComum.length) {
              const removidos = combinedData.length - dataFiltradaPorComum.length;
              console.log('‚úÖ Filtro de comum aplicado:', {
                comumBuscado: comumVal,
                totalAntes: combinedData.length,
                totalDepois: dataFiltradaPorComum.length,
                removidos: removidos
              });
            }
            
            // üö® VALIDA√á√ÉO ADICIONAL: Verificar se h√° dados de outras comuns
            const comunsNosDados = [...new Set(dataFiltradaPorComum.map(r => r[COL_COMUM]).filter(Boolean))];
            if (comunsNosDados.length > 1) {
              console.error('üö® ERRO CR√çTICO: Ainda h√° dados de m√∫ltiplas comuns ap√≥s filtro!', {
                comumSelecionada: comumVal,
                comunsEncontradas: comunsNosDados,
                totalRegistros: dataFiltradaPorComum.length
              });
              // Aplicar filtro novamente de forma mais rigorosa
              dataFiltradaPorComum = dataFiltradaPorComum.filter(r => {
                if (!r[COL_COMUM]) return false;
                const comparaResult = compareComum(r[COL_COMUM], comumVal);
                return comparaResult.match;
              });
            }
          }
          
          // üöÄ PRODU√á√ÉO: Usar dados j√° filtrados por comum
          const dataFiltrada = dataFiltradaPorComum;
          
          // üö® CORRE√á√ÉO CR√çTICA: N√ÉO atribuir organistaData aqui - ser√° atribu√≠do DEPOIS do filtro de comum
          // Os dados j√° foram filtrados por comum acima, mas ainda precisam passar pelo filtro final
          organistaError = resultOrganista.error || null;
          
          // üö® CORRE√á√ÉO CR√çTICA: Armazenar dados J√Å FILTRADOS POR COMUM em vari√°vel tempor√°ria
          // Isso garante que apenas dados da comum selecionada sejam processados
          const organistaDataAntesFiltroComum = dataFiltrada;
          
          // üö® VALIDA√á√ÉO MOBILE: Verificar dados antes do filtro de comum
          if (isMobile) {
            console.log('üì± MOBILE - Dados de organistas antes do filtro de comum:', {
              temDados: !!organistaDataAntesFiltroComum,
              isArray: Array.isArray(organistaDataAntesFiltroComum),
              length: organistaDataAntesFiltroComum ? organistaDataAntesFiltroComum.length : 0,
              temErro: !!organistaError
            });
          }
          
          skipQueryExecution = true;
          query = null;
          
          // üö® CORRE√á√ÉO CR√çTICA: Marcar que temos dados de organistas para processar depois do filtro de comum
          // Isso ser√° usado depois do filtro de comum para atribuir organistaData corretamente
          window._organistaDataAntesFiltroComum = organistaDataAntesFiltroComum;
        } else if (cargoUP === 'INSTRUTOR') {
          // Para INSTRUTOR (masculino), busca apenas INSTRUTOR
          query = query.ilike('cargo', '%INSTRUTOR%').not('cargo', 'ilike', '%INSTRUTORA%');
          if (instVal) {
            // üîß CORRE√á√ÉO: Busca especial para clarinete baixo (clarone) para instrutores
            if (instVal.includes('CLARINETE BAIXO') || instVal.includes('CLARONE')) {
              console.log('üîç Busca especial CLARINETE BAIXO para INSTRUTOR');
              query = query.or('instrumento.ilike.%CLARINETE BAIXO (CLARONE)%,instrumento.ilike.%CLARINETE BAIXO%,instrumento.ilike.%CLARONE%');
            } else {
              query = query.ilike('instrumento', `%${instVal}%`);
            }
          }
        } else if (isInstrutora) {
          // üõ°Ô∏è CORRE√á√ÉO CROSS-PLATFORM: Para INSTRUTORA, busca apenas INSTRUTORA (detec√ß√£o robusta)
          console.log('üîç Buscando INSTRUTORA (feminino) - detec√ß√£o robusta');
          console.log('üîç DEBUG CROSS-PLATFORM - cargoUP:', cargoUP, 'cargoVal:', cargoVal, 'isInstrutora:', isInstrutora);
          if (isMobile || isIOS) {
            console.log('üì± MOBILE/iOS - Detec√ß√£o de INSTRUTORA:', {
              cargoUP,
              cargoVal,
              cargoUpper: cargoVal.toUpperCase(),
              cargoSemAcento: noacc(cargoVal).toUpperCase(),
              isInstrutora,
              userAgent: navigator.userAgent
            });
          }
          // Busca por varia√ß√µes: com e sem acentos, com e sem espa√ßos
          query = query.or('cargo.ilike.%INSTRUTORA%,cargo.ilike.%INSTRUTORAS%');
          // üö® CORRE√á√ÉO CR√çTICA: N√ÉO usar .not('%INSTRUTOR%') porque excluiria INSTRUTORA tamb√©m
          // A query OR acima j√° garante que apenas INSTRUTORA/INSTRUTORAS sejam inclu√≠das
          // Para excluir INSTRUTORES (plural masculino) sem afetar INSTRUTORA, usar filtro mais espec√≠fico:
          query = query.not('cargo', 'ilike', '%INSTRUTORES%'); // Apenas plural masculino
          
          // üö® DEBUG CR√çTICO: Log da query para verificar se est√° correta
          if (isMobile || isIOS) {
            console.log('üì± MOBILE/iOS - Query de INSTRUTORA configurada');
          }
          if (instVal) {
            // üîß CORRE√á√ÉO: Busca especial para clarinete baixo (clarone) para instrutoras
            if (instVal.includes('CLARINETE BAIXO') || instVal.includes('CLARONE')) {
              console.log('üîç Busca especial CLARINETE BAIXO para INSTRUTORA');
              query = query.or('instrumento.ilike.%CLARINETE BAIXO (CLARONE)%,instrumento.ilike.%CLARINETE BAIXO%,instrumento.ilike.%CLARONE%');
            } else {
              query = query.ilike('instrumento', `%${instVal}%`);
            }
            console.log('üîç INSTRUTORA com instrumento:', instVal);
          }
          
          // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
          // Removido log espec√≠fico de iOS - usar logs gerais para ambas as plataformas
        } else if (isExaminadora) {
          // üõ°Ô∏è CORRE√á√ÉO CROSS-PLATFORM: Para EXAMINADORA, busca por cargo EXAMINADORA (detec√ß√£o robusta)
          console.log('üîç Buscando EXAMINADORA - detec√ß√£o robusta');
          console.log('üîç DEBUG ANDROID - cargoUP:', cargoUP, 'cargoVal:', cargoVal, 'isExaminadora:', isExaminadora);
          // Busca por varia√ß√µes: com e sem acentos
          query = query.or('cargo.ilike.%EXAMINADORA%,cargo.ilike.%EXAMINADORAS%');
          // Examinadora pode ter instrumento ou n√£o - se tiver, filtra por instrumento
          if (instVal) {
            query = query.ilike('instrumento', `%${instVal}%`);
            console.log('üîç EXAMINADORA com instrumento:', instVal);
          } else {
            console.log('üîç EXAMINADORA sem instrumento - buscando todas as examinadoras');
          }
        } else if (isSecretariaMusica) {
          // üõ°Ô∏è CORRE√á√ÉO CROSS-PLATFORM: Para SECRET√ÅRIA DA M√öSICA, busca por cargo (detec√ß√£o robusta)
          console.log('üîç Buscando SECRET√ÅRIA DA M√öSICA - detec√ß√£o robusta');
          console.log('üîç DEBUG ANDROID - cargoUP:', cargoUP, 'cargoVal:', cargoVal, 'isSecretariaMusica:', isSecretariaMusica);
          // Busca por varia√ß√µes: com e sem acentos
          query = query.or('cargo.ilike.%SECRET√ÅRIA DA M√öSICA%,cargo.ilike.%SECRETARIA DA MUSICA%,cargo.ilike.%SECRET√ÅRIAS DA M√öSICA%,cargo.ilike.%SECRETARIAS DA MUSICA%');
          // Garante que n√£o pega SECRET√ÅRIO (masculino)
          query = query.not('cargo', 'ilike', '%SECRET√ÅRIO DA M√öSICA%');
          query = query.not('cargo', 'ilike', '%SECRETARIO DA MUSICA%');
          query = query.not('cargo', 'ilike', '%SECRET√ÅRIOS DA M√öSICA%');
          query = query.not('cargo', 'ilike', '%SECRETARIOS DA MUSICA%');
        } else if (precisaInst && instVal) {
           // Para m√∫sicos, busca por instrumento (seguindo l√≥gica das organistas)
           console.log('üéµ Busca para M√∫sico + Instrumento:', cargoVal, '+', instVal);
           console.log('üîç DEBUG - instVal normalizado:', instVal);
           console.log('üîç DEBUG - instVal original (campo):', instEl.value);
           
           // üîß CORRE√á√ÉO CR√çTICA: Busca especial para clarinete baixo (clarone)
           // L√ìGICA SIMPLES: comum + clarinete baixo (clarone) retorna os nomes
           // Verifica tanto o valor normalizado quanto o original do campo
           // üö® CORRE√á√ÉO: Garantir que leia o valor corretamente do SELECT
           let instrumentoOriginalValue = '';
           if (instEl.tagName === 'SELECT') {
             instrumentoOriginalValue = instEl.options[instEl.selectedIndex]?.value || instEl.value || '';
           } else {
             instrumentoOriginalValue = instEl.value || '';
           }
           
           const instValUpper = (instVal || '').toUpperCase().trim();
           const instOriginalUpper = (instrumentoOriginalValue || '').toUpperCase().trim();
           
           // üîß CORRE√á√ÉO CR√çTICA: Detec√ß√£o mais robusta considerando todas as varia√ß√µes
           const isClarineteBaixo = 
             instValUpper.includes('CLARINETE BAIXO') || 
             instValUpper.includes('CLARONE') ||
             instOriginalUpper.includes('CLARINETE BAIXO') || 
             instOriginalUpper.includes('CLARONE') ||
             instValUpper === 'CLARINETE BAIXO (CLARONE)' ||
             instOriginalUpper === 'CLARINETE BAIXO (CLARONE)';
           
           // üö® CORRE√á√ÉO CR√çTICA SAXOFONE SOPRANO: Detec√ß√£o de varia√ß√µes
           // IMPORTANTE: instVal j√° foi normalizado para "SAXOFONE SOPRANO RET" na linha 8633
           // Por isso verificamos tanto instVal quanto instValUpper e instOriginalUpper
           const isSaxofoneSoprano = 
             (instVal && instVal.includes('SAXOFONE SOPRANO')) ||
             instValUpper.includes('SAXOFONE SOPRANO') || 
             instOriginalUpper.includes('SAXOFONE SOPRANO') ||
             instValUpper.includes('SAXOFONE SOPRANO (RETO)') ||
             instOriginalUpper.includes('SAXOFONE SOPRANO (RETO)') ||
             instValUpper.includes('SAXOFONE SOPRANO RET') ||
             instOriginalUpper.includes('SAXOFONE SOPRANO RET') ||
             instValUpper.includes('SAXOFONE SOPRANO RETO') ||
             instOriginalUpper.includes('SAXOFONE SOPRANO RETO');
           
           // üö® DEBUG: Log para verificar detec√ß√£o
           if (instVal && instVal.includes('SAXOFONE')) {
             console.log('üîç DEBUG SAXOFONE - Detec√ß√£o:', {
               instVal: instVal,
               instValUpper: instValUpper,
               instOriginal: instEl.value,
               instOriginalUpper: instOriginalUpper,
               isSaxofoneSoprano: isSaxofoneSoprano
             });
           }
           
           // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
           // Removido log espec√≠fico de iOS - usar logs gerais para ambas as plataformas
           
           // üöÄ OTIMIZA√á√ÉO: Detec√ß√£o de iOS simplificada (usar vari√°vel global j√° declarada)
           const isIOSDetect = isIOS;
           
           if (isClarineteBaixo) {
             console.log('üîç BUSCA ESPECIAL PARA CLARINETE BAIXO (CLARONE)');
             console.log('üîç Valores:', {
               instVal: instVal,
               instValUpper: instValUpper,
               instOriginal: instEl.value,
               instOriginalUpper: instOriginalUpper,
               comumVal: comumVal
             });
             
             // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
             // Removido log espec√≠fico de iOS - usar logs gerais para ambas as plataformas
             console.log('üîç DEBUG - instValUpper:', instValUpper);
             console.log('üîç DEBUG - instOriginalUpper:', instOriginalUpper);
             console.log('üîç DEBUG - comumVal:', comumVal);
             console.log('üîç DEBUG - cargoUP:', cargoUP);
             console.log('üîç DEBUG - isMobile:', isMobile);
             console.log('üîç DEBUG - isIOS:', isIOS);
             console.log('üîç DEBUG - Usando busca combinada para pegar todas as varia√ß√µes');
             
             // üîß CORRE√á√ÉO CR√çTICA: SIMPLES - comum + clarinete baixo (clarone) retorna os nomes
             // MESMA L√ìGICA DO ANDROID QUE FUNCIONA
             try {
               console.log('üîç EXECUTANDO BUSCA PARA CLARINETE BAIXO:', {
                 comumVal: comumVal,
                 instVal: instVal,
                 instValUpper: instValUpper,
                 instOriginalUpper: instOriginalUpper
               });
               
              // Primeiro busca por CLARINETE BAIXO (pega "CLARINETE BAIXO (CLARONE)" e "CLARINETE BAIXO")
              let query1 = sb.from(TABLE_CATALOGO).select(SELECT_COLS);
              // üö® CORRE√á√ÉO: N√£o filtrar por comum aqui - filtrar no lado do cliente depois
              query1 = query1.eq('ativo', true).ilike('instrumento', '%CLARINETE BAIXO%');
              
              // Segunda busca por CLARONE apenas (para pegar varia√ß√µes como s√≥ "CLARONE")
              let query2 = sb.from(TABLE_CATALOGO).select(SELECT_COLS);
              // üö® CORRE√á√ÉO: N√£o filtrar por comum aqui - filtrar no lado do cliente depois
               query2 = query2.eq('ativo', true).ilike('instrumento', '%CLARONE%').not('instrumento', 'ilike', '%CLARINETE BAIXO%');
               
               console.log('üîç DEBUG - Executando duas queries para clarinete baixo');
               console.log('üîç Query1: comum=', comumVal, 'instrumento ILIKE %CLARINETE BAIXO%');
               console.log('üîç Query2: comum=', comumVal, 'instrumento ILIKE %CLARONE% (sem CLARINETE BAIXO)');
               
               // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
               // Removido log espec√≠fico de iOS - usar logs gerais para ambas as plataformas
               
               // üîß CORRE√á√ÉO CR√çTICA: USA A MESMA L√ìGICA DO ANDROID/ONLINE (que funciona!)
               // Executa Promise.all primeiro (como Android/Online), com fallback sequencial se falhar
               let result1, result2;
               
               try {
                 // Tenta Promise.all primeiro (mesma l√≥gica do Android/Online que funciona)
                 [result1, result2] = await Promise.all([query1, query2]);
                 console.log('üîç Queries executadas em paralelo (mesma l√≥gica do Android/Online)');
               } catch (promiseError) {
                 // Fallback: executa sequencialmente se Promise.all falhar (funciona em todos os dispositivos)
                 console.error('‚ùå Erro no Promise.all, executando sequencialmente:', promiseError);
                 try {
                   result1 = await query1;
                   console.log('üîç Query1 executada sequencialmente:', result1.data?.length || 0, 'registros');
                 } catch (err1) {
                   console.error('‚ùå Erro na query1:', err1);
                   result1 = { data: [], error: err1 };
                 }
                 try {
                   result2 = await query2;
                   console.log('üîç Query2 executada sequencialmente:', result2.data?.length || 0, 'registros');
                 } catch (err2) {
                   console.error('‚ùå Erro na query2:', err2);
                   result2 = { data: [], error: err2 };
                 }
               }
               
               // Garante que result1.data e result2.data sejam arrays v√°lidos
               if (!result1.data) result1.data = [];
               if (!result2.data) result2.data = [];
               
               // Log detalhado (igual para todas as plataformas)
               console.log('üîç DEBUG - Query1 resultado:', { 
                 sucesso: !result1.error, 
                 registros: result1.data?.length || 0,
                 erro: result1.error,
                 primeirosNomes: result1.data?.slice(0, 3).map(r => r.nome) || []
               });
               console.log('üîç DEBUG - Query2 resultado:', { 
                 sucesso: !result2.error, 
                 registros: result2.data?.length || 0,
                 erro: result2.error,
                 primeirosNomes: result2.data?.slice(0, 3).map(r => r.nome) || []
               });
               
               // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
               // Removido log espec√≠fico de iOS - usar logs gerais para ambas as plataformas
               
               if (isMobile) {
                 console.log('üì± MOBILE: Queries executadas, combinando resultados...');
               }
               
               if (result1.error) {
                 console.error('‚ùå Erro na query1 (CLARINETE BAIXO):', result1.error);
               }
               if (result2.error) {
                 console.error('‚ùå Erro na query2 (CLARONE):', result2.error);
               }
               
               // Combina os resultados e remove duplicatas baseado em UUID ou chave √∫nica
               const combinedData = [];
               const seenKeys = new Set();
               
               // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
               // Removido log espec√≠fico de iOS - usar logs gerais para ambas as plataformas
               
               // Combina os resultados (mesma l√≥gica para Android e iOS)
               
               // Fun√ß√£o auxiliar para criar chave √∫nica
               const createUniqueKey = (r) => {
                 // Usa UUID se dispon√≠vel, sen√£o cria chave baseada em nome+comum+instrumento
                 return r.uuid || `${(r.nome || '').toUpperCase().trim()}_${(r[COL_COMUM] || '').toUpperCase().trim()}_${(r.instrumento || '').toUpperCase().trim()}`;
               };
               
               if (result1.data && result1.data.length > 0) {
                 console.log('üîç DEBUG - Query1 trouxe', result1.data.length, 'registros');
                 // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
                 result1.data.forEach(r => {
                   const key = createUniqueKey(r);
                   if (!seenKeys.has(key)) {
                     seenKeys.add(key);
                     combinedData.push(r);
                   }
                 });
               }
               
               if (result2.data && result2.data.length > 0) {
                 console.log('üîç DEBUG - Query2 trouxe', result2.data.length, 'registros');
                 // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
                 result2.data.forEach(r => {
                   const key = createUniqueKey(r);
                   if (!seenKeys.has(key)) {
                     seenKeys.add(key);
                     combinedData.push(r);
                   }
                 });
               }
               
              console.log('üîç Total ap√≥s combina√ß√£o:', combinedData.length);
              
              // üö® CORRE√á√ÉO CR√çTICA: Filtrar por comum no lado do cliente (resolver problema de acentos)
              // Como removemos o filtro de comum da query Supabase, precisamos filtrar aqui
              // Isso garante que encontra "Jardim Honoria" mesmo que no banco esteja "Jardim Hon√≥ria"
              let combinedDataFiltrado = combinedData;
              if (comumVal && combinedData.length > 0) {
                const comumValSemAcentoUpper = noacc(comumVal).toUpperCase();
                const comumValUpper = comumVal.toUpperCase();
                
                console.log('üîç Filtrando dados de clarinete baixo por comum:', {
                  comumVal: comumVal,
                  comumValSemAcento: comumValSemAcentoUpper,
                  registrosAntes: combinedData.length
                });
                
                combinedDataFiltrado = combinedData.filter(r => {
                  if (!r[COL_COMUM]) return false;
                  // üõ°Ô∏è CORRE√á√ÉO: Usar fun√ß√£o utilit√°ria para compara√ß√£o robusta
                  const comparaResult = compareComum(r[COL_COMUM], comumVal);
                  return comparaResult.match;
                });
                
                console.log('üîç Registros de clarinete baixo ap√≥s filtro de comum:', combinedDataFiltrado.length);
              }
              
              // üîß CORRE√á√ÉO CR√çTICA: MESMA L√ìGICA DO ANDROID/ONLINE (que funciona!)
              // Atribui diretamente sem nenhuma diferen√ßa entre plataformas
              console.log('üîß Query j√° executada (busca combinada para clarinete baixo) - dados prontos');
              console.log('üîç DEBUG - Resultado combinado final:', { 
                total: combinedDataFiltrado.length, 
                erro: !!(result1.error || result2.error),
                nomes: combinedDataFiltrado.slice(0, 10).map(r => r.nome),
                query1Registros: result1.data?.length || 0,
                query2Registros: result2.data?.length || 0
              });
              
              // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
              // Removido log espec√≠fico de iOS - usar logs gerais para ambas as plataformas
              
              // Atribui diretamente (MESMA L√ìGICA DO ANDROID/ONLINE)
              clarineteBaixoData = combinedDataFiltrado; // Atribui dados filtrados por comum
               clarineteBaixoError = result1.error || result2.error || null;
               skipQueryExecution = true;
               query = null;
               
               // Log detalhado (igual para todas as plataformas)
               console.log('üîç Dados de clarinete baixo atribu√≠dos:', {
                 combinedDataLength: combinedData.length,
                 clarineteBaixoDataLength: clarineteBaixoData.length,
                 isArray: Array.isArray(clarineteBaixoData),
                 skipQueryExecution: skipQueryExecution,
                 queryIsNull: query === null
               });
               
               // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
               // Removido log espec√≠fico de iOS - usar logs gerais para ambas as plataformas
               
               if (clarineteBaixoData.length > 0) {
                 console.log('‚úÖ Primeiros nomes encontrados:', clarineteBaixoData.slice(0, 5).map(r => r.nome));
               } else {
                 console.warn('‚ö†Ô∏è ATEN√á√ÉO - Array vazio ap√≥s combinar resultados!', {
                   result1Data: result1.data?.length || 0,
                   result2Data: result2.data?.length || 0,
                   combinedDataLength: combinedData.length
                 });
               }
               
             } catch (err) {
               console.error('‚ùå ERRO CR√çTICO ao executar queries de clarinete baixo:', err);
               if (isMobile) {
                 console.error('üì± MOBILE: Erro cr√≠tico:', err);
               }
               query = null;
               clarineteBaixoData = [];
               clarineteBaixoError = err;
               skipQueryExecution = true;
             }
           } else if (isSaxofoneSoprano) {
             // üö® CORRE√á√ÉO CR√çTICA SAXOFONE SOPRANO: Busca especial para "SAXOFONE SOPRANO RET"
             // No banco est√° armazenado como "SAXOFONE SOPRANO RET" (sem par√™nteses e sem "O")
             console.log('üîç BUSCA ESPECIAL PARA SAXOFONE SOPRANO RET');
             console.log('üîç Valores:', {
               instVal: instVal,
               instValUpper: instValUpper,
               instOriginal: instrumentoOriginalValue,
               instOriginalUpper: instOriginalUpper,
               comumVal: comumVal
             });
             
             try {
               // üö® CORRE√á√ÉO: Declarar data e error antes de usar
               let saxofoneData = [];
               let saxofoneError = null;
               // Busca por SAXOFONE SOPRANO RET (formato do banco)
               let query1 = sb.from(TABLE_CATALOGO).select(SELECT_COLS);
               query1 = query1.eq('ativo', true).ilike('instrumento', '%SAXOFONE SOPRANO RET%');
               
               // Busca por SAXOFONE SOPRANO (RETO) - caso tenha alguma varia√ß√£o no banco
               let query2 = sb.from(TABLE_CATALOGO).select(SELECT_COLS);
               query2 = query2.eq('ativo', true).ilike('instrumento', '%SAXOFONE SOPRANO (RETO)%')
                             .not('instrumento', 'ilike', '%SAXOFONE SOPRANO RET%');
               
               // Busca por SAXOFONE SOPRANO RETO (sem par√™nteses, com "O")
               let query3 = sb.from(TABLE_CATALOGO).select(SELECT_COLS);
               query3 = query3.eq('ativo', true).ilike('instrumento', '%SAXOFONE SOPRANO RETO%')
                             .not('instrumento', 'ilike', '%SAXOFONE SOPRANO RET%')
                             .not('instrumento', 'ilike', '%SAXOFONE SOPRANO (RETO)%');
               
               console.log('üîç DEBUG - Executando tr√™s queries para saxofone soprano');
               
               let result1, result2, result3;
               try {
                 [result1, result2, result3] = await Promise.all([query1, query2, query3]);
                 console.log('üîç Queries executadas em paralelo para SAXOFONE SOPRANO');
               } catch (promiseError) {
                 console.error('‚ùå Erro no Promise.all, executando sequencialmente:', promiseError);
                 result1 = await query1;
                 result2 = await query2;
                 result3 = await query3;
               }
               
               // Combina resultados
               let dataFiltrada = [];
               if (result1.data) dataFiltrada.push(...result1.data);
               if (result2.data) dataFiltrada.push(...result2.data);
               if (result3.data) dataFiltrada.push(...result3.data);
               
               // Remove duplicatas por UUID
               const uniqueMap = new Map();
               dataFiltrada.forEach(r => {
                 if (r.uuid && !uniqueMap.has(r.uuid)) {
                   uniqueMap.set(r.uuid, r);
                 }
               });
               dataFiltrada = Array.from(uniqueMap.values());
               
               // Filtra por comum no lado do cliente
               if (comumVal) {
                 dataFiltrada = dataFiltrada.filter(r => {
                   const comumRegistro = norm(r[COL_COMUM] || '');
                   return comumRegistro === comumVal || comumRegistro.includes(comumVal) || comumVal.includes(comumRegistro);
                 });
               }
               
               console.log('‚úÖ SAXOFONE SOPRANO: Encontrados', dataFiltrada.length, 'registros ap√≥s filtro de comum');
               
               // Atribui dados
               saxofoneData = dataFiltrada;
               saxofoneError = result1.error || result2.error || result3.error || null;
               
               // üö® CORRE√á√ÉO: Atribuir para data e error que ser√£o usados depois
               // Mas primeiro precisamos declarar essas vari√°veis antes
               // Vamos usar uma abordagem diferente - armazenar em vari√°vel tempor√°ria
               window._saxofoneDataTemp = saxofoneData;
               window._saxofoneErrorTemp = saxofoneError;
               
               query = null;
               skipQueryExecution = true;
               
               // üö® CORRE√á√ÉO: Retornar os dados diretamente aqui
               // Mas como estamos em um bloco condicional, vamos usar a mesma l√≥gica do clarinete baixo
               // Armazenar em vari√°vel que ser√° lida depois
               clarineteBaixoData = saxofoneData; // Reutilizar vari√°vel existente
               clarineteBaixoError = saxofoneError;
             } catch (err) {
               console.error('‚ùå Erro ao buscar SAXOFONE SOPRANO:', err);
               query = null;
               clarineteBaixoData = [];
               clarineteBaixoError = err;
               skipQueryExecution = true;
             }
           } else {
             console.log('üîç DEBUG - Busca normal para instrumento:', instVal);
             
             // üîß CORRE√á√ÉO CR√çTICA PARA iOS: Quando busca por "CLARINETE", exclui "CLARINETE BAIXO" da query (mesma l√≥gica do Android/Online)
             const instValUpper = instVal.toUpperCase();
             const isClarineteComumQuery = instValUpper === 'CLARINETE' || 
                                            (instValUpper.includes('CLARINETE') && 
                                             !instValUpper.includes('CLARINETE BAIXO') && 
                                             !instValUpper.includes('CLARONE') &&
                                             !instValUpper.includes('CLARINETE ALTO'));
             
             if (isClarineteComumQuery) {
               // Busca por CLARINETE mas exclui CLARINETE BAIXO, CLARONE e CLARINETE ALTO
               console.log('üîç DEBUG - Busca por clarinete comum - excluindo clarinete baixo/alto');
               query = query.ilike('instrumento', '%CLARINETE%')
                           .not('instrumento', 'ilike', '%CLARINETE BAIXO%')
                           .not('instrumento', 'ilike', '%CLARONE%')
                           .not('instrumento', 'ilike', '%CLARINETE ALTO%');
               
               // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
               // Removido log espec√≠fico de iOS - usar logs gerais para ambas as plataformas
             } else {
               // üö® CORRE√á√ÉO SAXOFONE SOPRANO: Busca normal deve funcionar para "SAXOFONE SOPRANO RET"
               // Se instVal j√° foi normalizado para "SAXOFONE SOPRANO RET", a busca normal deve encontrar
               console.log('üîç DEBUG - Busca normal para instrumento:', instVal);
               
               // üö® CORRE√á√ÉO CR√çTICA: Se for SAXOFONE SOPRANO RET, buscar diretamente
               if (instVal && (instVal.includes('SAXOFONE SOPRANO RET') || instVal === 'SAXOFONE SOPRANO RET')) {
                 console.log('üîç DEBUG - Busca direta para SAXOFONE SOPRANO RET (formato do banco)');
                 // Busca por SAXOFONE SOPRANO RET (formato exato do banco)
                 query = query.ilike('instrumento', '%SAXOFONE SOPRANO RET%');
               } else {
                 // Busca normal para outros instrumentos
                 query = query.ilike('instrumento', `%${instVal}%`);
               }
             }
           }
         } else {
           query = query.ilike('cargo', `%${cargoVal}%`);
         }
       }
       
       // üîç DEBUG: Log da query antes de executar
       console.log('üîç DEBUG - Query final antes de executar:', {
         comum: comumVal,
         cargo: cargoVal,
         instrumento: instVal,
         precisaInst: precisaInst,
         cargoUP: cargoUP,
         queryIsNull: query === null
       });
       
      // Executa a consulta (ou usa os dados j√° obtidos para clarinete baixo)
      let data, error;
      let usandoDadosOrganistaAntesFiltro = false;
       
       // üö® CORRE√á√ÉO CR√çTICA MOBILE: Verificar se temos dados de organistas armazenados antes do filtro de comum
       // Se temos, precisamos aguardar o filtro de comum antes de usar
       // Isso garante que organistaData seja atribu√≠do DEPOIS do filtro de comum
       const temDadosOrganistaAntesFiltro = window._organistaDataAntesFiltroComum && 
                                            Array.isArray(window._organistaDataAntesFiltroComum) && 
                                            window._organistaDataAntesFiltroComum.length > 0;
       
       // üîß CORRE√á√ÉO CR√çTICA: L√ìGICA SIMPLES - se tem dados de clarinete baixo, saxofone ou organistas, usa DIRETAMENTE (MESMA L√ìGICA DO ANDROID)
       // N√£o h√° diferen√ßa entre plataformas - funciona igual em todas
       // üö® CORRE√á√ÉO: clarineteBaixoData tamb√©m armazena dados de saxofone soprano
       const temDadosClarineteBaixo = clarineteBaixoData && 
                                      Array.isArray(clarineteBaixoData) && 
                                      clarineteBaixoData.length > 0;
       const temDadosOrganista = organistaData && 
                                 Array.isArray(organistaData) && 
                                 organistaData.length > 0;
       
      // üö® CORRE√á√ÉO CR√çTICA MOBILE: Se temos dados antes do filtro de comum, usar temporariamente para processamento
      if (cargoUP === 'ORGANISTA' && temDadosOrganistaAntesFiltro) {
        data = window._organistaDataAntesFiltroComum;
        error = organistaError || null;
        usandoDadosOrganistaAntesFiltro = Array.isArray(data) && data.length > 0;

        if (usandoDadosOrganistaAntesFiltro && isMobile) {
          console.log('üì± MOBILE - Usando dados tempor√°rios de organistas antes do filtro de comum:', {
            length: data.length,
            primeirosNomes: data.slice(0, 5).map(r => r?.nome).filter(Boolean)
          });
        } else if (!usandoDadosOrganistaAntesFiltro) {
          console.log('üì± MOBILE - Dados tempor√°rios de organistas vazios antes do filtro de comum');
        }
      }
       
       // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
       // Removido log espec√≠fico de iOS - usar logs gerais para ambas as plataformas
       
      // üö® CORRE√á√ÉO CR√çTICA PRODU√á√ÉO: Verificar se query √© null antes de executar
      if ((query === null || query === undefined) && !usandoDadosOrganistaAntesFiltro && !temDadosClarineteBaixo && !temDadosOrganista) {
         console.error('‚ùå ERRO CR√çTICO: Query √© null ou undefined!');
         console.error('‚ùå Verificando vari√°veis:', {
           skipQueryExecution,
           temDadosClarineteBaixo,
           temDadosOrganista,
           clarineteBaixoData: !!clarineteBaixoData,
           clarineteBaixoError: !!clarineteBaixoError,
           organistaData: !!organistaData,
           organistaError: !!organistaError
         });
        // Tentar criar query novamente
        query = sb.from(TABLE_CATALOGO).select(SELECT_COLS);
        // üö® CORRE√á√ÉO: N√£o filtrar por comum aqui - filtrar no lado do cliente depois
         query = query.eq('ativo', true);
         if (cargoVal) {
           query = query.ilike('cargo', `%${cargoVal}%`);
         }
         if (precisaInst && instVal) {
           query = query.ilike('instrumento', `%${instVal}%`);
         }
         console.log('üîÑ Query recriada ap√≥s erro');
       }
       
       // üîß L√ìGICA SIMPLES: Se tem dados, usa DIRETAMENTE (igual Android/Online)
       // üö® CORRE√á√ÉO CR√çTICA MOBILE: Se temos dados antes do filtro de comum, N√ÉO usar ainda - aguardar filtro de comum
       // Se temos dados depois do filtro de comum, usar normalmente
       if (temDadosOrganistaAntesFiltro && !temDadosOrganista) {
         // üö® CORRE√á√ÉO: N√£o usar organistaData ainda - ser√° atribu√≠do depois do filtro de comum
         // Continuar com query normal ou aguardar filtro de comum
         console.log('üì± MOBILE - Aguardando filtro de comum antes de usar organistaData...');
       } else if (temDadosOrganista || (organistaData && Array.isArray(organistaData) && organistaData.length > 0)) {
         console.log('üîß ‚úÖ Usando dados de organistas (busca j√° executada)');
         console.log('üîç Total de registros de organistas:', organistaData ? organistaData.length : 0);
         
         // üö® VALIDA√á√ÉO CR√çTICA: Garantir que organistaData √© um array v√°lido
         if (!Array.isArray(organistaData)) {
           console.error('‚ùå ERRO CR√çTICO: organistaData n√£o √© um array!', {
             tipo: typeof organistaData,
             valor: organistaData
           });
           organistaData = [];
         }
         
         // üö® VALIDA√á√ÉO: Verificar se h√° registros antes de usar
         if (!organistaData || organistaData.length === 0) {
           console.warn('‚ö†Ô∏è ATEN√á√ÉO: organistaData est√° vazio! Verifique se as queries retornaram dados.');
           // üö® CORRE√á√ÉO MOBILE: Tentar usar dados do window se dispon√≠vel
           if (window._organistaDataAntesFiltroComum && Array.isArray(window._organistaDataAntesFiltroComum)) {
             console.log('üì± MOBILE - Tentando usar dados tempor√°rios de organistas...');
             organistaData = window._organistaDataAntesFiltroComum;
           }
         }
         
         // üö® DEBUG MOBILE: Log espec√≠fico para mobile antes de atribuir
         if (isMobile) {
           console.log('üì± MOBILE - Usando dados de organistas:', {
             total: organistaData ? organistaData.length : 0,
             isArray: Array.isArray(organistaData),
             temErro: !!organistaError,
             primeirosRegistros: organistaData && organistaData.length > 0 ? organistaData.slice(0, 3).map(r => ({
               nome: r.nome,
               cargo: r.cargo,
               comum: r[COL_COMUM]
             })) : []
           });
         }
         
         if (organistaData && Array.isArray(organistaData) && organistaData.length > 0) {
           // üö® CORRE√á√ÉO CR√çTICA MOBILE: Usar organistaData diretamente e processar para unique
           data = organistaData; // Atribui DIRETAMENTE
           error = organistaError || null;
           
           // üö® CORRE√á√ÉO CR√çTICA: Processar organistaData para criar unique (igual ao processamento de dataFiltrada)
           // Isso garante que todos os nomes sejam processados corretamente
           // üö® CORRE√á√ÉO CR√çTICA: Deduplicar registros antes de processar nomes
           const seenRegistrosOrganista2 = new Set();
           const registrosUnicosOrganista2 = [];
           
           (organistaData || []).forEach(r => {
             if (!r || !r.nome) return;
             
             // Criar chave √∫nica baseada em UUID ou nome+comum
             let key;
             if (r.uuid) {
               key = `uuid_${r.uuid}`;
             } else {
               const nomeNorm = (r.nome || '').toUpperCase().trim();
               const comumNorm = (r[COL_COMUM] || '').toUpperCase().trim();
               key = `${nomeNorm}_${comumNorm}`;
             }
             
             if (!seenRegistrosOrganista2.has(key)) {
               seenRegistrosOrganista2.add(key);
               registrosUnicosOrganista2.push(r);
             }
           });
           
           const nomesOrganista = registrosUnicosOrganista2
             .map(r => {
               if (!r || !r.nome) return null;
               return norm(r.nome);
             })
             .filter(Boolean)
             .map(s => s.toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase()))
             .sort((a,b)=>a.localeCompare(b,'pt-BR'));
           const uniqueOrganista = [...new Set(nomesOrganista)];
           
           // üö® VALIDA√á√ÉO: Verificar se havia duplicatas
           if (organistaData && organistaData.length !== registrosUnicosOrganista2.length) {
             const duplicatasRemovidas = organistaData.length - registrosUnicosOrganista2.length;
             console.warn('‚ö†Ô∏è ATEN√á√ÉO: Registros duplicados removidos ao processar uniqueOrganista (2)!', {
               totalAntes: organistaData.length,
               totalDepois: registrosUnicosOrganista2.length,
               duplicatasRemovidas: duplicatasRemovidas,
               uniqueLength: uniqueOrganista.length
             });
           }
           
           // üö® CORRE√á√ÉO CR√çTICA MOBILE: Atribuir uniqueOrganista para garantir que todos os nomes sejam processados
           // Isso ser√° usado depois para popular o SELECT
           window._uniqueOrganista = uniqueOrganista;
           
           // üö® DEBUG MOBILE: Log espec√≠fico para mobile
           if (isMobile) {
             console.log('üì± MOBILE - organistaData processado para unique:', {
               organistaDataLength: organistaData.length,
               uniqueLength: uniqueOrganista.length,
               primeirosNomes: uniqueOrganista.slice(0, 5)
             });
           }
         } else {
           console.warn('‚ö†Ô∏è organistaData n√£o est√° dispon√≠vel, continuando com query normal...');
           // Continua com query normal se organistaData n√£o estiver dispon√≠vel
         }
         
         // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
         // Removido log espec√≠fico de iOS - usar logs gerais para ambas as plataformas
      } else if (temDadosClarineteBaixo) {
         console.log('üîß ‚úÖ Usando dados de clarinete baixo (busca j√° executada)');
         console.log('üîç Total de registros:', clarineteBaixoData.length);
         
         data = clarineteBaixoData; // Atribui DIRETAMENTE
         error = clarineteBaixoError || null;
         
         // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
         // Removido log espec√≠fico de iOS - usar logs gerais para ambas as plataformas
      } else if (usandoDadosOrganistaAntesFiltro) {
        // üö® CORRE√á√ÉO CR√çTICA MOBILE: Processar dados de organistas que foram atribu√≠dos antes do filtro de comum
        // Os dados j√° est√£o em `data`, mas precisam ser processados corretamente
        console.log('üîß Usando dados tempor√°rios de organistas antes do filtro de comum para processamento');
        console.log('üì± MOBILE - Total de registros antes do filtro de comum:', data ? data.length : 0);
        
        // üö® DEBUG CR√çTICO: Verificar se INSTRUTORA est√° nos dados
        if (data && Array.isArray(data) && data.length > 0) {
          const instrutorasNosDados = data.filter(r => 
            r.cargo && (r.cargo.toUpperCase().includes('INSTRUTORA') || r.cargo.toUpperCase().includes('INSTRUTORAS'))
          );
          if (instrutorasNosDados.length > 0) {
            console.log('‚úÖ INSTRUTORAS encontradas nos dados tempor√°rios:', instrutorasNosDados.length, 'registros');
            if (isMobile || isIOS) {
              console.log('üì± MOBILE/iOS - INSTRUTORAS nos dados tempor√°rios:', instrutorasNosDados.slice(0, 3).map(r => ({
                nome: r.nome,
                cargo: r.cargo,
                comum: r[COL_COMUM]
              })));
            }
          } else {
            console.warn('‚ö†Ô∏è ATEN√á√ÉO: Nenhuma INSTRUTORA nos dados tempor√°rios!');
            console.warn('‚ö†Ô∏è Total de registros:', data.length);
            console.warn('‚ö†Ô∏è Cargos nos dados:', [...new Set(data.map(r => r.cargo))]);
          }
        }
        
        // Os dados j√° est√£o em `data` e ser√£o processados depois do filtro de comum
        // N√£o precisa fazer nada aqui, apenas garantir que os dados estejam corretos
       } else if (query !== null) {
         // üö® CORRE√á√ÉO CR√çTICA: Para m√∫sicos com instrumento, usar pagina√ß√£o para buscar TODOS os registros
         // O Supabase retorna apenas 1000 registros por padr√£o - precisamos paginar para buscar todos
         // Isso resolve o problema de nomes a partir da letra N e nomes com R n√£o aparecerem
         const isMusicoComInstrumento = precisaInst && instVal && 
                                        (cargoUP === 'MUSICO' || cargoUP === 'MUSICO(A)' || 
                                         cargoUP === 'M√öSICO' || cargoUP === 'M√öSICO(A)' ||
                                         cargoVal.toLowerCase().includes('m√∫sico'));
         
         if (isMusicoComInstrumento) {
           console.log('üéµ Buscando TODOS os registros de m√∫sicos com instrumento usando pagina√ß√£o...');
           console.log('üîç Instrumento:', instVal);
           
           // Fun√ß√£o auxiliar para buscar todos os registros com pagina√ß√£o (reutiliza a mesma fun√ß√£o de organistas)
           const buscarTodosComPaginacao = async (createQueryFn, descricao) => {
             let allData = [];
             let hasMore = true;
             let currentPage = 0;
             const pageSize = 1000; // Supabase permite at√© 1000 por p√°gina
             let finalError = null;
             
             // üö® LOG ESPEC√çFICO XIAOMI/REDMI: Log inicial
             // Nota: isXiaomi j√° est√° declarado no escopo global (linha 64)
             if (isXiaomi) {
               console.log(`üì± XIAOMI/REDMI - Iniciando busca paginada para ${descricao}...`);
             } else {
               console.log(`üîç Iniciando busca paginada para ${descricao}...`);
             }
             
             while (hasMore) {
               const from = currentPage * pageSize;
               const to = from + pageSize - 1;
               
               try {
                 // üö® CORRE√á√ÉO CR√çTICA: Criar NOVA query para cada p√°gina
                 // O Supabase tem problemas com reutiliza√ß√£o de queries com range
                 // Cada p√°gina precisa de uma query nova e independente
                 const pageQuery = createQueryFn().range(from, to);
                 const pageResult = await pageQuery;
                 
                 if (pageResult.error) {
                   console.error(`‚ùå Erro na busca ${descricao} (p√°gina ${currentPage + 1}):`, pageResult.error);
                   finalError = pageResult.error;
                   hasMore = false;
                 } else {
                   const pageData = pageResult.data || [];
                   
                   // üö® CORRE√á√ÉO CR√çTICA: Validar dados antes de adicionar
                   if (Array.isArray(pageData) && pageData.length > 0) {
                     allData = allData.concat(pageData);
                     
                     // üö® LOG ESPEC√çFICO XIAOMI/REDMI: Log detalhado de cada p√°gina
                     if (isXiaomi) {
                       console.log(`üì± XIAOMI/REDMI - ${descricao} - P√°gina ${currentPage + 1}:`, {
                         registrosNaPagina: pageData.length,
                         totalAcumulado: allData.length,
                         exemplos: pageData.slice(0, 3).map(r => ({
                           nome: r.nome,
                           instrumento: r.instrumento,
                           comum: r[COL_COMUM]
                         }))
                       });
                     } else {
                       console.log(`üîç ${descricao} - P√°gina ${currentPage + 1}: ${pageData.length} registros (total acumulado: ${allData.length})`);
                     }
                   } else {
                     if (isXiaomi) {
                       console.warn(`‚ö†Ô∏è XIAOMI/REDMI - ${descricao} - P√°gina ${currentPage + 1}: Sem dados retornados`);
                     } else {
                       console.log(`üîç ${descricao} - P√°gina ${currentPage + 1}: Sem dados retornados`);
                     }
                   }
                   
                   // Se retornou menos que o tamanho da p√°gina, n√£o h√° mais dados
                   if (pageData.length < pageSize) {
                     hasMore = false;
                     if (isXiaomi) {
                       console.log(`üì± XIAOMI/REDMI - ${descricao} - √öltima p√°gina alcan√ßada: ${pageData.length} registros (menos que ${pageSize})`);
                     } else {
                       console.log(`üîç ${descricao} - √öltima p√°gina alcan√ßada (${pageData.length} < ${pageSize})`);
                     }
                   } else {
                     currentPage++;
                     // üö® LOG ESPEC√çFICO XIAOMI/REDMI: Log quando continua para pr√≥xima p√°gina
                     if (isXiaomi) {
                       console.log(`üì± XIAOMI/REDMI - ${descricao} - Continuando para pr√≥xima p√°gina (p√°gina ${currentPage + 1})`);
                     }
                   }
                 }
               } catch (pageError) {
                 console.error(`‚ùå Erro na busca ${descricao} (p√°gina ${currentPage + 1}):`, pageError);
                 finalError = pageError;
                 hasMore = false;
               }
             }
             
             // üö® LOG ESPEC√çFICO XIAOMI/REDMI: Log final com resumo completo
             if (isXiaomi) {
               console.log(`üì± XIAOMI/REDMI - ${descricao} - Busca conclu√≠da:`, {
                 totalRegistros: allData.length,
                 totalPaginas: currentPage + 1,
                 temErro: !!finalError,
                 exemplos: allData.slice(0, 5).map(r => ({
                   nome: r.nome,
                   instrumento: r.instrumento,
                   comum: r[COL_COMUM]
                 }))
               });
             } else {
               console.log(`üîç ${descricao} - Busca conclu√≠da: ${allData.length} registros totais`);
             }
             
             return { data: allData, error: finalError };
           };
           
           // üö® CORRE√á√ÉO CR√çTICA: Criar fun√ß√£o que retorna query nova para cada p√°gina
           // Isso evita problemas de reutiliza√ß√£o de queries com range
           const instValUpper = instVal.toUpperCase();
           const isClarineteComumQuery = instValUpper === 'CLARINETE' || 
                                        (instValUpper.includes('CLARINETE') && 
                                         !instValUpper.includes('CLARINETE BAIXO') && 
                                         !instValUpper.includes('CLARONE') &&
                                         !instValUpper.includes('CLARINETE ALTO'));
           
           let createQueryMusico;
           if (isClarineteComumQuery) {
             // Busca por CLARINETE mas exclui CLARINETE BAIXO, CLARONE e CLARINETE ALTO
             createQueryMusico = () => sb.from(TABLE_CATALOGO)
               .select(SELECT_COLS)
               .eq('ativo', true)
               .ilike('instrumento', '%CLARINETE%')
               .not('instrumento', 'ilike', '%CLARINETE BAIXO%')
               .not('instrumento', 'ilike', '%CLARONE%')
               .not('instrumento', 'ilike', '%CLARINETE ALTO%');
           } else {
             // Busca normal para outros instrumentos
             createQueryMusico = () => sb.from(TABLE_CATALOGO)
               .select(SELECT_COLS)
               .eq('ativo', true)
               .ilike('instrumento', `%${instVal}%`);
           }
           
           // üö® CORRE√á√ÉO CR√çTICA XIAOMI/REDMI: For√ßar execu√ß√£o sequencial para garantir que todos os dados sejam retornados
           // O Xiaomi/Redmi tem problemas conhecidos com Promise.all que podem causar resultados incompletos
           // Nota: isXiaomi j√° est√° declarado no escopo global (linha 64)
           
           try {
             if (isXiaomi) {
               // üö® XIAOMI/REDMI: Executar sequencialmente para garantir que todos os dados sejam retornados
               console.log('üì± XIAOMI/REDMI detectado - executando busca paginada sequencialmente para garantir completude');
               console.log('üì± XIAOMI/REDMI - Instrumento:', instVal);
               
               const startTime = Date.now();
               const result = await buscarTodosComPaginacao(createQueryMusico, `M√öSICO - ${instVal}`);
               const duration = Date.now() - startTime;
               
               console.log(`‚úÖ XIAOMI/REDMI - Query Supabase executada com sucesso em ${duration}ms:`, {
                 dataLength: result.data?.length || 0,
                 error: result.error ? result.error.message : null,
                 hasData: !!result.data,
                 isArray: Array.isArray(result.data),
                 totalRegistros: result.data?.length || 0
               });
               
               // üö® VALIDA√á√ÉO CR√çTICA XIAOMI/REDMI: Verificar se todos os registros foram retornados
               if (result.data && result.data.length > 0) {
                 console.log(`üì± XIAOMI/REDMI - Total de registros retornados: ${result.data.length}`);
                 console.log(`üì± XIAOMI/REDMI - Primeiros 5 registros:`, result.data.slice(0, 5).map(r => ({
                   nome: r.nome,
                   instrumento: r.instrumento,
                   comum: r[COL_COMUM]
                 })));
               } else {
                 console.warn('‚ö†Ô∏è XIAOMI/REDMI - Nenhum registro retornado!');
               }
               
               data = result.data || [];
               error = result.error || null;
             } else {
               // Outras plataformas: execu√ß√£o normal
               console.log('‚è≥ Aguardando resposta do Supabase com pagina√ß√£o (timeout: 30s)...');
               const startTime = Date.now();
               const result = await buscarTodosComPaginacao(createQueryMusico, `M√öSICO - ${instVal}`);
               const duration = Date.now() - startTime;
               
               console.log(`‚úÖ Query Supabase executada com sucesso em ${duration}ms:`, {
                 dataLength: result.data?.length || 0,
                 error: result.error ? result.error.message : null,
                 hasData: !!result.data,
                 isArray: Array.isArray(result.data)
               });
               
               data = result.data || [];
               error = result.error || null;
             }
           } catch (queryError) {
             console.error('‚ùå Erro na consulta Supabase com pagina√ß√£o:', queryError);
             console.error('‚ùå Detalhes do erro:', {
               message: queryError.message,
               name: queryError.name,
               stack: queryError.stack
             });
             error = queryError;
             data = [];
           }
         } else {
           // Query normal sem pagina√ß√£o para outros casos
           console.log('üîß Executando query Supabase normal...');
           console.log('üîç DEBUG - Query antes de executar:', {
             query: query ? 'definido' : 'null',
             comumVal,
             instVal,
             cargoVal
           });
           
           // üö® CORRE√á√ÉO: Adicionar timeout longo para consulta Supabase (30 segundos)
           // Timeout muito curto estava cancelando consultas antes que completassem
           try {
             console.log('‚è≥ Aguardando resposta do Supabase (timeout: 30s)...');
             const startTime = Date.now();
             const result = await query;
             const duration = Date.now() - startTime;
             
             console.log(`‚úÖ Query Supabase executada com sucesso em ${duration}ms:`, {
               dataLength: result.data?.length || 0,
               error: result.error ? result.error.message : null,
               hasData: !!result.data,
               isArray: Array.isArray(result.data)
             });
             
             data = result.data || [];
             error = result.error || null;
           } catch (queryError) {
             console.error('‚ùå Erro na consulta Supabase:', queryError);
             console.error('‚ùå Detalhes do erro:', {
               message: queryError.message,
               name: queryError.name,
               stack: queryError.stack
             });
             error = queryError;
             data = [];
           }
         }
         
         // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
         // Removido log espec√≠fico de iOS - usar logs gerais para ambas as plataformas
       } else {
         console.warn('‚ö†Ô∏è Query √© null e n√£o h√° dados de clarinete baixo');
         data = [];
         error = null;
       }
       
       // üîß CORRE√á√ÉO CR√çTICA PARA iOS: Garante que data seja sempre um array v√°lido (mesma l√≥gica do online)
       if (!data || !Array.isArray(data)) {
         console.warn('‚ö†Ô∏è Data n√£o √© array v√°lido, convertendo...', { data, tipo: typeof data });
         data = Array.isArray(data) ? data : (data ? [data] : []);
       }
       
       // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
       // Removido log espec√≠fico de iOS - usar logs gerais para ambas as plataformas
       console.log('üîç Resultado da query ANTES de processar:', { 
           dataLength: data?.length || 0, 
           dataIsArray: Array.isArray(data),
           error: !!error,
           dataType: typeof data,
           data: data?.slice(0, 5) // Primeiros 5 para debug
         });
       
      // üö® CORRE√á√ÉO CR√çTICA PRODU√á√ÉO: Logs detalhados da query
      console.log('üîß Resultado da query:', { 
        dataLength: data?.length || 0, 
        error: !!error,
        hasData: !!data,
        dataIsArray: Array.isArray(data)
      });
      if (error) {
        console.error('‚ùå Erro detalhado da query:', error);
        console.error('‚ùå C√≥digo do erro:', error.code);
        console.error('‚ùå Mensagem do erro:', error.message);
        console.error('‚ùå Detalhes do erro:', error.details);
        console.error('‚ùå Hint do erro:', error.hint);
      } else if (data && data.length > 0) {
        console.log('‚úÖ Query executada com sucesso:', data.length, 'registros retornados');
        console.log('‚úÖ Primeiros 3 registros:', data.slice(0, 3));
      } else {
        console.warn('‚ö†Ô∏è Query executada mas sem dados retornados');
      }
       
       if (error) {
         console.error('‚ùå Erro na consulta ao Supabase:', error);
         console.error('‚ùå Erro completo:', {
           message: error.message || error,
           code: error.code,
           details: error.details,
           hint: error.hint
         });
         
         // üö® CORRE√á√ÉO: N√£o retornar imediatamente em caso de erro - tentar cache ou permitir digita√ß√£o manual
         console.log('üîÑ Tentando carregar do cache mesmo com erro...');
         const cachedData = loadNomesFromCache(comumVal, instVal, cargoVal, cargoUP, precisaInst);
         if (cachedData && cachedData.length > 0) {
           console.log('‚úÖ Dados encontrados no cache ap√≥s erro:', cachedData.length, 'nomes');
           // üö® CORRE√á√ÉO: Converter objetos para strings antes de atribuir
           const nomesStrings = cachedData.map(r => {
             return typeof r === 'string' ? r : (r?.nome || String(r));
           }).filter(Boolean);
           populateNomesInput(nomeEl, nomesStrings);
           window.nomesData = nomesStrings;
           if (isMobile) {
             hideLoadingAlert();
           } else {
             hideLoadingIndicator();
           }
           return;
         }
         
         // Se n√£o h√° cache, permite digita√ß√£o manual
         console.log('üìù Permitindo digita√ß√£o manual ap√≥s erro...');
         populateNomesInput(nomeEl, []);
         window.nomesData = [];
         if (isMobile) {
           hideLoadingAlert();
         } else {
           hideLoadingIndicator();
         }
         return;
       }
       
       // üö® CORRE√á√ÉO CR√çTICA: Garantir que data seja sempre um array v√°lido
       if (!data || !Array.isArray(data)) {
         console.warn('‚ö†Ô∏è Data n√£o √© array v√°lido ap√≥s query, convertendo...', { 
           data, 
           tipo: typeof data,
           isArray: Array.isArray(data),
           dataValue: data 
         });
         data = Array.isArray(data) ? data : (data ? [data] : []);
       }
       
      // üö® CORRE√á√ÉO CR√çTICA PRODU√á√ÉO: Logs detalhados para debug na nuvem
      if (!data || data.length === 0) {
        console.error('‚ùå ERRO CR√çTICO: Nenhum registro recebido do Supabase');
        console.error('‚ùå Detalhes da query:', {
          comumVal,
          instVal,
          cargoVal,
          precisaInst,
          SELECT_COLS,
          TABLE_CATALOGO,
          COL_COMUM
        });
        console.error('‚ùå Verificando se Supabase est√° dispon√≠vel:', {
          supabaseLoaded,
          sbDisponivel: !!sb,
          navigatorOnLine: navigator.onLine
        });
        
        // üö® CORRE√á√ÉO CR√çTICA: Tentar query simplificada para verificar se h√° dados na tabela
        if (sb && typeof sb.from === 'function') {
          console.log('üîÑ Tentando query simplificada para diagn√≥stico...');
          try {
            const testQuery = sb.from(TABLE_CATALOGO).select('nome, comum, cargo, instrumento').limit(5);
            const testResult = await testQuery;
            console.log('üîç Resultado da query de teste:', {
              dataLength: testResult.data?.length || 0,
              error: testResult.error ? testResult.error.message : null,
              hasData: !!testResult.data,
              firstRecord: testResult.data?.[0]
            });
            
            if (testResult.error) {
              console.error('‚ùå Erro na query de teste:', testResult.error);
              console.error('‚ùå C√≥digo do erro:', testResult.error.code);
              console.error('‚ùå Mensagem:', testResult.error.message);
              console.error('‚ùå Detalhes:', testResult.error.details);
              console.error('‚ùå Hint:', testResult.error.hint);
            } else if (testResult.data && testResult.data.length > 0) {
              console.log('‚úÖ Query de teste retornou dados - problema pode ser nos filtros');
              console.log('‚úÖ Primeiro registro:', testResult.data[0]);
            } else {
              console.error('‚ùå Query de teste retornou 0 registros - tabela pode estar vazia ou RLS bloqueando');
            }
          } catch (testError) {
            console.error('‚ùå Erro ao executar query de teste:', testError);
          }
        }
      } else {
        console.log('‚úÖ Dados recebidos do Supabase:', data.length, 'registros');
        console.log('‚úÖ Primeiros registros:', data.slice(0, 3));
      }
       
      // üîß CORRE√á√ÉO CR√çTICA: Filtro p√≥s-consulta para garantir que os dados correspondem ao instrumento buscado
      // üîß CORRE√á√ÉO CR√çTICA PARA iOS: Garante que data seja sempre um array antes de filtrar (mesma l√≥gica do online)
      let dataFiltrada = Array.isArray(data) ? data : (data ? [data] : []);
      
      // üöÄ OTIMIZA√á√ÉO MOBILE: L√≥gica unificada para Android e iOS (mesma performance)
      // Verifica se dados de clarinete baixo j√° foram buscados especificamente
      // Se sim, N√ÉO aplica filtro adicional pois os dados j√° est√£o corretos
      const temDadosClarineteBaixoFiltro = clarineteBaixoData && 
                                           Array.isArray(clarineteBaixoData) && 
                                           clarineteBaixoData.length > 0;
      
      // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
      console.log('üîç Dados ANTES do filtro:', { 
          dataLength: data?.length || 0, 
          dataFiltradaLength: dataFiltrada.length,
          dataIsArray: Array.isArray(data),
          dataFiltradaIsArray: Array.isArray(dataFiltrada),
          precisaInst: precisaInst,
          instVal: instVal,
          temDadosClarineteBaixoFiltro: temDadosClarineteBaixoFiltro,
          skipFiltroAdicional: temDadosClarineteBaixoFiltro
        });
      
      // üîß CORRE√á√ÉO CR√çTICA: Se dados de clarinete baixo j√° foram buscados especificamente, PULA o filtro
      // Os dados j√° est√£o corretos e n√£o precisam ser filtrados novamente
      if (temDadosClarineteBaixoFiltro) {
        console.log('üîß ‚úÖ Dados de clarinete baixo j√° foram buscados especificamente - pulando filtro adicional');
        // üö® CORRE√á√ÉO: Removida refer√™ncia a isIOSFinalFilter (n√£o definida)
        // üîß CR√çTICO: Garante que dataFiltrada use os dados de clarinete baixo diretamente
        dataFiltrada = clarineteBaixoData;
        // üö® CORRE√á√ÉO: Removida refer√™ncia a isIOSFinalFilter (n√£o definida)
      } else if (cargoUP === 'ORGANISTA') {
        // üö® CORRE√á√ÉO CR√çTICA: Para ORGANISTA, N√ÉO aplicar filtro de instrumento
        // A query j√° busca por ORGANISTA, SECRET√ÅRIA DA M√öSICA, INSTRUTORA e EXAMINADORA
        // N√£o precisa filtrar por instrumento - mant√©m todos os resultados da query
        console.log('üîç ORGANISTA - mantendo todos os resultados (ORGANISTA, SECRET√ÅRIA DA M√öSICA, INSTRUTORA, EXAMINADORA)');
        
        // üö® DEBUG CR√çTICO: Verificar se INSTRUTORA est√° em dataFiltrada
        const instrutorasEmDataFiltrada = dataFiltrada.filter(r => 
          r.cargo && (r.cargo.toUpperCase().includes('INSTRUTORA') || r.cargo.toUpperCase().includes('INSTRUTORAS'))
        );
        if (instrutorasEmDataFiltrada.length > 0) {
          console.log('‚úÖ INSTRUTORAS em dataFiltrada para ORGANISTA:', instrutorasEmDataFiltrada.length, 'registros');
          if (isMobile || isIOS) {
            console.log('üì± MOBILE/iOS - INSTRUTORAS encontradas:', instrutorasEmDataFiltrada.slice(0, 3).map(r => ({
              nome: r.nome,
              cargo: r.cargo,
              comum: r[COL_COMUM]
            })));
          }
        } else {
          console.warn('‚ö†Ô∏è ATEN√á√ÉO: Nenhuma INSTRUTORA em dataFiltrada para ORGANISTA!');
          console.warn('‚ö†Ô∏è Total de registros em dataFiltrada:', dataFiltrada.length);
          console.warn('‚ö†Ô∏è Cargos em dataFiltrada:', [...new Set(dataFiltrada.map(r => r.cargo))]);
        }
        
        // N√£o filtra - mant√©m todos os resultados da query
      } else if (isExaminadora) {
        // üõ°Ô∏è CORRE√á√ÉO CROSS-PLATFORM: Para EXAMINADORA, n√£o aplicar filtro de instrumento se n√£o houver instrumento (usando detec√ß√£o robusta)
        // Examinadora pode ter instrumento ou n√£o - se tiver, filtra por instrumento
        if (instVal) {
          const instValUpper = instVal.toUpperCase();
          console.log('üîç Filtrando examinadoras por instrumento:', instVal);
          dataFiltrada = dataFiltrada.filter(r => {
            if (!r.instrumento) return false;
            const instUpper = (r.instrumento || '').toUpperCase().trim();
            return instUpper.includes(instValUpper);
          });
        } else {
          console.log('üîç Examinadoras sem instrumento - mantendo todas as examinadoras');
          // N√£o filtra por instrumento - mant√©m todas as examinadoras
        }
      } else if (isInstrutora) {
        // üõ°Ô∏è CORRE√á√ÉO CROSS-PLATFORM: Para INSTRUTORA, n√£o aplicar filtro de instrumento se n√£o houver instrumento (usando detec√ß√£o robusta)
        // Instrutora pode ter instrumento ou n√£o - se tiver, filtra por instrumento
        if (instVal) {
          const instValUpper = instVal.toUpperCase();
          console.log('üîç Filtrando instrutoras por instrumento:', instVal);
          dataFiltrada = dataFiltrada.filter(r => {
            if (!r.instrumento) return false;
            const instUpper = (r.instrumento || '').toUpperCase().trim();
            return instUpper.includes(instValUpper);
          });
        } else {
          console.log('üîç Instrutoras sem instrumento - mantendo todas as instrutoras');
          // N√£o filtra por instrumento - mant√©m todas as instrutoras
        }
      } else if (isSecretariaMusica) {
        // üõ°Ô∏è CORRE√á√ÉO CROSS-PLATFORM: Para SECRET√ÅRIA DA M√öSICA, n√£o aplicar filtro de instrumento se n√£o houver instrumento (usando detec√ß√£o robusta)
        // Secret√°ria da M√∫sica pode ter instrumento ou n√£o - se tiver, filtra por instrumento
        if (instVal) {
          const instValUpper = instVal.toUpperCase();
          console.log('üîç Filtrando secret√°rias da m√∫sica por instrumento:', instVal);
          dataFiltrada = dataFiltrada.filter(r => {
            if (!r.instrumento) return false;
            const instUpper = (r.instrumento || '').toUpperCase().trim();
            return instUpper.includes(instValUpper);
          });
        } else {
          console.log('üîç Secret√°rias da m√∫sica sem instrumento - mantendo todas as secret√°rias');
          // N√£o filtra por instrumento - mant√©m todas as secret√°rias
        }
      } else if (precisaInst && instVal) {
        const instValUpper = instVal.toUpperCase();
        // üö® CORRE√á√ÉO: Logs de debug removidos para n√£o atrasar carregamento
        const instrumentosUnicos = [...new Set(dataFiltrada?.map(r => r.instrumento))];
        
        // üîß CORRE√á√ÉO: Filtro mais robusto para clarinete baixo
        if (instValUpper.includes('CLARINETE BAIXO') || instValUpper.includes('CLARONE')) {
          // üö® CORRE√á√ÉO: Logs de debug removidos para n√£o atrasar carregamento
          dataFiltrada = dataFiltrada.filter(r => {
            if (!r.instrumento) return false;
            const instUpper = (r.instrumento || '').toUpperCase().trim();
            
            // üîß CORRE√á√ÉO CR√çTICA: Aceita qualquer varia√ß√£o de clarinete baixo/clarone
            return instUpper.includes('CLARINETE BAIXO (CLARONE)') || 
                   instUpper.includes('CLARINETE BAIXO') || 
                   instUpper.includes('CLARONE');
          });
        } else {
           // üîß CORRE√á√ÉO CR√çTICA PARA iOS: Quando busca por "CLARINETE", exclui "CLARINETE BAIXO" (mesma l√≥gica do Android/Online)
           // Evita que clarinete baixo apare√ßa na lista de clarinete comum
           const isClarineteComum = instValUpper === 'CLARINETE' || 
                                    (instValUpper.includes('CLARINETE') && 
                                     !instValUpper.includes('CLARINETE BAIXO') && 
                                     !instValUpper.includes('CLARONE') &&
                                     !instValUpper.includes('CLARINETE ALTO'));
           
           // üö® CORRE√á√ÉO: Removida refer√™ncia a isIOSFinalFilter (n√£o definida)
           
           dataFiltrada = dataFiltrada.filter(r => {
             if (!r.instrumento) return false;
             const instUpper = (r.instrumento || '').toUpperCase().trim();
             
             // üîß CORRE√á√ÉO CR√çTICA: Se busca por clarinete comum, exclui clarinete baixo e clarone (MESMA L√ìGICA DO ANDROID)
             if (isClarineteComum) {
               // Exclui clarinete baixo, clarone e clarinete alto quando busca apenas por "CLARINETE"
               if (instUpper.includes('CLARINETE BAIXO') || 
                   instUpper.includes('CLARONE') ||
                   instUpper.includes('CLARINETE ALTO')) {
                 // üö® CORRE√á√ÉO: Removida refer√™ncia a isIOSFinalFilter (n√£o definida)
                 return false; // üîß EXCLUI clarinete baixo quando busca por clarinete comum
               }
             }
             
             // Verifica se o instrumento do registro corresponde ao instrumento buscado
             return instUpper.includes(instValUpper);
           });
           
           // üö® CORRE√á√ÉO: Logs de debug removidos para n√£o atrasar carregamento
         }
         
         // üö® CORRE√á√ÉO: Logs de debug removidos para n√£o atrasar carregamento
         // Apenas log de erro se n√£o encontrar resultados
         if (dataFiltrada.length === 0 && data && data.length > 0) {
           console.warn('‚ö†Ô∏è Nenhum m√∫sico encontrado com o instrumento', instVal);
         }
       }
       
       // üö® CORRE√á√ÉO: Logs de debug removidos para n√£o atrasar carregamento
       
      // üö® CORRE√á√ÉO CR√çTICA: Garantir que dataFiltrada seja sempre um array v√°lido antes de processar
      if (!dataFiltrada || !Array.isArray(dataFiltrada)) {
        console.warn('‚ö†Ô∏è dataFiltrada n√£o √© array v√°lido, convertendo...', { 
          dataFiltrada, 
          tipo: typeof dataFiltrada,
          isArray: Array.isArray(dataFiltrada)
        });
        dataFiltrada = Array.isArray(dataFiltrada) ? dataFiltrada : (dataFiltrada ? [dataFiltrada] : []);
      }
      
      // üö® CORRE√á√ÉO CR√çTICA: Filtrar por comum no lado do cliente (resolver problema de acentos)
      // Como removemos o filtro de comum da query Supabase, precisamos filtrar aqui
      // Isso garante que encontra "Jardim Honoria" mesmo que no banco esteja "Jardim Hon√≥ria"
      if (comumVal && dataFiltrada.length > 0) {
        // üõ°Ô∏è CORRE√á√ÉO ANDROID: Normaliza√ß√£o robusta antes de comparar
        const comumValNormalizado = norm(comumVal);
        const comumValSemAcentoUpper = noacc(comumValNormalizado).toUpperCase().trim();
        const comumValUpper = comumValNormalizado.toUpperCase().trim();
        
        console.log('üîç Filtrando por comum no lado do cliente:', {
          comumVal: comumVal,
          comumValSemAcento: comumValSemAcentoUpper,
          registrosAntes: dataFiltrada.length,
          cargoUP: cargoUP,
          cargoVal: cargoVal
        });
        
        const registrosAntesFiltro = dataFiltrada.length;
        
        // üö® DEBUG MOBILE: Log detalhado antes do filtro de comum quando cargo √© ORGANISTA (iOS e Android)
        if (isMobile && cargoUP === 'ORGANISTA' && registrosAntesFiltro > 0) {
          console.log('üì± MOBILE - Antes do filtro de comum (ORGANISTA):', {
            registrosAntes: registrosAntesFiltro,
            comumBuscado: comumVal,
            comumBuscadoSemAcento: comumValSemAcentoUpper,
            primeirosRegistros: dataFiltrada.slice(0, 3).map(r => ({
              nome: r.nome,
              cargo: r.cargo,
              comum: r[COL_COMUM]
            }))
          });
        }
        
        // üö® DEBUG CR√çTICO: Verificar INSTRUTORA antes do filtro de comum
        const instrutorasAntesFiltro = dataFiltrada.filter(r => 
          r.cargo && (r.cargo.toUpperCase().includes('INSTRUTORA') || r.cargo.toUpperCase().includes('INSTRUTORAS'))
        );
        if (instrutorasAntesFiltro.length > 0 && (isMobile || isIOS)) {
          console.log('üì± MOBILE/iOS - INSTRUTORAS antes do filtro de comum:', instrutorasAntesFiltro.length, 'registros');
          console.log('üì± MOBILE/iOS - Exemplos:', instrutorasAntesFiltro.slice(0, 3).map(r => ({
            nome: r.nome,
            cargo: r.cargo,
            comum: r[COL_COMUM]
          })));
        }
        
        dataFiltrada = dataFiltrada.filter(r => {
          if (!r[COL_COMUM]) {
            // üö® CORRE√á√ÉO ANDROID: Log espec√≠fico para debug (usando detec√ß√£o robusta)
            if (isAndroid && (cargoUP === 'ORGANISTA' || isInstrutora || isExaminadora || isSecretariaMusica)) {
              console.warn('‚ö†Ô∏è ANDROID: Registro sem comum removido:', {
                nome: r.nome,
                cargo: r.cargo,
                comum: r[COL_COMUM]
              });
            }
            return false;
          }
          const comumR = r[COL_COMUM];
          
          // üõ°Ô∏è CORRE√á√ÉO: Usar fun√ß√£o utilit√°ria para compara√ß√£o robusta
          // üö® CORRE√á√ÉO MOBILE: Habilitar debug para mobile (iOS e Android)
          const comparaResult = compareComum(comumR, comumVal, {
            debug: isMobile && (cargoUP === 'ORGANISTA' || isInstrutora || isExaminadora || isSecretariaMusica)
          });
          
          // üö® CORRE√á√ÉO CR√çTICA: N√ÉO incluir INSTRUTORAS de outras comuns
          // O filtro de comum deve ser aplicado rigorosamente para TODAS as organistas
          // Isso garante que apenas organistas da comum selecionada sejam retornadas
          const isInstrutoraRegistro = r.cargo && (r.cargo.toUpperCase().includes('INSTRUTORA') || r.cargo.toUpperCase().includes('INSTRUTORAS'));
          
          // üö® CORRE√á√ÉO MOBILE: Log espec√≠fico para debug quando n√£o faz match (iOS e Android)
          if (!comparaResult.match && isMobile && (cargoUP === 'ORGANISTA' || isInstrutora || isExaminadora || isSecretariaMusica)) {
            if (isInstrutoraRegistro) {
              console.warn('‚ö†Ô∏è MOBILE: INSTRUTORA n√£o corresponde ao comum selecionado - removendo:', {
                nome: r.nome,
                cargo: r.cargo,
                comumRegistro: comumR,
                comumBuscado: comumVal,
                ...comparaResult.matchDetails
              });
            } else {
              console.warn('‚ö†Ô∏è MOBILE: Registro n√£o correspondeu ao comum:', {
                nome: r.nome,
                cargo: r.cargo,
                comumRegistro: comumR,
                comumBuscado: comumVal,
                ...comparaResult.matchDetails
              });
            }
          }
          
          // üö® FILTRO RIGOROSO: Aplicar filtro de comum para TODAS as organistas, incluindo INSTRUTORAS
          return comparaResult.match;
        });
        
        // üö® DEBUG CR√çTICO: Verificar INSTRUTORA depois do filtro de comum
        const instrutorasDepoisFiltro = dataFiltrada.filter(r => 
          r.cargo && (r.cargo.toUpperCase().includes('INSTRUTORA') || r.cargo.toUpperCase().includes('INSTRUTORAS'))
        );
        if (instrutorasDepoisFiltro.length > 0 && (isMobile || isIOS)) {
          console.log('‚úÖ MOBILE/iOS - INSTRUTORAS depois do filtro de comum:', instrutorasDepoisFiltro.length, 'registros');
          // Verificar se as INSTRUTORAS s√£o da comum correta
          const instrutorasComumCorreta = instrutorasDepoisFiltro.filter(r => {
            const comumR = r[COL_COMUM] || '';
            const comparaResult = compareComum(comumR, comumVal);
            return comparaResult.match;
          });
          if (instrutorasComumCorreta.length !== instrutorasDepoisFiltro.length) {
            console.warn('‚ö†Ô∏è ATEN√á√ÉO: Algumas INSTRUTORAS n√£o s√£o da comum selecionada:', {
              totalInstrutoras: instrutorasDepoisFiltro.length,
              instrutorasComumCorreta: instrutorasComumCorreta.length,
              comumBuscado: comumVal
            });
          }
        } else if (instrutorasAntesFiltro.length > 0 && instrutorasDepoisFiltro.length === 0) {
          // üö® CORRE√á√ÉO: Se n√£o h√° INSTRUTORAS ap√≥s o filtro, √© porque n√£o h√° INSTRUTORAS na comum selecionada
          // Isso √© CORRETO - n√£o devemos adicionar INSTRUTORAS de outras comuns
          console.log('‚ÑπÔ∏è Nenhuma INSTRUTORA encontrada na comum selecionada:', comumVal);
        }
        
        console.log('üîç Registros ap√≥s filtro de comum:', {
          antes: registrosAntesFiltro,
          depois: dataFiltrada.length,
          removidos: registrosAntesFiltro - dataFiltrada.length,
          cargoUP: cargoUP,
          isInstrutora: isInstrutora,
          isExaminadora: isExaminadora,
          isSecretariaMusica: isSecretariaMusica
        });
        
        // üö® CORRE√á√ÉO MOBILE: Log de alerta se todos os registros foram removidos pelo filtro de comum (iOS e Android)
        // Inclui verifica√ß√£o para ORGANISTA tamb√©m, pois pode incluir instrutoras, examinadoras e secret√°rias
        if (isMobile && (cargoUP === 'ORGANISTA' || isInstrutora || isExaminadora || isSecretariaMusica) &&
            registrosAntesFiltro > 0 && dataFiltrada.length === 0) {
          console.error('‚ùå MOBILE: TODOS os registros foram removidos pelo filtro de comum!', {
            cargoUP: cargoUP,
            cargoVal: cargoVal,
            comumVal: comumVal,
            registrosAntes: registrosAntesFiltro,
            isInstrutora: isInstrutora,
            isExaminadora: isExaminadora,
            isSecretariaMusica: isSecretariaMusica
          });
        }
        
        // üö® DEBUG DETALHADO: Log detalhado quando cargo √© ORGANISTA (todas as plataformas)
        if (cargoUP === 'ORGANISTA' && registrosAntesFiltro > 0) {
          const cargosAposFiltro = {};
          dataFiltrada.forEach(r => {
            const cargo = (r.cargo || '').toUpperCase();
            if (!cargosAposFiltro[cargo]) {
              cargosAposFiltro[cargo] = 0;
            }
            cargosAposFiltro[cargo]++;
          });
          console.log('üîç Cargos ap√≥s filtro de comum (ORGANISTA):', cargosAposFiltro);
          console.log('üîç Registros removidos pelo filtro de comum:', registrosAntesFiltro - dataFiltrada.length);
          
          // üö® DEBUG MOBILE: Log espec√≠fico para mobile ap√≥s filtro de comum
          if (isMobile) {
            console.log('üì± MOBILE - Organistas ap√≥s filtro de comum:', {
              registrosAntes: registrosAntesFiltro,
              registrosDepois: dataFiltrada.length,
              removidos: registrosAntesFiltro - dataFiltrada.length,
              cargos: cargosAposFiltro,
              comumBuscado: comumVal,
              exemplos: dataFiltrada.slice(0, 3).map(r => ({
                nome: r.nome,
                cargo: r.cargo,
                comum: r[COL_COMUM]
              }))
            });
          }
          
          // Verifica se instrutoras, examinadoras e secret√°rias foram removidas
          const temInstrutoras = Object.keys(cargosAposFiltro).some(c => c.includes('INSTRUTORA'));
          const temExaminadoras = Object.keys(cargosAposFiltro).some(c => c.includes('EXAMINADORA'));
          const temSecretarias = Object.keys(cargosAposFiltro).some(c => c.includes('SECRET√ÅRIA') && c.includes('M√öSICA'));
          
          if (!temInstrutoras || !temExaminadoras || !temSecretarias) {
            console.warn('‚ö†Ô∏è Cargos faltando ap√≥s filtro de comum:', {
              temInstrutoras,
              temExaminadoras,
              temSecretarias,
              cargosEncontrados: Object.keys(cargosAposFiltro),
              registrosAntes: registrosAntesFiltro,
              registrosDepois: dataFiltrada.length,
              comumBuscado: comumVal
            });
            
            // üö® DEBUG MOBILE: Log espec√≠fico para mobile quando cargos est√£o faltando
            if (isMobile) {
              console.error('üì± MOBILE - Cargos faltando ap√≥s filtro de comum:', {
                temInstrutoras,
                temExaminadoras,
                temSecretarias,
                cargosEncontrados: Object.keys(cargosAposFiltro),
                registrosAntes: registrosAntesFiltro,
                registrosDepois: dataFiltrada.length,
                comumBuscado: comumVal
              });
            }
          }
        }
      }
      
        // üö® CORRE√á√ÉO CR√çTICA MOBILE: Atribuir organistaData DEPOIS do filtro de comum
        // Se temos dados de organistas armazenados antes do filtro de comum, atribuir agora
        if (window._organistaDataAntesFiltroComum && cargoUP === 'ORGANISTA') {
          // üö® CORRE√á√ÉO CHROME iOS: Garantir que TODOS os dados sejam processados corretamente
          // No Chrome iOS, garantir que dataFiltrada contenha TODOS os dados, incluindo INSTRUTORA
          let dadosFinais = [...dataFiltrada];
          
          // üö® CORRE√á√ÉO CR√çTICA: N√ÉO adicionar INSTRUTORAS de outras comuns
          // O filtro de comum j√° foi aplicado corretamente em dataFiltrada
          // Se n√£o h√° INSTRUTORAS em dataFiltrada, √© porque n√£o h√° INSTRUTORAS na comum selecionada
          // Isso √© CORRETO - n√£o devemos adicionar INSTRUTORAS de outras comuns
          if (isChromeIOS) {
            const instrutorasEmDataFiltrada = dadosFinais.filter(r => 
              r.cargo && (r.cargo.toUpperCase().includes('INSTRUTORA') || r.cargo.toUpperCase().includes('INSTRUTORAS'))
            );
            
            if (instrutorasEmDataFiltrada.length === 0) {
              console.log('‚ÑπÔ∏è CHROME iOS - Nenhuma INSTRUTORA encontrada na comum selecionada:', comumVal);
              console.log('‚ÑπÔ∏è Isso √© CORRETO - n√£o devemos adicionar INSTRUTORAS de outras comuns');
            }
          }
          
          // üö® CORRE√á√ÉO: Atribuir dadosFinais (que j√° passou pelo filtro de comum e corre√ß√µes) para organistaData
          organistaData = dadosFinais;
          
          // üö® DEBUG CR√çTICO: Verificar se INSTRUTORA est√° em organistaData ap√≥s atribui√ß√£o
          const instrutorasEmOrganistaData = organistaData.filter(r => 
            r.cargo && (r.cargo.toUpperCase().includes('INSTRUTORA') || r.cargo.toUpperCase().includes('INSTRUTORAS'))
          );
          if (instrutorasEmOrganistaData.length > 0) {
            console.log('‚úÖ INSTRUTORAS em organistaData ap√≥s atribui√ß√£o:', instrutorasEmOrganistaData.length, 'registros');
            if (isChromeIOS) {
              console.log('‚úÖ CHROME iOS - INSTRUTORAS em organistaData:', instrutorasEmOrganistaData.slice(0, 3).map(r => ({
                nome: r.nome,
                cargo: r.cargo,
                comum: r[COL_COMUM]
              })));
            }
          } else {
            console.error('üö® ERRO CR√çTICO: Nenhuma INSTRUTORA em organistaData ap√≥s atribui√ß√£o!');
            console.error('üö® Total de registros em organistaData:', organistaData.length);
            console.error('üö® Cargos em organistaData:', [...new Set(organistaData.map(r => r.cargo))]);
            if (isChromeIOS) {
              console.error('üö® CHROME iOS - ERRO CR√çTICO: INSTRUTORAS n√£o est√£o em organistaData!');
            }
          }
          
          // üö® LOG ESPEC√çFICO CHROME iOS: Log antes do processamento
          if (isChromeIOS) {
            console.log('üîç CHROME iOS - Processando organistaData ap√≥s filtro de comum:', {
              organistaDataLength: organistaData ? organistaData.length : 0,
              antesFiltro: window._organistaDataAntesFiltroComum ? window._organistaDataAntesFiltroComum.length : 0,
              depoisFiltro: dataFiltrada ? dataFiltrada.length : 0,
              dadosFinais: dadosFinais.length,
              instrutoras: instrutorasEmOrganistaData.length,
              exemplos: organistaData ? organistaData.slice(0, 5).map(r => ({
                nome: r.nome,
                cargo: r.cargo,
                comum: r[COL_COMUM]
              })) : []
            });
          }
          
          // üö® CORRE√á√ÉO CR√çTICA MOBILE: Processar organistaData para criar uniqueOrganista
          // Isso garante que todos os nomes sejam processados corretamente
          // üö® CORRE√á√ÉO CR√çTICA: Deduplicar registros antes de processar nomes
          const seenRegistrosOrganista = new Set();
          const registrosUnicosOrganista = [];
          
          (organistaData || []).forEach(r => {
            if (!r || !r.nome) return;
            
            // Criar chave √∫nica baseada em UUID ou nome+comum
            let key;
            if (r.uuid) {
              key = `uuid_${r.uuid}`;
            } else {
              const nomeNorm = (r.nome || '').toUpperCase().trim();
              const comumNorm = (r[COL_COMUM] || '').toUpperCase().trim();
              key = `${nomeNorm}_${comumNorm}`;
            }
            
            if (!seenRegistrosOrganista.has(key)) {
              seenRegistrosOrganista.add(key);
              registrosUnicosOrganista.push(r);
            }
          });
          
          const nomesOrganista = registrosUnicosOrganista
            .map(r => {
              if (!r || !r.nome) return null;
              return norm(r.nome);
            })
            .filter(Boolean)
            .map(s => s.toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase()))
            .sort((a,b)=>a.localeCompare(b,'pt-BR'));
          const uniqueOrganista = [...new Set(nomesOrganista)];
          
          // üö® VALIDA√á√ÉO: Verificar se havia duplicatas
          if (organistaData && organistaData.length !== registrosUnicosOrganista.length) {
            const duplicatasRemovidas = organistaData.length - registrosUnicosOrganista.length;
            console.warn('‚ö†Ô∏è ATEN√á√ÉO: Registros duplicados removidos ao processar uniqueOrganista!', {
              totalAntes: organistaData.length,
              totalDepois: registrosUnicosOrganista.length,
              duplicatasRemovidas: duplicatasRemovidas,
              uniqueLength: uniqueOrganista.length
            });
          }
          
          // üö® DEBUG CR√çTICO: Verificar se nomes de INSTRUTORA est√£o em uniqueOrganista
          // Usar registrosUnicosOrganista em vez de organistaData (j√° deduplicado)
          const nomesInstrutoras = registrosUnicosOrganista.filter(r => 
            r.cargo && (r.cargo.toUpperCase().includes('INSTRUTORA') || r.cargo.toUpperCase().includes('INSTRUTORAS'))
          ).map(r => norm(r.nome)).filter(Boolean);
          const nomesInstrutorasNormalizados = nomesInstrutoras.map(s => 
            s.toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase())
          );
          const instrutorasEmUnique = uniqueOrganista.filter(nome => 
            nomesInstrutorasNormalizados.some(nomeInstr => 
              nome.toLowerCase() === nomeInstr.toLowerCase()
            )
          );
          
          if (instrutorasEmUnique.length > 0) {
            console.log('‚úÖ Nomes de INSTRUTORA em uniqueOrganista:', instrutorasEmUnique.length, 'nomes');
            if (isMobile || isIOS) {
              console.log('üì± MOBILE/iOS - Nomes de INSTRUTORA:', instrutorasEmUnique);
            }
          } else if (nomesInstrutoras.length > 0) {
            console.error('üö® ERRO CR√çTICO: Nomes de INSTRUTORA N√ÉO est√£o em uniqueOrganista!');
            console.error('üö® Nomes de INSTRUTORA encontrados:', nomesInstrutorasNormalizados);
            console.error('üö® uniqueOrganista:', uniqueOrganista.slice(0, 10));
            if (isMobile || isIOS) {
              console.error('üì± MOBILE/iOS - ERRO: Nomes de INSTRUTORA n√£o foram processados!');
              // üö® CORRE√á√ÉO: Adicionar nomes de INSTRUTORA manualmente se n√£o estiverem
              nomesInstrutorasNormalizados.forEach(nome => {
                if (!uniqueOrganista.some(u => u.toLowerCase() === nome.toLowerCase())) {
                  uniqueOrganista.push(nome);
                  console.log('üîß CORRE√á√ÉO: Nome de INSTRUTORA adicionado manualmente:', nome);
                }
              });
              // Reordenar ap√≥s adicionar
              uniqueOrganista.sort((a,b)=>a.localeCompare(b,'pt-BR'));
            }
          }
          
          // üö® LOG ESPEC√çFICO CHROME iOS: Log ap√≥s processamento
          if (isChromeIOS) {
            console.log('üîç CHROME iOS - uniqueOrganista processado:', {
              nomesOrganistaLength: nomesOrganista.length,
              uniqueOrganistaLength: uniqueOrganista.length,
              duplicatasRemovidas: nomesOrganista.length - uniqueOrganista.length,
              instrutorasEmUnique: instrutorasEmUnique.length,
              primeirosNomes: uniqueOrganista.slice(0, 10),
              todosOsNomes: uniqueOrganista
            });
          }
          
          // üö® CORRE√á√ÉO CR√çTICA MOBILE: Atribuir uniqueOrganista para garantir que todos os nomes sejam processados
          window._uniqueOrganista = uniqueOrganista;
          
          // üö® VALIDA√á√ÉO MOBILE: Verificar se organistaData foi atribu√≠do corretamente ap√≥s filtro de comum
          if (isMobile) {
            console.log('üì± MOBILE - organistaData atribu√≠do AP√ìS filtro de comum:', {
              temDados: !!organistaData,
              isArray: Array.isArray(organistaData),
              length: organistaData ? organistaData.length : 0,
              antesFiltro: window._organistaDataAntesFiltroComum ? window._organistaDataAntesFiltroComum.length : 0,
              depoisFiltro: dataFiltrada ? dataFiltrada.length : 0,
              uniqueLength: uniqueOrganista.length
            });
          }
          
          // Limpar vari√°vel tempor√°ria
          delete window._organistaDataAntesFiltroComum;
        }
      
      // üö® CORRE√á√ÉO: Logs de debug removidos para n√£o atrasar carregamento
      
      // üö® CORRE√á√ÉO: Restaurar l√≥gica original que funcionava
      // üö® CORRE√á√ÉO CR√çTICA MOBILE: Se temos uniqueOrganista processado de organistaData, usar ele
      // Isso garante que todos os nomes de organistas sejam processados corretamente
      let unique;
      if (window._uniqueOrganista && Array.isArray(window._uniqueOrganista) && window._uniqueOrganista.length > 0) {
        // üö® CORRE√á√ÉO: Usar uniqueOrganista processado de organistaData
        unique = window._uniqueOrganista;
        
        // üö® VALIDA√á√ÉO FINAL: Garantir que unique cont√©m apenas nomes da comum selecionada
        // Isso √© ESSENCIAL para evitar que nomes de outras comuns sejam exibidos
        if (cargoUP === 'ORGANISTA' && comumVal && comumVal.trim() !== '') {
          // Verificar se organistaData est√° dispon√≠vel para valida√ß√£o
          if (organistaData && Array.isArray(organistaData) && organistaData.length > 0) {
            // Criar mapa de nomes v√°lidos (apenas da comum selecionada)
            const nomesValidos = new Set();
            organistaData.forEach(r => {
              if (r && r.nome && r[COL_COMUM]) {
                const comparaResult = compareComum(r[COL_COMUM], comumVal);
                if (comparaResult.match) {
                  const nomeNorm = norm(r.nome).toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase());
                  nomesValidos.add(nomeNorm.toLowerCase());
                }
              }
            });
            
            // Filtrar unique para conter apenas nomes v√°lidos
            const uniqueFiltrado = unique.filter(nome => {
              const nomeLower = nome.toLowerCase();
              return nomesValidos.has(nomeLower);
            });
            
            if (uniqueFiltrado.length !== unique.length) {
              const removidos = unique.length - uniqueFiltrado.length;
              console.warn('üö® VALIDA√á√ÉO FINAL: Removidos nomes de outras comuns:', {
                comumSelecionada: comumVal,
                totalAntes: unique.length,
                totalDepois: uniqueFiltrado.length,
                removidos: removidos
              });
              unique = uniqueFiltrado;
            }
          }
        }
        
        // üö® DEBUG MOBILE: Log espec√≠fico para mobile
        if (isMobile) {
          console.log('üì± MOBILE - Usando uniqueOrganista processado:', {
            uniqueLength: unique.length,
            primeirosNomes: unique.slice(0, 5)
          });
        }
        
        // Limpar vari√°vel tempor√°ria
        delete window._uniqueOrganista;
      } else {
        // Processa os dados filtrados (n√£o os dados brutos)
        // üö® CORRE√á√ÉO CR√çTICA MOBILE: Se organistaData foi atribu√≠do, usar ele em vez de dataFiltrada
        const dadosParaProcessar = (organistaData && Array.isArray(organistaData) && organistaData.length > 0) ? organistaData : dataFiltrada;
        
        // üö® CORRE√á√ÉO CR√çTICA: Deduplicar registros antes de processar nomes
        // Garantir que n√£o processemos registros duplicados
        const seenRegistrosParaUnique = new Set();
        const registrosUnicos = [];
        
        (dadosParaProcessar || []).forEach(r => {
          if (!r || !r.nome) return;
          
          // Criar chave √∫nica baseada em UUID ou nome+comum
          let key;
          if (r.uuid) {
            key = `uuid_${r.uuid}`;
          } else {
            const nomeNorm = (r.nome || '').toUpperCase().trim();
            const comumNorm = (r[COL_COMUM] || '').toUpperCase().trim();
            key = `${nomeNorm}_${comumNorm}`;
          }
          
          if (!seenRegistrosParaUnique.has(key)) {
            seenRegistrosParaUnique.add(key);
            registrosUnicos.push(r);
          }
        });
        
        const nomes = registrosUnicos
          .map(r => {
            // üõ°Ô∏è VALIDA√á√ÉO B√ÅSICA: Garantir que r.nome existe
            if (!r || !r.nome) {
              return null;
            }
            return norm(r.nome);
          })
          .filter(Boolean) // Remove nulls e valores vazios
          .map(s => s.toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase()))
          .sort((a,b)=>a.localeCompare(b,'pt-BR'));
        unique = [...new Set(nomes)];
        
        // üö® VALIDA√á√ÉO: Verificar se havia duplicatas
        if (dadosParaProcessar && dadosParaProcessar.length !== registrosUnicos.length) {
          const duplicatasRemovidas = dadosParaProcessar.length - registrosUnicos.length;
          console.warn('‚ö†Ô∏è ATEN√á√ÉO: Registros duplicados removidos ao processar unique!', {
            totalAntes: dadosParaProcessar.length,
            totalDepois: registrosUnicos.length,
            duplicatasRemovidas: duplicatasRemovidas,
            uniqueLength: unique.length
          });
        }
        
        // üö® DEBUG MOBILE: Log espec√≠fico para mobile
        if (isMobile && cargoUP === 'ORGANISTA') {
          console.log('üì± MOBILE - Processando dados para unique:', {
            usandoOrganistaData: organistaData && Array.isArray(organistaData) && organistaData.length > 0,
            organistaDataLength: organistaData ? organistaData.length : 0,
            dataFiltradaLength: dataFiltrada ? dataFiltrada.length : 0,
            dadosParaProcessarLength: dadosParaProcessar ? dadosParaProcessar.length : 0,
            uniqueLength: unique.length
          });
        }
        
        // üö® VALIDA√á√ÉO FINAL: Garantir que unique cont√©m apenas nomes da comum selecionada
        // Isso √© ESSENCIAL para evitar que nomes de outras comuns sejam exibidos
        if (cargoUP === 'ORGANISTA' && comumVal && comumVal.trim() !== '') {
          // Verificar se dadosParaProcessar est√° dispon√≠vel para valida√ß√£o
          if (dadosParaProcessar && Array.isArray(dadosParaProcessar) && dadosParaProcessar.length > 0) {
            // Criar mapa de nomes v√°lidos (apenas da comum selecionada)
            const nomesValidos = new Set();
            dadosParaProcessar.forEach(r => {
              if (r && r.nome && r[COL_COMUM]) {
                const comparaResult = compareComum(r[COL_COMUM], comumVal);
                if (comparaResult.match) {
                  const nomeNorm = norm(r.nome).toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase());
                  nomesValidos.add(nomeNorm.toLowerCase());
                }
              }
            });
            
            // Filtrar unique para conter apenas nomes v√°lidos
            const uniqueFiltrado = unique.filter(nome => {
              const nomeLower = nome.toLowerCase();
              return nomesValidos.has(nomeLower);
            });
            
            if (uniqueFiltrado.length !== unique.length) {
              const removidos = unique.length - uniqueFiltrado.length;
              console.warn('üö® VALIDA√á√ÉO FINAL: Removidos nomes de outras comuns:', {
                comumSelecionada: comumVal,
                totalAntes: unique.length,
                totalDepois: uniqueFiltrado.length,
                removidos: removidos
              });
              unique = uniqueFiltrado;
            }
          }
        }
      }
      
      // üõ°Ô∏è XIAOMI: Log adicional para debug (apenas se for Xiaomi)
      // üõ°Ô∏è REDMI NOTE 13: Inclu√≠do para logs espec√≠ficos
      if ((isXiaomi || isRedmiNote13) && unique.length > 0) {
        console.log('üì± XIAOMI: Nomes processados:', {
          totalRegistros: dataFiltrada.length,
          nomesUnicos: unique.length,
          primeirosNomes: unique.slice(0, 5)
        });
      }
      
      // üö® LOG CR√çTICO: Verificar se unique foi criado corretamente
      // üö® CORRE√á√ÉO CR√çTICA MOBILE: Log detalhado para mobile
      if (isMobile && cargoUP === 'ORGANISTA') {
        console.log('üì± MOBILE - DEBUG CR√çTICO - unique criado:', {
          uniqueLength: unique.length,
          uniqueIsArray: Array.isArray(unique),
          primeirosNomes: unique.slice(0, 10),
          usandoUniqueOrganista: !!window._uniqueOrganista,
          organistaDataLength: organistaData ? organistaData.length : 0,
          dataFiltradaLength: dataFiltrada ? dataFiltrada.length : 0
        });
      }
      // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
  
      // üö® CORRE√á√ÉO: Logs de debug removidos para n√£o atrasar carregamento
       
       // Armazena os dados completos filtrados para captura autom√°tica da classe
       // üö® CORRE√á√ÉO CR√çTICA MOBILE: Se organistaData foi atribu√≠do, usar ele em vez de dataFiltrada
       const dadosParaArmazenar = (organistaData && Array.isArray(organistaData) && organistaData.length > 0) ? organistaData : dataFiltrada;
       
       // üö® CORRE√á√ÉO CR√çTICA: Garantir que dadosParaArmazenar contenha apenas dados da comum selecionada
       // Aplicar filtro de comum como camada de seguran√ßa adicional
       let dadosFiltradosPorComumParaArmazenar = dadosParaArmazenar;
       if (comumVal && Array.isArray(dadosParaArmazenar) && dadosParaArmazenar.length > 0) {
         dadosFiltradosPorComumParaArmazenar = dadosParaArmazenar.filter(r => {
           if (!r[COL_COMUM]) return false;
           const comparaResult = compareComum(r[COL_COMUM], comumVal);
           return comparaResult.match;
         });
         
         // üö® VALIDA√á√ÉO: Verificar se havia dados de outras comuns
         if (dadosFiltradosPorComumParaArmazenar.length !== dadosParaArmazenar.length) {
           const comunsNosDados = [...new Set(dadosParaArmazenar.map(r => r[COL_COMUM]).filter(Boolean))];
           if (comunsNosDados.length > 1) {
             console.error('üö® ERRO CR√çTICO: dadosParaArmazenar continha dados de m√∫ltiplas comuns!', {
               comumSelecionada: comumVal,
               comunsEncontradas: comunsNosDados,
               totalAntes: dadosParaArmazenar.length,
               totalDepois: dadosFiltradosPorComumParaArmazenar.length
             });
           }
         }
       }
       
       // üö® CORRE√á√ÉO CR√çTICA: Deduplicar registros completos antes de usar
       // Garantir que n√£o haja registros duplicados baseado em UUID ou nome+comum+cargo
       const dadosAntesDeduplicacao = (dadosFiltradosPorComumParaArmazenar || []).filter(r => r.ativo !== false);
       const seenRegistros = new Set();
       const dadosCompletos = [];
       
       // Fun√ß√£o para criar chave √∫nica de registro
       const createRegistroKey = (r) => {
         // Priorizar UUID se dispon√≠vel (mais confi√°vel)
         if (r.uuid) {
           return `uuid_${r.uuid}`;
         }
         // Sen√£o, usar nome + comum + cargo (garante que registros diferentes sejam √∫nicos)
         const nomeNorm = (r.nome || '').toUpperCase().trim();
         const comumNorm = (r[COL_COMUM] || '').toUpperCase().trim();
         const cargoNorm = (r.cargo || '').toUpperCase().trim();
         return `registro_${nomeNorm}_${comumNorm}_${cargoNorm}`;
       };
       
       // Deduplicar registros
       dadosAntesDeduplicacao.forEach(r => {
         if (!r || !r.nome) return; // Ignorar registros inv√°lidos
         const key = createRegistroKey(r);
         if (!seenRegistros.has(key)) {
           seenRegistros.add(key);
           dadosCompletos.push(r);
         }
       });
       
       // üö® VALIDA√á√ÉO: Verificar se havia duplicatas
       if (dadosAntesDeduplicacao.length !== dadosCompletos.length) {
         const duplicatasRemovidas = dadosAntesDeduplicacao.length - dadosCompletos.length;
         console.warn('‚ö†Ô∏è ATEN√á√ÉO: Registros duplicados removidos!', {
           totalAntes: dadosAntesDeduplicacao.length,
           totalDepois: dadosCompletos.length,
           duplicatasRemovidas: duplicatasRemovidas
         });
       }
       
       // üö® DEBUG MOBILE: Log espec√≠fico para mobile
       if (isMobile && cargoUP === 'ORGANISTA') {
         console.log('üì± MOBILE - Armazenando dados completos:', {
           usandoOrganistaData: organistaData && Array.isArray(organistaData) && organistaData.length > 0,
           organistaDataLength: organistaData ? organistaData.length : 0,
           dataFiltradaLength: dataFiltrada ? dataFiltrada.length : 0,
           dadosParaArmazenarLength: dadosParaArmazenar ? dadosParaArmazenar.length : 0,
           dadosAntesDeduplicacao: dadosAntesDeduplicacao.length,
           dadosCompletosLength: dadosCompletos.length,
           duplicatasRemovidas: dadosAntesDeduplicacao.length - dadosCompletos.length
         });
       }
       
       // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
       
       // FOR√áA o armazenamento dos dados completos no cache
       if (dadosCompletos.length > 0) {
         setCache(cacheKey + '_dados', dadosCompletos, 2 * 60 * 60 * 1000);
       }
   
       setCache(cacheKey, unique, 2 * 60 * 60 * 1000);
       
       // üöÄ OTIMIZA√á√ÉO PRODU√á√ÉO: Salvar cache espec√≠fico para organistas (permite carregamento imediato)
       if (cargoUP === 'ORGANISTA' && comumVal && dadosCompletos.length > 0) {
         // üö® CORRE√á√ÉO CR√çTICA: Garantir que apenas organistas da comum selecionada sejam salvos no cache
         // Filtrar dadosCompletos pela comum selecionada ANTES de salvar no cache
         const dadosFiltradosPorComum = dadosCompletos.filter(r => {
           if (!r[COL_COMUM]) return false;
           const comparaResult = compareComum(r[COL_COMUM], comumVal);
           return comparaResult.match;
         });
         
         // üö® VALIDA√á√ÉO: Verificar se o filtro foi aplicado corretamente
         if (dadosFiltradosPorComum.length !== dadosCompletos.length) {
           console.warn('‚ö†Ô∏è ATEN√á√ÉO: Filtro de comum aplicado ao salvar cache. Registros antes:', dadosCompletos.length, 'depois:', dadosFiltradosPorComum.length);
           // Log detalhado para debug
           const comunsNosDados = [...new Set(dadosCompletos.map(r => r[COL_COMUM]).filter(Boolean))];
           if (comunsNosDados.length > 1) {
             console.error('üö® ERRO CR√çTICO: Cache estava sendo salvo com dados de m√∫ltiplas comuns!', {
               comumSelecionada: comumVal,
               comunsEncontradas: comunsNosDados,
               totalAntes: dadosCompletos.length,
               totalDepois: dadosFiltradosPorComum.length
             });
           }
         }
         
         // üö® DEBUG CR√çTICO: Verificar se INSTRUTORA est√° nos dados antes de salvar no cache
         const instrutorasNoCache = dadosFiltradosPorComum.filter(r => 
           r.cargo && (r.cargo.toUpperCase().includes('INSTRUTORA') || r.cargo.toUpperCase().includes('INSTRUTORAS'))
         );
         if (instrutorasNoCache.length > 0) {
           console.log('‚úÖ INSTRUTORAS inclu√≠das no cache de organistas:', instrutorasNoCache.length, 'registros');
         } else {
           console.warn('‚ö†Ô∏è ATEN√á√ÉO: Nenhuma INSTRUTORA nos dados que ser√£o salvos no cache!');
           console.warn('‚ö†Ô∏è Total de registros:', dadosFiltradosPorComum.length);
           console.warn('‚ö†Ô∏è Cargos nos dados:', [...new Set(dadosFiltradosPorComum.map(r => r.cargo))]);
         }
         
         const organistaCacheKey = `cache_organistas_${comumVal.toLowerCase().replace(/\s+/g, '_')}`;
         // üö® CORRE√á√ÉO CR√çTICA: Salvar APENAS organistas da comum selecionada (j√° filtrados)
         // Isso garante que o cache contenha apenas dados da comum correta
         setCache(organistaCacheKey, dadosFiltradosPorComum, 2 * 60 * 60 * 1000);
       }
       
       // Se n√£o h√° resultados, mostra mensagem informativa apenas para cargos musicais
       if (unique.length === 0) {
         // Cargos que n√£o precisam de instrumento (n√£o tocam) - usando vers√£o sem acentos
         const cargosSemInstrumento = [
           'IRMANDADE',     // Irmandade
           'ANCIAO',        // Anci√£o
           'DIACONO',       // Di√°cono
           'COOPERADOR DO OFICIO',  // Cooperador do Of√≠cio
           'COOPERADOR DE JOVENS',  // Cooperador de Jovens
           'PORTEIRO (A)',  // Porteiro (a)
           'BOMBEIRO (A)',  // Bombeiro (a)
           'MEDICO (A)',    // M√©dico (a)
           'SECRETARIO (A)', // Secret√°rio (a)
           'SECRETARIA DA MUSICA', // Secret√°ria da M√∫sica
           'SECRETARIO DA MUSICA'  // Secret√°rio da M√∫sica
         ];
         
         const isCargoNaoMusical = cargosSemInstrumento.includes(cargoUP);
         
         // Alerta removido - usu√°rio pode sempre digitar manualmente
       }
       
       // üîß VERIFICA√á√ÉO: Verifica se ainda √© a requisi√ß√£o mais recente antes de atualizar UI
       if (loadNomesRequestId !== currentRequestId) {
         console.log('‚ö†Ô∏è Requisi√ß√£o foi cancelada - existe uma mais recente. N√£o atualizando UI.');
         // Esconde indicador mesmo se cancelado
         if (isMobile) {
           hideLoadingAlert();
         } else {
           hideLoadingIndicator();
         }
         return;
       }
       
      // üö® CORRE√á√ÉO: Logs de debug removidos para n√£o atrasar carregamento
      
      // üö® CORRE√á√ÉO CR√çTICA: Se h√° resultados, SEMPRE restaurar datalist e limpar estado manual
      if (unique.length > 0) {
        console.log('‚úÖ H√° nomes cadastrados - restaurando datalist e limpando estado manual');
        if (nomeEl && nomeEl.tagName === 'INPUT' && nomeEl.type === 'text') {
          // üö® CORRE√á√ÉO: N√£o usar datalist - remover atributo list
          nomeEl.removeAttribute('list');
          nomeEl.removeAttribute('data-nome-manual');
          nomeEl.removeAttribute('data-selected-from-list');
          // Restaurar estilo normal
          if (nomeEl.style) {
            nomeEl.style.backgroundColor = '';
            nomeEl.style.borderColor = '';
          }
        }
      }
      
      // üö® CORRE√á√ÉO CR√çTICA: Garantir que unique seja sempre um array v√°lido antes de popular
      if (!unique || !Array.isArray(unique)) {
        unique = [];
      }
      
      // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
      
      // üö® CORRE√á√ÉO CR√çTICA: Atribuir window.nomesData com array de strings (nomes √∫nicos) para o dropdown
      window.nomesData = unique || [];
      
      // üö® CORRE√á√ÉO CR√çTICA MULTI-PLATAFORMA: Garantir que unique seja um array de strings
      if (window.nomesData && window.nomesData.length > 0) {
        window.nomesData = window.nomesData.map(nome => {
          return typeof nome === 'string' ? nome : (nome?.nome || String(nome));
        }).filter(Boolean);
      }
      
      // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
      
      // üö® SOLU√á√ÉO DEFINITIVA: Popular SELECT com appendChild (EXATAMENTE igual ao Safari que funciona)
      // Usar EXATAMENTE a mesma l√≥gica do Safari para TODOS os navegadores - SEM diferen√ßas
      if (nomeEl && nomeEl.tagName === 'SELECT') {
        if (unique && Array.isArray(unique) && unique.length > 0) {
          // Limpar SELECT completamente (igual ao Safari)
          while (nomeEl.firstChild) {
            nomeEl.removeChild(nomeEl.firstChild);
          }
          
          // Adicionar primeira op√ß√£o
          const primeiraOpcao = document.createElement('option');
          primeiraOpcao.value = '';
          primeiraOpcao.textContent = 'Selecione um nome da lista (ou digite, se offline)';
          nomeEl.appendChild(primeiraOpcao);
          
          // Adicionar nomes com appendChild (igual ao Safari que funciona)
          // üö® CORRE√á√ÉO CR√çTICA: Garantir que unique seja array de strings
          const nomesStrings = unique.map(nome => {
            // Se for string, usar diretamente
            if (typeof nome === 'string') {
              return nome;
            }
            // Se for objeto, extrair a propriedade 'nome'
            if (nome && typeof nome === 'object' && nome.nome) {
              return nome.nome;
            }
            // Fallback: converter para string
            return String(nome || '');
          }).filter(Boolean);
          
          // üö® CORRE√á√ÉO CR√çTICA CHROME iOS: Verificar e garantir que INSTRUTORA esteja em nomesStrings
          // Buscar em TODAS as fontes poss√≠veis para garantir que INSTRUTORA seja encontrada
          if (isChromeIOS && cargoUP === 'ORGANISTA') {
            console.log('üîç CHROME iOS - Verificando INSTRUTORA em nomesStrings...');
            
            // Buscar INSTRUTORA em m√∫ltiplas fontes de dados
            const fontesDados = [
              organistaData,
              dataFiltrada,
              window._organistaDataAntesFiltroComum,
              window._organistaDataCache
            ].filter(Boolean);
            
            let instrutorasEncontradas = [];
            let nomesInstrutoras = [];
            
            // Buscar em todas as fontes
            for (const fonte of fontesDados) {
              if (Array.isArray(fonte) && fonte.length > 0) {
                const instrutorasNaFonte = fonte.filter(r => 
                  r.cargo && (r.cargo.toUpperCase().includes('INSTRUTORA') || r.cargo.toUpperCase().includes('INSTRUTORAS'))
                );
                
                if (instrutorasNaFonte.length > 0) {
                  instrutorasEncontradas = instrutorasNaFonte;
                  nomesInstrutoras = instrutorasNaFonte.map(r => {
                    const nomeNorm = norm(r.nome);
                    return nomeNorm.toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase());
                  });
                  console.log('‚úÖ CHROME iOS - INSTRUTORA encontrada em fonte de dados:', nomesInstrutoras.length, 'nomes');
                  break; // Parar ap√≥s encontrar em uma fonte
                }
              }
            }
            
            // Se encontrou INSTRUTORA, verificar se est√° em nomesStrings
            if (nomesInstrutoras.length > 0) {
              const instrutorasEmNomesStrings = nomesStrings.filter(nome => 
                nomesInstrutoras.some(nomeInstr => nome.toLowerCase() === nomeInstr.toLowerCase())
              );
              
              if (instrutorasEmNomesStrings.length > 0) {
                console.log('‚úÖ CHROME iOS - Nomes de INSTRUTORA j√° est√£o em nomesStrings:', instrutorasEmNomesStrings.length, 'nomes');
              } else {
                console.error('üö® ERRO CR√çTICO CHROME iOS: Nomes de INSTRUTORA N√ÉO est√£o em nomesStrings!');
                console.error('üö® Nomes de INSTRUTORA esperados:', nomesInstrutoras);
                console.error('üö® nomesStrings atual (primeiros 10):', nomesStrings.slice(0, 10));
                console.error('üö® nomesStrings total:', nomesStrings.length);
                
                // üö® CORRE√á√ÉO CR√çTICA: Adicionar TODOS os nomes de INSTRUTORA manualmente
                nomesInstrutoras.forEach(nomeInstr => {
                  if (!nomesStrings.some(n => n.toLowerCase() === nomeInstr.toLowerCase())) {
                    nomesStrings.push(nomeInstr);
                    console.log('üîß CHROME iOS - Nome de INSTRUTORA adicionado a nomesStrings:', nomeInstr);
                  }
                });
                
                // Reordenar ap√≥s adicionar
                nomesStrings.sort((a,b)=>a.localeCompare(b,'pt-BR'));
                console.log('‚úÖ CHROME iOS - nomesStrings corrigido. Total:', nomesStrings.length);
                
                // üö® CORRE√á√ÉO CR√çTICA: Atualizar window.nomesData com nomes corrigidos
                window.nomesData = [...nomesStrings];
                console.log('‚úÖ CHROME iOS - window.nomesData atualizado com nomes corrigidos');
              }
            } else {
              console.warn('‚ö†Ô∏è CHROME iOS - Nenhuma INSTRUTORA encontrada nas fontes de dados dispon√≠veis');
              console.warn('‚ö†Ô∏è Fontes verificadas:', fontesDados.map(f => Array.isArray(f) ? f.length : 'N/A'));
            }
          }
          
          // üö® CORRE√á√ÉO CR√çTICA CHROME iOS: Atualizar window.nomesData ANTES de popular SELECT
          // Isso garante que o fallback use os nomes corrigidos
          if (isChromeIOS && cargoUP === 'ORGANISTA') {
            window.nomesData = [...nomesStrings];
          }
          
          // üö® CORRE√á√ÉO CR√çTICA CHROME iOS: Adicionar todos os nomes de uma vez usando DocumentFragment
          if (isChromeIOS && cargoUP === 'ORGANISTA') {
            const fragment = document.createDocumentFragment();
            
            nomesStrings.forEach((nome) => {
              try {
                const option = document.createElement('option');
                option.value = nome;
                option.textContent = nome;
                fragment.appendChild(option);
              } catch (err) {
                // Erro silencioso - continuar com pr√≥ximo nome
              }
            });
            
            // Adicionar todos os elementos de uma vez
            try {
              nomeEl.appendChild(fragment);
            } catch (err) {
              // Fallback: adicionar um por um
              nomesStrings.forEach((nome) => {
                try {
                  const option = document.createElement('option');
                  option.value = nome;
                  option.textContent = nome;
                  nomeEl.appendChild(option);
                } catch (err2) {
                  // Erro silencioso - continuar
                }
              });
            }
          } else {
            // Outras plataformas: adicionar um por um (comportamento normal)
            nomesStrings.forEach((nome) => {
              try {
                const option = document.createElement('option');
                option.value = nome;
                option.textContent = nome;
                nomeEl.appendChild(option);
              } catch (err) {
                // Erro silencioso - continuar
              }
            });
          }
          
          // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
          
          // Adicionar op√ß√£o manual
          const optionManual = document.createElement('option');
          optionManual.value = '__MANUAL_INPUT__';
          optionManual.textContent = '‚úèÔ∏è Adicionar novo nome manualmente';
          optionManual.style.backgroundColor = '#e3f2fd';
          optionManual.style.color = '#1976d2';
          optionManual.style.fontWeight = 'bold';
          nomeEl.appendChild(optionManual);
          
          // For√ßar renderiza√ß√£o (EXATAMENTE igual ao Safari que funciona)
          nomeEl.style.backgroundColor = '';
          nomeEl.style.display = 'block';
          nomeEl.style.visibility = 'visible';
          
          // For√ßar reflow para garantir renderiza√ß√£o (igual ao Safari)
          void nomeEl.offsetHeight;
          void nomeEl.offsetWidth;
          
          // Usar requestAnimationFrame para garantir renderiza√ß√£o no Chrome iOS e Android
          requestAnimationFrame(() => {
            void nomeEl.offsetHeight;
            void nomeEl.offsetWidth;
            
            // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
            const opcoesCount = nomeEl.options.length;
            if (opcoesCount > 1) {
              // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
              
              // üö® CORRE√á√ÉO ESPEC√çFICA CHROME iOS: Verificar se todos os nomes foram adicionados
              if (isChromeIOS && cargoUP === 'ORGANISTA') {
                // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
                const opcoesSemPlaceholder = opcoesCount - 1; // -1 para excluir placeholder
                const opcoesSemManual = opcoesCount - 2; // -2 para excluir placeholder e op√ß√£o manual
                const nomesEsperados = nomesStrings.length;
                
                // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
                // Se n√£o todos foram adicionados, tentar novamente com DocumentFragment
                if (opcoesSemManual < nomesEsperados) {
                  // Tentar adicionar novamente ap√≥s um delay
                  setTimeout(() => {
                    const nomeElChromeIOS = document.getElementById('nome');
                    if (nomeElChromeIOS && nomeElChromeIOS.tagName === 'SELECT') {
                      const opcoesAtuais = nomeElChromeIOS.options.length - 2; // -2 para excluir placeholder e op√ß√£o manual
                      if (opcoesAtuais < nomesEsperados && window.nomesData && window.nomesData.length > 0) {
                        // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
                        // Limpar SELECT
                        while (nomeElChromeIOS.firstChild) {
                          nomeElChromeIOS.removeChild(nomeElChromeIOS.firstChild);
                        }
                        // Adicionar primeira op√ß√£o
                        const primeiraOpcao = document.createElement('option');
                        primeiraOpcao.value = '';
                        primeiraOpcao.textContent = 'Selecione um nome da lista (ou digite, se offline)';
                        nomeElChromeIOS.appendChild(primeiraOpcao);
                        // üö® CORRE√á√ÉO CR√çTICA CHROME iOS: Verificar INSTRUTORA antes de adicionar nomes
                        let nomesParaAdicionar = [...(window.nomesData || [])];
                        
                        // Buscar INSTRUTORA em m√∫ltiplas fontes se n√£o estiver em nomesParaAdicionar
                        if (cargoUP === 'ORGANISTA') {
                          const fontesDados = [
                            organistaData,
                            dataFiltrada,
                            window._organistaDataAntesFiltroComum,
                            window._organistaDataCache
                          ].filter(Boolean);
                          
                          for (const fonte of fontesDados) {
                            if (Array.isArray(fonte) && fonte.length > 0) {
                              const instrutorasNaFonte = fonte.filter(r => 
                                r.cargo && (r.cargo.toUpperCase().includes('INSTRUTORA') || r.cargo.toUpperCase().includes('INSTRUTORAS'))
                              );
                              
                              if (instrutorasNaFonte.length > 0) {
                                const nomesInstrutoras = instrutorasNaFonte.map(r => {
                                  const nomeNorm = norm(r.nome);
                                  return nomeNorm.toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase());
                                });
                                
                                // Verificar se nomes de INSTRUTORA est√£o em nomesParaAdicionar
                                const instrutorasEmNomes = nomesParaAdicionar.filter(nome => 
                                  nomesInstrutoras.some(nomeInstr => nome.toLowerCase() === nomeInstr.toLowerCase())
                                );
                                
                                if (instrutorasEmNomes.length === 0) {
                                  console.error('üö® CHROME iOS - INSTRUTORA n√£o est√° em nomesParaAdicionar! Adicionando...');
                                  nomesInstrutoras.forEach(nomeInstr => {
                                    if (!nomesParaAdicionar.some(n => n.toLowerCase() === nomeInstr.toLowerCase())) {
                                      nomesParaAdicionar.push(nomeInstr);
                                      console.log('üîß CHROME iOS - Nome de INSTRUTORA adicionado:', nomeInstr);
                                    }
                                  });
                                  nomesParaAdicionar.sort((a,b)=>a.localeCompare(b,'pt-BR'));
                                }
                                break;
                              }
                            }
                          }
                        }
                        
                        // Adicionar TODOS os nomes (incluindo INSTRUTORA se foi adicionada)
                        nomesParaAdicionar.forEach((nome) => {
                          const option = document.createElement('option');
                          option.value = nome;
                          option.textContent = nome;
                          nomeElChromeIOS.appendChild(option);
                        });
                        
                        // Atualizar window.nomesData com a lista corrigida
                        window.nomesData = [...nomesParaAdicionar];
                        // Adicionar op√ß√£o manual
                        const optionManual = document.createElement('option');
                        optionManual.value = '__MANUAL_INPUT__';
                        optionManual.textContent = '‚úèÔ∏è Adicionar novo nome manualmente';
                        optionManual.style.backgroundColor = '#e3f2fd';
                        optionManual.style.color = '#1976d2';
                        optionManual.style.fontWeight = 'bold';
                        nomeElChromeIOS.appendChild(optionManual);
                        // Marcar como populado
                        nomeElChromeIOS.setAttribute('data-populado', 'true');
                        // For√ßar reflow
                        void nomeElChromeIOS.offsetHeight;
                        void nomeElChromeIOS.offsetWidth;
                        
                        // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
                      }
                    }
                  }, 300);
                }
              }
              
              // For√ßar foco no SELECT para garantir renderiza√ß√£o no mobile
              if (isMobile) {
                nomeEl.focus();
                nomeEl.blur();
              }
            } else {
              console.error('‚ùå ERRO: SELECT n√£o foi populado! Apenas', opcoesCount, 'op√ß√µes');
              console.error('‚ùå nomesStrings.length:', nomesStrings.length);
              console.error('‚ùå unique.length:', unique.length);
              
              // Tentar popular novamente se falhou
              if (nomesStrings.length > 0) {
                console.log('üîÑ Tentando popular novamente...');
                
                // üö® CORRE√á√ÉO CR√çTICA CHROME iOS: Verificar INSTRUTORA antes de repopular
                let nomesParaRepopular = [...nomesStrings];
                
                if (isChromeIOS && cargoUP === 'ORGANISTA') {
                  const fontesDadosRepopular = [
                    organistaData,
                    dataFiltrada,
                    window._organistaDataAntesFiltroComum,
                    window._organistaDataCache
                  ].filter(Boolean);
                  
                  for (const fonte of fontesDadosRepopular) {
                    if (Array.isArray(fonte) && fonte.length > 0) {
                      const instrutorasNaFonte = fonte.filter(r => 
                        r.cargo && (r.cargo.toUpperCase().includes('INSTRUTORA') || r.cargo.toUpperCase().includes('INSTRUTORAS'))
                      );
                      
                      if (instrutorasNaFonte.length > 0) {
                        const nomesInstrutoras = instrutorasNaFonte.map(r => {
                          const nomeNorm = norm(r.nome);
                          return nomeNorm.toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase());
                        });
                        
                        const instrutorasEmNomes = nomesParaRepopular.filter(nome => 
                          nomesInstrutoras.some(nomeInstr => nome.toLowerCase() === nomeInstr.toLowerCase())
                        );
                        
                        if (instrutorasEmNomes.length === 0) {
                          console.error('üö® CHROME iOS - INSTRUTORA n√£o est√° em nomesParaRepopular! Adicionando...');
                          nomesInstrutoras.forEach(nomeInstr => {
                            if (!nomesParaRepopular.some(n => n.toLowerCase() === nomeInstr.toLowerCase())) {
                              nomesParaRepopular.push(nomeInstr);
                            }
                          });
                          nomesParaRepopular.sort((a,b)=>a.localeCompare(b,'pt-BR'));
                        }
                        break;
                      }
                    }
                  }
                }
                
                while (nomeEl.firstChild) {
                  nomeEl.removeChild(nomeEl.firstChild);
                }
                const primeiraOpcao2 = document.createElement('option');
                primeiraOpcao2.value = '';
                primeiraOpcao2.textContent = 'Selecione um nome da lista (ou digite, se offline)';
                nomeEl.appendChild(primeiraOpcao2);
                nomesParaRepopular.forEach((nome) => {
                  const option = document.createElement('option');
                  option.value = nome;
                  option.textContent = nome;
                  nomeEl.appendChild(option);
                });
                const optionManual2 = document.createElement('option');
                optionManual2.value = '__MANUAL_INPUT__';
                optionManual2.textContent = '‚úèÔ∏è Adicionar novo nome manualmente';
                optionManual2.style.backgroundColor = '#e3f2fd';
                optionManual2.style.color = '#1976d2';
                optionManual2.style.fontWeight = 'bold';
                nomeEl.appendChild(optionManual2);
                void nomeEl.offsetHeight;
                void nomeEl.offsetWidth;
                console.log('üîÑ SELECT repopulado, agora tem', nomeEl.options.length, 'op√ß√µes');
              }
            }
          });
          
          // üö® PROTE√á√ÉO CR√çTICA: Marcar SELECT como populado para evitar limpeza acidental
          nomeEl.setAttribute('data-populado', 'true');
          nomeEl.setAttribute('data-populado-em', Date.now().toString());
          
          // Event listener para op√ß√£o manual
          nomeEl.removeEventListener('change', handleNomeSelectChangeManual);
          nomeEl.addEventListener('change', handleNomeSelectChangeManual);
          
          function handleNomeSelectChangeManual(e) {
            if (e.target.value === '__MANUAL_INPUT__') {
              const selectEl = e.target;
              const inputEl = document.createElement('input');
              inputEl.type = 'text';
              inputEl.id = 'nome';
              inputEl.name = 'nome';
              inputEl.className = 'form-control';
              inputEl.placeholder = 'Digite o nome completo...';
              inputEl.required = true;
              inputEl.setAttribute('data-nome-manual', 'true');
              inputEl.removeAttribute('readonly');
              inputEl.removeAttribute('disabled');
              inputEl.readOnly = false;
              inputEl.disabled = false;
              selectEl.parentNode.replaceChild(inputEl, selectEl);
              inputEl.focus();
            }
          }
          
          // üö® PROTE√á√ÉO ADICIONAL: Verificar ap√≥s um pequeno delay se o SELECT ainda est√° populado
          // üö® CORRE√á√ÉO ESPEC√çFICA CHROME iOS: Chrome iOS precisa de verifica√ß√£o especial
          setTimeout(() => {
            const nomeElVerificacao = document.getElementById('nome');
            if (nomeElVerificacao && nomeElVerificacao.tagName === 'SELECT') {
              const opcoesCount = nomeElVerificacao.options.length;
              const opcoesSemManual = opcoesCount - 2; // -2 para excluir placeholder e op√ß√£o manual
              const nomesEsperados = nomesStrings ? nomesStrings.length : (window.nomesData ? window.nomesData.length : 0);
              
              // üö® CORRE√á√ÉO ESPEC√çFICA CHROME iOS: Verificar se todos os nomes foram adicionados
              if (isChromeIOS && cargoUP === 'ORGANISTA' && nomesEsperados > 0) {
                console.log('üì± CHROME iOS - Verifica√ß√£o ap√≥s delay:', {
                  opcoesCount: opcoesCount,
                  opcoesSemManual: opcoesSemManual,
                  nomesEsperados: nomesEsperados,
                  match: opcoesSemManual === nomesEsperados
                });
                
                // Se n√£o todos foram adicionados, repopular
                if (opcoesSemManual < nomesEsperados) {
                  console.error('‚ùå CHROME iOS - Nem todos os nomes foram adicionados ap√≥s delay!', {
                    esperado: nomesEsperados,
                    opcoesSemManual: opcoesSemManual
                  });
                  
                  // Repopular com TODOS os nomes
                  if (window.nomesData && window.nomesData.length > 0) {
                    console.log('üö® CHROME iOS - Repopulando SELECT ap√≥s delay com TODOS os nomes...');
                    // Limpar SELECT
                    while (nomeElVerificacao.firstChild) {
                      nomeElVerificacao.removeChild(nomeElVerificacao.firstChild);
                    }
                    // Adicionar primeira op√ß√£o
                    const primeiraOpcao = document.createElement('option');
                    primeiraOpcao.value = '';
                    primeiraOpcao.textContent = 'Selecione um nome da lista (ou digite, se offline)';
                    nomeElVerificacao.appendChild(primeiraOpcao);
                    // Adicionar TODOS os nomes
                    let nomesAdicionadosDelay = 0;
                    window.nomesData.forEach((nome, index) => {
                      const option = document.createElement('option');
                      option.value = nome;
                      option.textContent = nome;
                      nomeElVerificacao.appendChild(option);
                      nomesAdicionadosDelay++;
                      
                      // Log a cada 10 nomes
                      if (index % 10 === 0 || index === window.nomesData.length - 1) {
                        console.log(`üì± CHROME iOS - Delay: Adicionando nome ${index + 1}/${window.nomesData.length}: ${nome}`);
                      }
                    });
                    // Adicionar op√ß√£o manual
                    const optionManual = document.createElement('option');
                    optionManual.value = '__MANUAL_INPUT__';
                    optionManual.textContent = '‚úèÔ∏è Adicionar novo nome manualmente';
                    optionManual.style.backgroundColor = '#e3f2fd';
                    optionManual.style.color = '#1976d2';
                    optionManual.style.fontWeight = 'bold';
                    nomeElVerificacao.appendChild(optionManual);
                    // Marcar como populado
                    nomeElVerificacao.setAttribute('data-populado', 'true');
                    // For√ßar reflow
                    void nomeElVerificacao.offsetHeight;
                    void nomeElVerificacao.offsetWidth;
                    const opcoesFinais = nomeElVerificacao.options.length - 2;
                    console.log('‚úÖ CHROME iOS - Repopula√ß√£o ap√≥s delay conclu√≠da:', nomesAdicionadosDelay, 'nomes (op√ß√µes:', opcoesFinais, ')');
                    
                    // Verificar novamente
                    if (opcoesFinais !== nomesEsperados) {
                      console.error('‚ùå CHROME iOS - AINDA n√£o todos os nomes foram adicionados ap√≥s delay!', {
                        esperado: nomesEsperados,
                        opcoesFinais: opcoesFinais
                      });
                    }
                  }
                } else {
                  console.log('‚úÖ CHROME iOS - Todos os nomes foram adicionados corretamente ap√≥s delay');
                }
              } else if (opcoesCount > 1) {
                console.log('‚úÖ SELECT ainda populado ap√≥s delay:', opcoesCount, 'op√ß√µes');
              } else {
                console.error('‚ùå ERRO CR√çTICO: SELECT foi limpo ap√≥s ser populado! Apenas', opcoesCount, 'op√ß√µes');
                // Tentar repopular se foi limpo acidentalmente
                if (nomesStrings && nomesStrings.length > 0) {
                  console.log('üîÑ Repopulando SELECT que foi limpo acidentalmente...');
                  while (nomeElVerificacao.firstChild) {
                    nomeElVerificacao.removeChild(nomeElVerificacao.firstChild);
                  }
                  const primeiraOpcao3 = document.createElement('option');
                  primeiraOpcao3.value = '';
                  primeiraOpcao3.textContent = 'Selecione um nome da lista (ou digite, se offline)';
                  nomeElVerificacao.appendChild(primeiraOpcao3);
                  nomesStrings.forEach((nome) => {
                    const option = document.createElement('option');
                    option.value = nome;
                    option.textContent = nome;
                    nomeElVerificacao.appendChild(option);
                  });
                  const optionManual3 = document.createElement('option');
                  optionManual3.value = '__MANUAL_INPUT__';
                  optionManual3.textContent = '‚úèÔ∏è Adicionar novo nome manualmente';
                  optionManual3.style.backgroundColor = '#e3f2fd';
                  optionManual3.style.color = '#1976d2';
                  optionManual3.style.fontWeight = 'bold';
                  nomeElVerificacao.appendChild(optionManual3);
                  nomeElVerificacao.setAttribute('data-populado', 'true');
                  void nomeElVerificacao.offsetHeight;
                  void nomeElVerificacao.offsetWidth;
                }
              }
            }
          }, 500);
        } else {
          // Sem nomes - converter para INPUT
          const inputEl = converterParaInput(nomeEl);
          if (inputEl) {
            inputEl.addEventListener('input', capturarClasseAutomaticamente);
          }
        }
      }
      
      // üö® CORRE√á√ÉO CR√çTICA MOBILE: Verificar se SELECT j√° foi populado, mas permitir atualizar se houver mais nomes
      // Isso √© CRUCIAL para garantir que todos os nomes sejam exibidos no mobile
      // üö® CORRE√á√ÉO ESPEC√çFICA CHROME iOS: Chrome iOS precisa de tratamento especial
      // üö® CORRE√á√ÉO ESPEC√çFICA XIAOMI/REDMI: Xiaomi/Redmi precisa de tratamento especial
      const nomeElCheck = findNomeField();
      let selectJaPopulado = false;
      if (nomeElCheck && nomeElCheck.tagName === 'SELECT' && nomeElCheck.options.length > 1) {
        // üö® CORRE√á√ÉO MOBILE: Se h√° mais nomes dispon√≠veis que op√ß√µes no SELECT, permitir atualizar
        const opcoesAtuais = nomeElCheck.options.length - 1; // -1 para excluir placeholder
        const nomesDisponiveis = unique ? unique.length : 0;
        
        // üö® CORRE√á√ÉO ESPEC√çFICA XIAOMI/REDMI: Xiaomi/Redmi sempre permite atualizar se houver nomes
        // üõ°Ô∏è REDMI NOTE 13: Garantir que sempre permite atualizar
        if ((isXiaomi || isRedmiNote13) && nomesDisponiveis > 0) {
          // üö® CORRE√á√ÉO XIAOMI: Sempre permitir atualizar em Xiaomi/Redmi para garantir que nomes sejam exibidos
          const deviceName = isRedmiNote13 ? 'REDMI NOTE 13' : 'XIAOMI/REDMI';
          console.log(`üì± ${deviceName} - SELECT tem ${opcoesAtuais} op√ß√µes, h√° ${nomesDisponiveis} nomes dispon√≠veis - permitindo atualizar`);
          selectJaPopulado = false; // Permitir atualizar
        } else if (isChromeIOS && nomesDisponiveis > opcoesAtuais) {
          // üö® CORRE√á√ÉO CHROME iOS: Chrome iOS sempre permite atualizar se houver mais nomes
          console.log(`üì± CHROME iOS - SELECT tem ${opcoesAtuais} op√ß√µes, mas h√° ${nomesDisponiveis} nomes dispon√≠veis - permitindo atualizar`);
          selectJaPopulado = false; // Permitir atualizar
        } else if (isMobile && nomesDisponiveis > opcoesAtuais) {
          // üö® CORRE√á√ÉO MOBILE: Tem mais nomes dispon√≠veis - permitir atualizar
          console.log(`üì± MOBILE - SELECT tem ${opcoesAtuais} op√ß√µes, mas h√° ${nomesDisponiveis} nomes dispon√≠veis - permitindo atualizar`);
          selectJaPopulado = false; // Permitir atualizar
        } else if (nomesDisponiveis === opcoesAtuais) {
          // Mesmo n√∫mero de nomes - n√£o atualizar
          selectJaPopulado = true;
        } else {
          // Menos nomes - n√£o atualizar (pode ser cache antigo)
          selectJaPopulado = true;
        }
      }
      
      // üö® CORRE√á√ÉO CHROME iOS: Verificar novamente ap√≥s um pequeno delay para garantir renderiza√ß√£o
      // Chrome iOS tem problemas espec√≠ficos com renderiza√ß√£o de SELECT
      if (isChromeIOS && nomeElCheck && nomeElCheck.tagName === 'SELECT' && unique && unique.length > 0) {
        // Aguardar um pouco para garantir que o SELECT foi renderizado
        setTimeout(() => {
          const nomeElChromeIOS = document.getElementById('nome');
          if (nomeElChromeIOS && nomeElChromeIOS.tagName === 'SELECT') {
            // Se o SELECT n√£o foi populado corretamente, popular agora
            const opcoesAtuais = nomeElChromeIOS.options.length - 2; // -2 para excluir placeholder e op√ß√£o manual
            const nomesDisponiveis = unique ? unique.length : 0;
            
            console.log('üì± CHROME iOS - Verifica√ß√£o no delay:', {
              opcoesAtuais: opcoesAtuais,
              nomesDisponiveis: nomesDisponiveis,
              windowNomesDataLength: window.nomesData ? window.nomesData.length : 0,
              precisaRepopular: opcoesAtuais < nomesDisponiveis
            });
            
            if (opcoesAtuais < nomesDisponiveis && window.nomesData && window.nomesData.length > 0) {
              console.log('üö® CHROME iOS: SELECT n√£o foi populado corretamente, populando agora...');
              // Limpar SELECT
              while (nomeElChromeIOS.firstChild) {
                nomeElChromeIOS.removeChild(nomeElChromeIOS.firstChild);
              }
              // Adicionar primeira op√ß√£o
              const primeiraOpcao = document.createElement('option');
              primeiraOpcao.value = '';
              primeiraOpcao.textContent = 'Selecione um nome da lista (ou digite, se offline)';
              nomeElChromeIOS.appendChild(primeiraOpcao);
              // Adicionar TODOS os nomes
              const nomesStrings = window.nomesData.map(nome => {
                return typeof nome === 'string' ? nome : (nome?.nome || String(nome));
              }).filter(Boolean);
              
              let nomesAdicionadosChromeIOS = 0;
              nomesStrings.forEach((nome, index) => {
                const option = document.createElement('option');
                option.value = nome;
                option.textContent = nome;
                nomeElChromeIOS.appendChild(option);
                nomesAdicionadosChromeIOS++;
                
                // Log a cada 10 nomes
                if (index % 10 === 0 || index === nomesStrings.length - 1) {
                  console.log(`üì± CHROME iOS - Delay: Adicionando nome ${index + 1}/${nomesStrings.length}: ${nome}`);
                }
              });
              
              // Adicionar op√ß√£o manual
              const optionManual = document.createElement('option');
              optionManual.value = '__MANUAL_INPUT__';
              optionManual.textContent = '‚úèÔ∏è Adicionar novo nome manualmente';
              optionManual.style.backgroundColor = '#e3f2fd';
              optionManual.style.color = '#1976d2';
              optionManual.style.fontWeight = 'bold';
              nomeElChromeIOS.appendChild(optionManual);
              // Marcar como populado
              nomeElChromeIOS.setAttribute('data-populado', 'true');
              // For√ßar reflow
              void nomeElChromeIOS.offsetHeight;
              void nomeElChromeIOS.offsetWidth;
              const opcoesFinais = nomeElChromeIOS.options.length - 2;
              console.log('‚úÖ CHROME iOS: SELECT populado com', nomesAdicionadosChromeIOS, 'nomes (op√ß√µes:', opcoesFinais, ')');
              
              // Verificar novamente
              if (opcoesFinais !== nomesDisponiveis) {
                console.error('‚ùå CHROME iOS - AINDA n√£o todos os nomes foram adicionados ap√≥s delay!', {
                  esperado: nomesDisponiveis,
                  opcoesFinais: opcoesFinais,
                  nomesAdicionados: nomesAdicionadosChromeIOS
                });
              } else {
                console.log('‚úÖ CHROME iOS - Todos os nomes foram adicionados corretamente ap√≥s delay');
              }
            }
          }
        }, 500); // Delay maior para Chrome iOS
      }
      
      // üö® CORRE√á√ÉO ANDROID: Verificar novamente ap√≥s um pequeno delay para garantir renderiza√ß√£o
      // No Android, pode haver um problema de timing onde o SELECT √© populado mas a verifica√ß√£o falha
      if (isAndroid && nomeElCheck && nomeElCheck.tagName === 'SELECT' && unique && unique.length > 0) {
        // Aguardar um pouco para garantir que o SELECT foi renderizado
        setTimeout(() => {
          const nomeElAndroid = document.getElementById('nome');
          if (nomeElAndroid && nomeElAndroid.tagName === 'SELECT') {
            // Se o SELECT n√£o foi populado corretamente, popular agora
            if (nomeElAndroid.options.length <= 1 && window.nomesData && window.nomesData.length > 0) {
              console.log('üö® ANDROID: SELECT n√£o foi populado corretamente, populando agora...');
              // Limpar SELECT
              while (nomeElAndroid.firstChild) {
                nomeElAndroid.removeChild(nomeElAndroid.firstChild);
              }
              // Adicionar primeira op√ß√£o
              const primeiraOpcao = document.createElement('option');
              primeiraOpcao.value = '';
              primeiraOpcao.textContent = 'Selecione um nome da lista (ou digite, se offline)';
              nomeElAndroid.appendChild(primeiraOpcao);
              // Adicionar nomes
              const nomesStrings = window.nomesData.map(nome => {
                return typeof nome === 'string' ? nome : (nome?.nome || String(nome));
              }).filter(Boolean);
              nomesStrings.forEach((nome) => {
                const option = document.createElement('option');
                option.value = nome;
                option.textContent = nome;
                nomeElAndroid.appendChild(option);
              });
              // Adicionar op√ß√£o manual
              const optionManual = document.createElement('option');
              optionManual.value = '__MANUAL_INPUT__';
              optionManual.textContent = '‚úèÔ∏è Adicionar novo nome manualmente';
              optionManual.style.backgroundColor = '#e3f2fd';
              optionManual.style.color = '#1976d2';
              optionManual.style.fontWeight = 'bold';
              nomeElAndroid.appendChild(optionManual);
              // Marcar como populado
              nomeElAndroid.setAttribute('data-populado', 'true');
              // For√ßar reflow
              void nomeElAndroid.offsetHeight;
              void nomeElAndroid.offsetWidth;
              console.log('‚úÖ ANDROID: SELECT populado com', nomesStrings.length, 'nomes');
            } else if (nomeElAndroid.options.length > 1) {
              console.log('‚úÖ ANDROID: SELECT j√° foi populado corretamente com', nomeElAndroid.options.length, 'op√ß√µes');
            }
          }
        }, 100); // Pequeno delay para garantir renderiza√ß√£o
      }
      
      // üö® CORRE√á√ÉO XIAOMI/REDMI: Verificar novamente ap√≥s um delay para garantir renderiza√ß√£o
      // Xiaomi/Redmi tem problemas espec√≠ficos com renderiza√ß√£o de SELECT, similar ao Chrome iOS
      // üõ°Ô∏è REDMI NOTE 13: Inclu√≠do especificamente para garantir funcionamento
      if ((isXiaomi || isRedmiNote13) && nomeElCheck && nomeElCheck.tagName === 'SELECT' && unique && unique.length > 0) {
        // Aguardar um pouco para garantir que o SELECT foi renderizado
        setTimeout(() => {
          const nomeElXiaomi = document.getElementById('nome');
          if (nomeElXiaomi && nomeElXiaomi.tagName === 'SELECT') {
            // Se o SELECT n√£o foi populado corretamente, popular agora
            const opcoesAtuais = nomeElXiaomi.options.length - 2; // -2 para excluir placeholder e op√ß√£o manual
            const nomesDisponiveis = unique ? unique.length : 0;
            
            console.log('üì± XIAOMI/REDMI - Verifica√ß√£o no delay:', {
              opcoesAtuais: opcoesAtuais,
              nomesDisponiveis: nomesDisponiveis,
              windowNomesDataLength: window.nomesData ? window.nomesData.length : 0,
              precisaRepopular: opcoesAtuais < nomesDisponiveis || nomeElXiaomi.options.length <= 1
            });
            
            if ((opcoesAtuais < nomesDisponiveis || nomeElXiaomi.options.length <= 1) && window.nomesData && window.nomesData.length > 0) {
              console.log('üö® XIAOMI/REDMI: SELECT n√£o foi populado corretamente, populando agora...');
              // Limpar SELECT
              while (nomeElXiaomi.firstChild) {
                nomeElXiaomi.removeChild(nomeElXiaomi.firstChild);
              }
              // Adicionar primeira op√ß√£o
              const primeiraOpcao = document.createElement('option');
              primeiraOpcao.value = '';
              primeiraOpcao.textContent = 'Selecione um nome da lista (ou digite, se offline)';
              nomeElXiaomi.appendChild(primeiraOpcao);
              // Adicionar TODOS os nomes
              const nomesStrings = window.nomesData.map(nome => {
                return typeof nome === 'string' ? nome : (nome?.nome || String(nome));
              }).filter(Boolean);
              
              let nomesAdicionadosXiaomi = 0;
              nomesStrings.forEach((nome, index) => {
                const option = document.createElement('option');
                option.value = nome;
                option.textContent = nome;
                nomeElXiaomi.appendChild(option);
                nomesAdicionadosXiaomi++;
                
                // Log a cada 10 nomes
                if (index % 10 === 0 || index === nomesStrings.length - 1) {
                  console.log(`üì± XIAOMI/REDMI - Delay: Adicionando nome ${index + 1}/${nomesStrings.length}: ${nome}`);
                }
              });
              
              // Adicionar op√ß√£o manual
              const optionManual = document.createElement('option');
              optionManual.value = '__MANUAL_INPUT__';
              optionManual.textContent = '‚úèÔ∏è Adicionar novo nome manualmente';
              optionManual.style.backgroundColor = '#e3f2fd';
              optionManual.style.color = '#1976d2';
              optionManual.style.fontWeight = 'bold';
              nomeElXiaomi.appendChild(optionManual);
              // Marcar como populado
              nomeElXiaomi.setAttribute('data-populado', 'true');
              // For√ßar reflow
              void nomeElXiaomi.offsetHeight;
              void nomeElXiaomi.offsetWidth;
              const opcoesFinais = nomeElXiaomi.options.length - 2;
              console.log('‚úÖ XIAOMI/REDMI: SELECT populado com', nomesAdicionadosXiaomi, 'nomes (op√ß√µes:', opcoesFinais, ')');
              
              // Verificar novamente
              if (opcoesFinais !== nomesDisponiveis) {
                console.error('‚ùå XIAOMI/REDMI - AINDA n√£o todos os nomes foram adicionados ap√≥s delay!', {
                  esperado: nomesDisponiveis,
                  opcoesFinais: opcoesFinais,
                  nomesAdicionados: nomesAdicionadosXiaomi
                });
              } else {
                console.log('‚úÖ XIAOMI/REDMI - Todos os nomes foram adicionados corretamente ap√≥s delay');
              }
            } else if (nomeElXiaomi.options.length > 1) {
              console.log('‚úÖ XIAOMI/REDMI: SELECT j√° foi populado corretamente com', nomeElXiaomi.options.length, 'op√ß√µes');
            }
          }
        }, 500); // Delay maior para Xiaomi/Redmi (similar ao Chrome iOS)
      }
      
      // üö® CORRE√á√ÉO MOBILE: Chamar populateNomesInput se SELECT N√ÉO foi populado OU se h√° mais nomes dispon√≠veis
      // Isso garante que todos os nomes sejam exibidos no mobile
      // üö® CORRE√á√ÉO ESPEC√çFICA CHROME iOS: Chrome iOS sempre chama populateNomesInput se houver mais nomes
      // üö® CORRE√á√ÉO ESPEC√çFICA XIAOMI/REDMI: Xiaomi/Redmi sempre chama populateNomesInput se houver nomes
      // üõ°Ô∏è REDMI NOTE 13: Garantir que sempre popula a lista de nomes
      if (!selectJaPopulado || (isChromeIOS && cargoUP === 'ORGANISTA' && unique && unique.length > 0) || (isXiaomi && unique && unique.length > 0) || (isRedmiNote13 && unique && unique.length > 0)) {
        // üö® DEBUG MOBILE: Log espec√≠fico para mobile
        if (isMobile && cargoUP === 'ORGANISTA') {
          console.log('üì± MOBILE - Chamando populateNomesInput com', unique.length, 'nomes');
        }
        
        // üö® DEBUG CHROME iOS: Log espec√≠fico para Chrome iOS
        if (isChromeIOS && cargoUP === 'ORGANISTA') {
          const nomeElCheck2 = findNomeField();
          const opcoesAtuais = nomeElCheck2 && nomeElCheck2.tagName === 'SELECT' ? nomeElCheck2.options.length - 2 : 0;
          const nomesDisponiveis = unique ? unique.length : 0;
          console.log('üì± CHROME iOS - Chamando populateNomesInput:', {
            opcoesAtuais: opcoesAtuais,
            nomesDisponiveis: nomesDisponiveis,
            selectJaPopulado: selectJaPopulado,
            forcarAtualizacao: isChromeIOS && nomesDisponiveis > opcoesAtuais
          });
        }
        
        populateNomesInput(nomeEl, unique);
      } else if (isMobile && cargoUP === 'ORGANISTA') {
        // üö® DEBUG MOBILE: Log quando n√£o est√° atualizando
        const nomeElCheck2 = findNomeField();
        const opcoesAtuais = nomeElCheck2 && nomeElCheck2.tagName === 'SELECT' ? nomeElCheck2.options.length - 1 : 0;
        const nomesDisponiveis = unique ? unique.length : 0;
        console.log('üì± MOBILE - SELECT j√° populado, n√£o atualizando:', {
          opcoesAtuais: opcoesAtuais,
          nomesDisponiveis: nomesDisponiveis,
          match: opcoesAtuais === nomesDisponiveis
        });
      }
      
      // üö® CORRE√á√ÉO ESPEC√çFICA CHROME iOS: Verifica√ß√£o final ap√≥s populateNomesInput
      // Garantir que todos os nomes foram adicionados no Chrome iOS
      if (isChromeIOS && cargoUP === 'ORGANISTA' && unique && unique.length > 0) {
        setTimeout(() => {
          const nomeElChromeIOSFinal = document.getElementById('nome');
          if (nomeElChromeIOSFinal && nomeElChromeIOSFinal.tagName === 'SELECT') {
            const opcoesFinais = nomeElChromeIOSFinal.options.length - 2; // -2 para excluir placeholder e op√ß√£o manual
            const nomesEsperados = unique.length;
            
            console.log('üì± CHROME iOS - Verifica√ß√£o final:', {
              opcoesFinais: opcoesFinais,
              nomesEsperados: nomesEsperados,
              match: opcoesFinais === nomesEsperados
            });
            
            // Se ainda n√£o todos foram adicionados, for√ßar repopula√ß√£o
            if (opcoesFinais < nomesEsperados && window.nomesData && window.nomesData.length > 0) {
              console.error('‚ùå CHROME iOS - Verifica√ß√£o final: Nem todos os nomes foram adicionados!', {
                esperado: nomesEsperados,
                opcoesFinais: opcoesFinais
              });
              
              console.log('üö® CHROME iOS - For√ßando repopula√ß√£o final com TODOS os nomes...');
              // Limpar SELECT
              while (nomeElChromeIOSFinal.firstChild) {
                nomeElChromeIOSFinal.removeChild(nomeElChromeIOSFinal.firstChild);
              }
              // Adicionar primeira op√ß√£o
              const primeiraOpcao = document.createElement('option');
              primeiraOpcao.value = '';
              primeiraOpcao.textContent = 'Selecione um nome da lista (ou digite, se offline)';
              nomeElChromeIOSFinal.appendChild(primeiraOpcao);
              // Adicionar TODOS os nomes
              let nomesAdicionadosFinal = 0;
              window.nomesData.forEach((nome, index) => {
                const option = document.createElement('option');
                option.value = nome;
                option.textContent = nome;
                nomeElChromeIOSFinal.appendChild(option);
                nomesAdicionadosFinal++;
              });
              // Adicionar op√ß√£o manual
              const optionManual = document.createElement('option');
              optionManual.value = '__MANUAL_INPUT__';
              optionManual.textContent = '‚úèÔ∏è Adicionar novo nome manualmente';
              optionManual.style.backgroundColor = '#e3f2fd';
              optionManual.style.color = '#1976d2';
              optionManual.style.fontWeight = 'bold';
              nomeElChromeIOSFinal.appendChild(optionManual);
              // Marcar como populado
              nomeElChromeIOSFinal.setAttribute('data-populado', 'true');
              // For√ßar reflow
              void nomeElChromeIOSFinal.offsetHeight;
              void nomeElChromeIOSFinal.offsetWidth;
              const opcoesFinaisAposRepopulacao = nomeElChromeIOSFinal.options.length - 2;
              console.log('‚úÖ CHROME iOS - Repopula√ß√£o final conclu√≠da:', nomesAdicionadosFinal, 'nomes (op√ß√µes:', opcoesFinaisAposRepopulacao, ')');
              
              // Verifica√ß√£o final
              if (opcoesFinaisAposRepopulacao !== nomesEsperados) {
                console.error('‚ùå CHROME iOS - ERRO CR√çTICO: Ainda n√£o todos os nomes foram adicionados ap√≥s repopula√ß√£o final!', {
                  esperado: nomesEsperados,
                  opcoesFinaisAposRepopulacao: opcoesFinaisAposRepopulacao
                });
              } else {
                console.log('‚úÖ CHROME iOS - SUCESSO: Todos os nomes foram adicionados ap√≥s repopula√ß√£o final!');
              }
            } else {
              console.log('‚úÖ CHROME iOS - Verifica√ß√£o final: Todos os nomes foram adicionados corretamente');
            }
          }
        }, 1000); // Delay maior para verifica√ß√£o final no Chrome iOS
      }
      
      // üö® CHROME iOS FIX: Esconder indicador de carregamento ap√≥s popular SELECT
      // Garantir que o indicador seja escondido SEMPRE ap√≥s popular SELECT
      if (nomeEl && nomeEl.tagName === 'SELECT' && unique && unique.length > 0) {
        console.log('üö® iOS: Escondendo indicador de carregamento ap√≥s popular SELECT');
        if (isMobile) {
          hideLoadingAlert();
        } else {
          hideLoadingIndicator();
        }
      }
      
      console.log('‚úÖ Nomes carregados com sucesso:', unique.length, 'para', { comumVal, instVal, cargoVal, variacoesCargo });
      
      // üö® CORRE√á√ÉO ANDROID: Verifica√ß√£o final para garantir que o SELECT foi populado
      // No Android, pode haver problemas de timing onde o SELECT n√£o √© populado corretamente
      if (isAndroid && unique && unique.length > 0) {
        setTimeout(() => {
          const nomeElFinal = document.getElementById('nome');
          if (nomeElFinal && nomeElFinal.tagName === 'SELECT') {
            // Se o SELECT n√£o foi populado, popular agora
            if (nomeElFinal.options.length <= 1 && window.nomesData && window.nomesData.length > 0) {
              console.log('üö® ANDROID: Verifica√ß√£o final - SELECT n√£o foi populado, populando agora...');
              // Limpar SELECT
              while (nomeElFinal.firstChild) {
                nomeElFinal.removeChild(nomeElFinal.firstChild);
              }
              // Adicionar primeira op√ß√£o
              const primeiraOpcao = document.createElement('option');
              primeiraOpcao.value = '';
              primeiraOpcao.textContent = 'Selecione um nome da lista (ou digite, se offline)';
              nomeElFinal.appendChild(primeiraOpcao);
              // Adicionar nomes
              const nomesStrings = window.nomesData.map(nome => {
                return typeof nome === 'string' ? nome : (nome?.nome || String(nome));
              }).filter(Boolean);
              nomesStrings.forEach((nome) => {
                const option = document.createElement('option');
                option.value = nome;
                option.textContent = nome;
                nomeElFinal.appendChild(option);
              });
              // Adicionar op√ß√£o manual
              const optionManual = document.createElement('option');
              optionManual.value = '__MANUAL_INPUT__';
              optionManual.textContent = '‚úèÔ∏è Adicionar novo nome manualmente';
              optionManual.style.backgroundColor = '#e3f2fd';
              optionManual.style.color = '#1976d2';
              optionManual.style.fontWeight = 'bold';
              nomeElFinal.appendChild(optionManual);
              // Marcar como populado
              nomeElFinal.setAttribute('data-populado', 'true');
              // For√ßar reflow
              void nomeElFinal.offsetHeight;
              void nomeElFinal.offsetWidth;
              console.log('‚úÖ ANDROID: Verifica√ß√£o final - SELECT populado com', nomesStrings.length, 'nomes');
            } else if (nomeElFinal.options.length > 1) {
              console.log('‚úÖ ANDROID: Verifica√ß√£o final - SELECT j√° foi populado corretamente com', nomeElFinal.options.length, 'op√ß√µes');
            }
          }
        }, 200); // Delay maior para garantir que todas as opera√ß√µes anteriores terminaram
      }
      
      // üöÄ OTIMIZA√á√ÉO MOBILE: Log unificado para Android e iOS (mesmo comportamento)
      // Removido log espec√≠fico de iOS - usar logs gerais para ambas as plataformas
       
       // Salva dados no cache para uso offline
       if (unique.length > 0) {
         saveNomesToCache(unique, comumVal, instVal, cargoVal);
         
         // Mostra toast informativo para instrutores
         if (cargoVal.toLowerCase().includes('instrutor')) {
           const instrutoresEncontrados = unique.filter(r => r.cargo && r.cargo.toUpperCase().includes('INSTRUTOR'));
           if (instrutoresEncontrados.length > 0) {
             showToast('info', 'Instrutores encontrados', 
               `Encontrados ${instrutoresEncontrados.length} instrutor(es) de ${instVal}`, 3000);
           }
         }
       }
       
       if (isMobile) {
         hideLoadingAlert();
       } else {
         hideLoadingIndicator();
       }
     } catch (e) {
       console.error('‚ùå Erro geral em loadNomes:', e);
       console.log('üîÑ Tentando carregar dados offline...');
       
       // Tenta carregar dados do cache quando h√° erro
       try {
         // Recoleta os valores dos campos para usar no cache
         const comumEl = findComumField();
         const instEl = findInstrumentField();
         const cargoEl = findCargoField();
         const nomeEl = findNomeField();
         
         if (comumEl && instEl && cargoEl && nomeEl) {
           const comumVal = norm(comumEl.value);
           const instVal = normalizeInstrument(instEl.value);
           const cargoVal = norm(cargoEl.value);
           const cargoUP = ucase(cargoVal);
           const precisaInst = ['MUSICO','MUSICO(A)','M√öSICO','M√öSICO(A)'].includes(cargoUP) || 
                               ['M√öSICO','M√öSICO(A)'].includes(upper(cargoVal)) ||
                               cargoUP === 'ORGANISTA' ||
                               cargoUP === 'EXAMINADORA' ||
                               cargoUP === 'INSTRUTOR' ||
                               (cargoVal.toLowerCase().includes('secret√°ria') && cargoVal.toLowerCase().includes('m√∫sica'));
           
           const cachedData = loadNomesFromCache(comumVal, instVal, cargoVal, cargoUP, precisaInst);
           if (cachedData.length > 0) {
             console.log('‚úÖ Dados carregados do cache offline:', cachedData.length);
             populateNomesInput(nomeEl, cachedData);
             // showToast('info', 'Dados carregados offline', `Encontrados ${cachedData.length} nomes no cache`, 3000); // Removido - alerta desnecess√°rio
             return;
           }
         }
       } catch (cacheError) {
         console.error('‚ùå Erro ao carregar cache:', cacheError);
       }
       
       // Se n√£o conseguiu carregar do cache, permite digita√ß√£o manual
       console.log('üìù Permitindo digita√ß√£o manual...');
       const nomeEl = findNomeField();
       if (nomeEl) {
         populateNomesInput(nomeEl, []);
       }
       // showToast('warning', 'Modo offline', 'Digite o nome manualmente', 3000); // Removido - alerta desnecess√°rio
       
       // Esconde indicador de carregamento
       if (isMobile) {
         hideLoadingAlert();
       } else {
         hideLoadingIndicator();
       }
       
       console.log('‚úÖ Fun√ß√£o loadNomes finalizada (fallback) - Request ID:', currentRequestId);
     }
     
     // üîß GARANTIA: Sempre esconde indicador de carregamento ao finalizar
     if (isMobile) {
       hideLoadingAlert();
     } else {
       hideLoadingIndicator();
     }
     
     console.log('‚úÖ Fun√ß√£o loadNomes finalizada - Request ID:', currentRequestId);
   }
   
   // Fun√ß√£o auxiliar para reconverter INPUT para SELECT quando h√° resultados
   function reconverterParaSelect(inputEl, unique) {
     console.log('üîÑ Reconvertendo INPUT para SELECT');
     
     // Verifica se o elemento e seu parent existem
     if (!inputEl || !inputEl.parentNode) {
       console.error('‚ùå Elemento ou parentNode n√£o encontrado para reconvers√£o');
       return null;
     }
     
     // Verifica se o elemento ainda est√° no DOM
     if (!document.contains(inputEl)) {
       console.error('‚ùå Elemento n√£o est√° mais no DOM para reconvers√£o');
       return null;
     }
     
     // Verifica se unique √© um array v√°lido
     if (!Array.isArray(unique) || unique.length === 0) {
       console.error('‚ùå Array unique inv√°lido ou vazio para reconvers√£o:', unique);
       return null;
     }
     
     // Cria novo elemento SELECT
     const selectEl = document.createElement('select');
     selectEl.id = 'nome';
     selectEl.className = 'form-select';
     selectEl.required = true;
     selectEl.innerHTML =
       '<option value="">Selecione um nome da lista (ou digite, se offline)</option>' +
       unique.map(v => `<option value="${v}">${v}</option>`).join('') +
       '<option value="__MANUAL_INPUT__" style="background-color: #e3f2fd; color: #1976d2; font-weight: bold;">‚úèÔ∏è Adicionar novo nome manualmente</option>';
     
     // Copia outros atributos importantes
     if (inputEl.hasAttribute('name')) {
       selectEl.setAttribute('name', inputEl.getAttribute('name'));
     }
     
     // Substitui o INPUT pelo SELECT de forma segura
     try {
       inputEl.parentNode.replaceChild(selectEl, inputEl);
       
       // Adiciona eventos ao novo elemento
       selectEl.addEventListener('change', capturarClasseAutomaticamente);
       selectEl.addEventListener('input', capturarClasseAutomaticamente);
       
       // Adiciona event listener espec√≠fico para a op√ß√£o manual
       selectEl.addEventListener('change', function(event) {
         console.log('üîç DEBUG - Event change detectado no SELECT (reconverter):', event.target.value);
         if (event.target.value === '__MANUAL_INPUT__') {
           console.log('üîç DEBUG - Op√ß√£o manual selecionada, convertendo...');
           setTimeout(() => {
             converterParaInputManual(event.target);
           }, 50);
         }
       });
       
       // Adiciona event listener de clique para garantir que funcione
       selectEl.addEventListener('click', function(event) {
         console.log('üîç DEBUG - Click detectado no SELECT (reconverter)');
       });
       
       console.log('‚úÖ INPUT reconvertido para SELECT com sucesso');
       return selectEl;
     } catch (error) {
       console.error('‚ùå Erro ao reconverter INPUT para SELECT:', error);
       return null;
     }
     console.log('üö®üö®üö® EVENT LISTENERS ADICIONADOS NO RECONVERTER - TESTE AGORA! üö®üö®üö®');
     
     return selectEl;
   }
   
   // Fun√ß√£o para preencher instrumento automaticamente quando selecionar nome
   async function preencherInstrumentoAutomaticamente(nomeSelecionado, comumVal, cargoVal, instEl) {
     console.log('üéµ Preenchendo instrumento automaticamente para:', nomeSelecionado);
     
     // üîß CORRE√á√ÉO CR√çTICA: Busca o instrumento atual para usar na chave de cache correta
     const instValAtual = normalizeInstrument(getFieldValue(instEl) || '');
     
     console.log('üîç DEBUG - Valores para buscar cache:', {
       nomeSelecionado,
       comumVal,
       cargoVal,
       instValAtual,
       instElValue: getFieldValue(instEl)
     });
     
     // üîß CORRE√á√ÉO CR√çTICA: Usa a mesma fun√ß√£o getCacheKey que loadNomes usa (com instVal)
     // Isso garante que encontra os dados corretos mesmo quando h√° instrumento selecionado
     let cacheKey = '';
     if (instValAtual) {
       // Se h√° instrumento, usa a chave com instrumento (mesma l√≥gica do loadNomes)
       cacheKey = getCacheKey(CACHE_KEYS.NOMES, { comumVal, instVal: instValAtual, cargoVal });
       console.log('üîç DEBUG - Usando chave de cache COM instrumento:', cacheKey);
     } else {
       // Se n√£o h√° instrumento, tenta sem instrumento (fallback)
       cacheKey = getCacheKey(CACHE_KEYS.NOMES, { comumVal, instVal: '', cargoVal });
       console.log('üîç DEBUG - Usando chave de cache SEM instrumento:', cacheKey);
     }
     
     // Tenta buscar no cache com a chave correta
     let dadosCompletos = getCache(cacheKey + '_dados');
     
     // üîß CORRE√á√ÉO CR√çTICA: Se n√£o encontrou, tenta outras chaves poss√≠veis (para clarinete baixo)
     if ((!dadosCompletos || dadosCompletos.length === 0) && instValAtual) {
       // Tenta com varia√ß√µes do instrumento (para clarinete baixo)
       const instValUpper = instValAtual.toUpperCase();
       if (instValUpper.includes('CLARINETE BAIXO') || instValUpper.includes('CLARONE')) {
         // Tenta com diferentes normaliza√ß√µes
         const variacoes = [
           'CLARINETE BAIXO (CLARONE)',
           'CLARINETE BAIXO',
           'CLARONE'
         ];
         
         for (const variacao of variacoes) {
           const cacheKeyVariacao = getCacheKey(CACHE_KEYS.NOMES, { comumVal, instVal: variacao, cargoVal });
           console.log('üîç DEBUG - Tentando chave de cache com varia√ß√£o:', cacheKeyVariacao);
           dadosCompletos = getCache(cacheKeyVariacao + '_dados');
           if (dadosCompletos && dadosCompletos.length > 0) {
             console.log('‚úÖ Dados encontrados com varia√ß√£o:', variacao);
             cacheKey = cacheKeyVariacao;
             break;
           }
         }
       }
     }
     
     if (dadosCompletos && Array.isArray(dadosCompletos) && dadosCompletos.length > 0) {
       console.log('üîç DEBUG - Dados completos encontrados no cache:', dadosCompletos.length, 'registros');
       // Busca o registro do nome selecionado
        // üö® CORRE√á√ÉO: Normalizar nome selecionado uma vez antes do loop
        const nomeSelecionadoNormalizado = norm(nomeSelecionado).toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase());
        
        const registro = dadosCompletos.find(r => {
          const nomeNormalizado = norm(r.nome).toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase());
          return nomeNormalizado === nomeSelecionadoNormalizado;
        });
        
        // Log apenas se encontrar o registro (evita spam)
        if (registro) {
          console.log('‚úÖ Match encontrado no cache:', { nome: registro.nome, instrumento: registro.instrumento });
        }
       
       if (registro && registro.instrumento) {
         // üö® CORRE√á√ÉO CR√çTICA: S√≥ preencher instrumento se o campo estiver vazio
         // Se j√° h√° um instrumento selecionado, manter o que o usu√°rio escolheu
         const instrumentoAtual = getFieldValue(instEl) || '';
         if (!instrumentoAtual || instrumentoAtual.trim() === '') {
           // üîß CORRE√á√ÉO CR√çTICA: Normaliza o instrumento antes de atribuir (garante clarinete baixo correto)
           const instrumentoNormalizado = normalizeInstrument(registro.instrumento);
           console.log('üéµ Instrumento encontrado no cache e preenchido:', { 
             nome: registro.nome, 
             instrumentoOriginal: registro.instrumento,
             instrumentoNormalizado: instrumentoNormalizado
           });
           instEl.value = instrumentoNormalizado;
         } else {
           console.log('üéµ Instrumento j√° est√° preenchido, mantendo:', instrumentoAtual);
         }
         return;
       } else {
         console.log('‚ö†Ô∏è Registro encontrado no cache mas sem instrumento ou nome n√£o coincide');
       }
     } else {
       console.log('‚ö†Ô∏è Dados completos n√£o encontrados no cache ou vazios');
     }
     
     // Se n√£o encontrou no cache, faz consulta direta
     try {
       console.log('üîç Fazendo consulta direta para encontrar instrumento...');
      // üö® CORRE√á√ÉO CR√çTICA: SEMPRE buscar ambas as varia√ß√µes (com e sem acento)
      // üö® CORRE√á√ÉO: Definir comumValSemAcento antes de usar
      const comumValSemAcento = noacc(comumVal);
      const consultaDireta = await sb
        .from(TABLE_CATALOGO)
        .select('nome, instrumento')
        .or(`comum.ilike.%${comumVal}%,comum.ilike.%${comumValSemAcento}%`)
        .ilike('cargo', `%${cargoVal}%`)
        .eq('ativo', true);
       
      if (consultaDireta.data && consultaDireta.data.length > 0) {
        // üö® CORRE√á√ÉO: Normalizar nome selecionado uma vez antes do loop (evita normaliza√ß√£o repetida)
        const nomeSelecionadoNormalizado = norm(nomeSelecionado).toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase());
        
        const registro = consultaDireta.data.find(r => {
          const nomeNormalizado = norm(r.nome).toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase());
          return nomeNormalizado === nomeSelecionadoNormalizado;
        });
        
        if (registro && registro.instrumento) {
          // üö® CORRE√á√ÉO CR√çTICA: S√≥ preencher instrumento se o campo estiver vazio
          // Se j√° h√° um instrumento selecionado, manter o que o usu√°rio escolheu
          const instrumentoAtual = getFieldValue(instEl) || '';
          if (!instrumentoAtual || instrumentoAtual.trim() === '') {
            // üîß CORRE√á√ÉO CR√çTICA: Normaliza o instrumento antes de atribuir
            const instrumentoNormalizado = normalizeInstrument(registro.instrumento);
            console.log('üéµ Instrumento encontrado via consulta direta e preenchido:', {
               nome: registro.nome, 
               instrumentoOriginal: registro.instrumento,
               instrumentoNormalizado: instrumentoNormalizado
             });
             instEl.value = instrumentoNormalizado;
          } else {
            console.log('üéµ Instrumento j√° est√° preenchido, mantendo:', instrumentoAtual);
          }
         }
       }
     } catch (error) {
       console.error('‚ùå Erro ao buscar instrumento:', error);
     }
   }
   
   async function validarInstrumentoCorreto(nomeSelecionado, comumVal, cargoVal, instEl) {
     console.log('üîç Validando instrumento correto para:', { nomeSelecionado, comumVal, cargoVal });
     
     const instrumentoAtual = instEl.value.trim();
     console.log('üîç Instrumento atual no campo:', instrumentoAtual);
     console.log('üîç Campo instrumento vis√≠vel:', instEl.offsetParent !== null);
     console.log('üîç Campo instrumento display:', instEl.closest('.mb-3')?.style.display);
     
     if (!instrumentoAtual) {
       console.log('‚ö†Ô∏è Campo instrumento vazio, pulando valida√ß√£o');
       return;
     }
     
     try {
       // Busca o instrumento correto para esta pessoa espec√≠fica
       const { data, error } = await sb
         .from(TABLE_CATALOGO)
         .select('nome, instrumento, cargo')
         .ilike('comum', `%${comumVal}%`)
         .ilike('cargo', `%${cargoVal}%`)
         .eq('ativo', true);
       
       if (error) {
         console.error('‚ùå Erro ao validar instrumento:', error);
         return;
       }
       
       if (data && data.length > 0) {
         console.log('üîç Dados encontrados na busca:', data.length, 'registros');
         console.log('üîç Primeiros registros:', data.slice(0, 3));
         
        // üö® CORRE√á√ÉO: Buscar diretamente pelo nome, sem loop desnecess√°rio e sem logs
        // Normaliza o nome selecionado uma vez para compara√ß√£o
        const nomeSelecionadoNormalizado = norm(nomeSelecionado).toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase());
        
        const registro = data.find(r => {
          const nomeNormalizado = norm(r.nome).toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase());
          return nomeNormalizado === nomeSelecionadoNormalizado;
        });
        
        // Log apenas se encontrar o registro (evita spam)
        if (registro) {
          console.log('‚úÖ Registro encontrado para valida√ß√£o:', { nome: registro.nome, instrumento: registro.instrumento });
        }
         
         if (registro && registro.instrumento) {
           const instrumentoCorreto = registro.instrumento.trim();
           const instrumentoAtualUpper = upper(instrumentoAtual);
           const instrumentoCorretoUpper = upper(instrumentoCorreto);
           
           console.log('üîç Comparando instrumentos:', {
             atual: instrumentoAtual,
             correto: instrumentoCorreto,
             nome: registro.nome
           });
           
           // üö® CORRE√á√ÉO: Fun√ß√£o auxiliar para comparar instrumentos considerando varia√ß√µes v√°lidas
           function saoInstrumentosEquivalentes(inst1, inst2) {
             const inst1Upper = inst1.toUpperCase().trim();
             const inst2Upper = inst2.toUpperCase().trim();
             
             // Se s√£o exatamente iguais, s√£o equivalentes
             if (inst1Upper === inst2Upper) {
               return true;
             }
             
             // üö® CORRE√á√ÉO ESPEC√çFICA SAXOFONE SOPRANO: Considera varia√ß√µes v√°lidas
             // "SAXOFONE SOPRANO (RETO)", "SAXOFONE SOPRANO RETO", "SAXOFONE SOPRANO RET" s√£o equivalentes
             if (inst1Upper.includes('SAXOFONE SOPRANO') && inst2Upper.includes('SAXOFONE SOPRANO')) {
               const temReto1 = inst1Upper.includes('RETO') || inst1Upper.includes('RET');
               const temReto2 = inst2Upper.includes('RETO') || inst2Upper.includes('RET');
               if (temReto1 && temReto2) {
                 return true; // Ambos s√£o SAXOFONE SOPRANO RETO (varia√ß√µes v√°lidas)
               }
             }
             
             // Para outros instrumentos, usar compara√ß√£o normalizada
             const inst1Norm = normalizeInstrument(inst1);
             const inst2Norm = normalizeInstrument(inst2);
             
             return inst1Norm.toUpperCase() === inst2Norm.toUpperCase();
           }
           
           // Se o instrumento atual n√£o corresponde ao correto E n√£o s√£o varia√ß√µes v√°lidas
           if (!saoInstrumentosEquivalentes(instrumentoAtual, instrumentoCorreto)) {
             // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
             
             // Verifica se o campo est√° vis√≠vel antes de corrigir
             const instrumentoContainer = instEl.closest('.mb-3');
             const campoVisivel = instrumentoContainer && instrumentoContainer.style.display !== 'none';
             
             if (!campoVisivel) {
               if (instrumentoContainer) {
                 instrumentoContainer.style.display = 'block';
               }
             }
             
             // CORRE√á√ÉO AUTOM√ÅTICA - Atualiza o campo imediatamente
             instEl.value = instrumentoCorreto;
             
             // For√ßa evento de mudan√ßa para garantir que o frontend seja atualizado
             instEl.dispatchEvent(new Event('change', { bubbles: true }));
             instEl.dispatchEvent(new Event('input', { bubbles: true }));
             
             // Calcula o naipe automaticamente
             const naipeCorreto = getNaipeByInstrumento(instrumentoCorreto);
             
             // Mostra toast de confirma√ß√£o
             const mensagem = naipeCorreto ? 
               `Instrumento corrigido para ${instrumentoCorreto} (${naipeCorreto})` : 
               `Instrumento corrigido para ${instrumentoCorreto}`;
             
             showToast('success', 'Instrumento Corrigido', mensagem, 3000);
           } else {
             // üöÄ PRODU√á√ÉO: Instrumento √© uma varia√ß√£o v√°lida, n√£o corrigir nem mostrar alerta
           }
         }
       }
     } catch (error) {
       console.error('‚ùå Erro na valida√ß√£o de instrumento:', error);
     }
   }
   
   // Fun√ß√£o global para corrigir instrumento
   window.corrigirInstrumento = function(instrumentoCorreto) {
     const instEl = findInstrumentField();
     if (instEl) {
       instEl.value = instrumentoCorreto;
       console.log('‚úÖ Instrumento corrigido para:', instrumentoCorreto);
       
       // Calcula o naipe automaticamente
       const naipeCorreto = getNaipeByInstrumento(instrumentoCorreto);
       console.log('üéµ Naipe calculado automaticamente:', naipeCorreto);
       
       // Remove o toast
       const toast = document.querySelector('.toast-notification.warning');
       if (toast) toast.remove();
       
       // Mostra confirma√ß√£o com naipe
       const mensagem = naipeCorreto ? 
         `Alterado para ${instrumentoCorreto} (${naipeCorreto})` : 
         `Alterado para ${instrumentoCorreto}`;
       showToast('success', 'Instrumento Corrigido', mensagem, 2000);
     }
   };
   
   // Fun√ß√£o para mostrar alerta de duplicata
   async function mostrarAlertaDuplicata(nome, comum, dataFormatada, duplicata) {
     console.log('üö® Mostrando alerta de duplicata:', { nome, comum, dataFormatada, duplicata });
     
    const mensagem = `
      <div style="text-align: left;">
        <strong>${nome}</strong> de <strong>${comum || 'Comum n√£o localizada'}</strong><br>
        j√° foi cadastrado hoje!<br><br>
        <small>Data: ${dataFormatada}</small><br>
         <small>Hor√°rio: ${new Date(duplicata.created_at).toLocaleTimeString('pt-BR')}</small>
       </div>
     `;
     
     // üö® CORRE√á√ÉO CR√çTICA: Garantir que SweetAlert2 est√° dispon√≠vel
     if (typeof Swal === 'undefined') {
       console.error('‚ùå SweetAlert2 n√£o est√° carregado!');
       // Fallback: usar alert nativo
       const confirmar = confirm(`‚ö†Ô∏è CADASTRO DUPLICADO!\n\n${nome} de ${comum || 'Comum n√£o localizada'} j√° foi cadastrado hoje!\n\nData: ${dataFormatada}\nHor√°rio: ${new Date(duplicata.created_at).toLocaleTimeString('pt-BR')}\n\nDeseja cadastrar mesmo assim?`);
       return !confirmar; // Retorna true se cancelou, false se confirmou
     }
     
     // üîß CORRE√á√ÉO MOBILE: Detectar se √© mobile
     const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
     
     const result = await Swal.fire({
       title: '‚ö†Ô∏è Cadastro Duplicado!',
       html: mensagem,
       icon: 'warning',
       showCancelButton: true,
       confirmButtonText: '<i class="fa-solid fa-check"></i> Cadastrar Mesmo Assim',
       cancelButtonText: '<i class="fa-solid fa-times"></i> Cancelar',
       confirmButtonColor: '#f59e0b',
       cancelButtonColor: '#6b7280',
       reverseButtons: true,
       width: isMobileDevice ? '90%' : '500px',
       padding: isMobileDevice ? '1.5rem' : '2rem',
       position: 'center',
       backdrop: true,
       allowOutsideClick: false,
       allowEscapeKey: true,
       focusConfirm: false,
       focusCancel: false,
       buttonsStyling: true,
       customClass: {
         popup: 'swal-duplicity-popup',
         title: 'swal-duplicity-title',
         content: 'swal-duplicity-content',
         container: 'swal-duplicity-container',
         confirmButton: 'swal-duplicity-confirm',
         cancelButton: 'swal-duplicity-cancel'
       },
       didOpen: () => {
         console.log('‚úÖ Modal de duplicidade aberto com sucesso');
         
         // üîß CORRE√á√ÉO EST√âTICA: Ajustar tamanho dos bot√µes ao conte√∫do do texto (compacto)
         setTimeout(() => {
           const confirmBtn = document.querySelector('.swal2-confirm, .swal-duplicity-confirm');
           const cancelBtn = document.querySelector('.swal2-cancel, .swal-duplicity-cancel');
           
           if (confirmBtn && cancelBtn) {
             // Remover todas as restri√ß√µes de largura
             confirmBtn.style.minWidth = 'unset';
             confirmBtn.style.width = 'auto';
             cancelBtn.style.minWidth = 'unset';
             cancelBtn.style.width = 'auto';
             
             // Padding m√≠nimo para compactar os bot√µes
             confirmBtn.style.padding = '0.5rem 1rem';
             cancelBtn.style.padding = '0.5rem 1rem';
             
             // Garantir que os √≠cones estejam vis√≠veis com margem m√≠nima
             const confirmIcon = confirmBtn.querySelector('i');
             const cancelIcon = cancelBtn.querySelector('i');
             if (confirmIcon) {
               confirmIcon.style.marginRight = '0.375rem';
             }
             if (cancelIcon) {
               cancelIcon.style.marginRight = '0.375rem';
             }
             
             // For√ßar rec√°lculo do layout
             confirmBtn.offsetHeight;
             cancelBtn.offsetHeight;
             
             // Obter a largura real do conte√∫do (sem padding excessivo)
             const confirmContentWidth = confirmBtn.scrollWidth;
             const cancelContentWidth = cancelBtn.scrollWidth;
             
             // Aplicar a mesma largura aos dois bot√µes (baseado no maior conte√∫do)
             const maxWidth = Math.max(confirmContentWidth, cancelContentWidth);
             confirmBtn.style.width = `${maxWidth}px`;
             cancelBtn.style.width = `${maxWidth}px`;
             
             console.log('‚úÖ Bot√µes ajustados ao tamanho do texto (compacto)');
           }
         }, 200);
       }
     });
     
     if (!result.isConfirmed) {
       // Usu√°rio cancelou - recarrega a p√°gina silenciosamente
       console.log('‚ùå Usu√°rio cancelou registro por duplicata - recarregando p√°gina...');
       setTimeout(() => {
         window.location.reload();
       }, 100);
       return true; // Retorna true para indicar que deve cancelar
     }
     
     // Usu√°rio confirmou - retorna false para permitir o registro
     console.log('‚úÖ Usu√°rio confirmou registro mesmo com duplicata');
     return false; // Retorna false para permitir o registro
   }
   
   // Fun√ß√£o para verificar duplicatas por nome + comum + data (VERS√ÉO EST√ÅVEL)
   async function verificarDuplicata(nome, comum) {
     if (!nome || !comum) {
       console.log('‚ö†Ô∏è Verifica√ß√£o de duplicata pulada - dados incompletos:', { nome, comum });
       return false;
     }
     
     try {
       // Verifica se Supabase est√° dispon√≠vel
       if (!supabaseLoaded || !sb) {
         return false;
       }
       
       // Formata a data atual
       const dataAtual = new Date();
       const dataFormatada = dataAtual.toLocaleDateString('pt-BR');
       const dataISO = dataAtual.toISOString().split('T')[0];
       
       // Consulta simples e direta
       const { data, error } = await sb
           .from('presencas')
         .select('nome_completo, comum, created_at')
           .ilike('nome_completo', `%${nome.trim()}%`)
           .ilike('comum', `%${comum.trim()}%`)
           .gte('created_at', `${dataISO}T00:00:00.000Z`)
           .lt('created_at', `${dataISO}T23:59:59.999Z`)
         .limit(5);
       
       if (error) {
         return false;
       }
       
       if (data && data.length > 0) {
         const usuarioCancelou = await mostrarAlertaDuplicata(nome, comum, dataFormatada, data[0]);
         
         // üö® CORRE√á√ÉO: Se usu√°rio confirmou (n√£o cancelou), definir flag para permitir envio
         if (!usuarioCancelou) {
           window._duplicataConfirmadaPeloUsuario = true;
           const platformType = isMobile ? 'MOBILE' : 'DESKTOP';
           console.log(`‚úÖ ${platformType}: Usu√°rio confirmou duplicata - flag definida para permitir envio`);
           console.log(`‚úÖ ${platformType}: Flag _duplicataConfirmadaPeloUsuario =`, window._duplicataConfirmadaPeloUsuario);
         } else {
           const platformType = isMobile ? 'MOBILE' : 'DESKTOP';
           console.log(`‚ùå ${platformType}: Usu√°rio cancelou duplicata - bloqueando envio`);
         }
         
         return usuarioCancelou;
       } else {
         return false;
       }
       
     } catch (error) {
         console.error('‚ùå Erro na verifica√ß√£o de duplicatas:', error);
       return false;
     }
   }
   
   // Fun√ß√£o para mapear instrumento para naipe
   function getNaipeByInstrumento(instrumento) {
     if (!instrumento) return '';
     
     const instrumentoUpper = upper(instrumento);
     
     // Mapeamento de instrumentos para naipes (3 categorias principais)
     const mapeamentoNaipes = {
       // CORDAS
       'VIOLINO': 'CORDAS',
       'VIOLA': 'CORDAS', 
       'VIOLONCELO': 'CORDAS',
       'CONTRABAIXO': 'CORDAS',
       'VIOL√ÉO': 'CORDAS',
       'GUITARRA': 'CORDAS',
       'BAIXO': 'CORDAS',
       
       // MADEIRAS
       'FLAUTA': 'MADEIRAS',
       'FLAUTA DOCE': 'MADEIRAS',
       'OBO√â': 'MADEIRAS',
       'CLARINETA': 'MADEIRAS',
       'CLARINETE': 'MADEIRAS',
       'FAGOTE': 'MADEIRAS',
       'SAXOFONE': 'MADEIRAS',
       'SAXOFONE ALTO': 'MADEIRAS',
       'SAXOFONE TENOR': 'MADEIRAS',
       'SAXOFONE SOPRANO': 'MADEIRAS',
       'SAXOFONE BAR√çTONO': 'MADEIRAS',
       
       // METAIS
       'TROMPA': 'METAIS',
       'TROMPETE': 'METAIS',
       'TROMBONE': 'METAIS',
       'TUBA': 'METAIS',
       'FLUGELHORN': 'METAIS',
       'EUF√îNIO': 'METAIS',
       'BOMBARDINO': 'METAIS',
       
       // TECLADO
       '√ìRG√ÉO': 'TECLADO',
       'PIANO': 'TECLADO',
       'TECLADO': 'TECLADO',
       'ACORDEON': 'TECLADO',
       'ACORDE√ÉO': 'TECLADO',
       
       // Outros instrumentos (sem naipe espec√≠fico)
       'BATERIA': '',
       'CAIXA': '',
       'PRATO': '',
       'BOMBO': '',
       'TRI√ÇNGULO': '',
       'XILOFONE': '',
       'VIBRAFONE': '',
       'MARIMBA': '',
       'TIMPANI': '',
       'T√çMPANOS': '',
       'VOZ': '',
       'CORAL': '',
       'SOLO': ''
     };
     
     // Busca exata primeiro
     if (mapeamentoNaipes[instrumentoUpper]) {
       return mapeamentoNaipes[instrumentoUpper];
     }
     
     // Busca parcial para instrumentos com varia√ß√µes
     for (const [instrumentoKey, naipe] of Object.entries(mapeamentoNaipes)) {
       if (instrumentoUpper.includes(instrumentoKey) || instrumentoKey.includes(instrumentoUpper)) {
         return naipe;
       }
     }
     
     // Se n√£o encontrou, retorna vazio
     console.log('‚ö†Ô∏è Naipe n√£o encontrado para instrumento:', instrumento);
     return '';
   }
   
   // Fun√ß√£o auxiliar para converter SELECT para INPUT quando n√£o h√° nomes
   function converterParaInput(selectEl) {
     console.log('üîÑ Convertendo SELECT para INPUT para permitir digita√ß√£o manual');
     
     // Verifica se o elemento e seu parent existem
     if (!selectEl || !selectEl.parentNode) {
       console.error('‚ùå Elemento ou parentNode n√£o encontrado para convers√£o');
       return null;
     }
     
     // Verifica se o elemento ainda est√° no DOM
     if (!document.contains(selectEl)) {
       console.error('‚ùå Elemento n√£o est√° mais no DOM');
       return null;
     }
     
     // Cria novo elemento INPUT
     const inputEl = document.createElement('input');
     inputEl.type = 'text';
     inputEl.id = 'nome';
     inputEl.name = 'nome';
     inputEl.className = 'form-control';
     inputEl.required = true;
     inputEl.placeholder = 'Digite o nome completo...';
     inputEl.setAttribute('data-nome-manual', 'true');
     inputEl.setAttribute('data-sem-nomes', 'true');
     
     // üö® CORRE√á√ÉO CR√çTICA: Garantir que o INPUT seja sempre edit√°vel
     inputEl.removeAttribute('readonly');
     inputEl.removeAttribute('disabled');
     inputEl.readOnly = false;
     inputEl.disabled = false;
     inputEl.style.pointerEvents = 'auto';
     inputEl.style.opacity = '1';
     
     // Otimiza√ß√µes para mobile
     if (isMobile) {
       inputEl.style.fontSize = '16px'; // Previne zoom no iOS
       inputEl.style.minHeight = '44px'; // Tamanho m√≠nimo para touch
       inputEl.style.padding = '12px 16px';
       inputEl.style.borderRadius = '8px';
       inputEl.style.border = '2px solid #e5e7eb';
       inputEl.style.width = '100%';
       inputEl.style.boxSizing = 'border-box';
       inputEl.autocomplete = 'off';
       inputEl.spellcheck = false;
       
       // Adicionar feedback visual para mobile
       inputEl.addEventListener('focus', () => {
         inputEl.style.borderColor = '#1e40af';
         inputEl.style.boxShadow = '0 0 0 3px rgba(30, 64, 175, 0.1)';
         // Garantir que seja edit√°vel ao focar
         inputEl.removeAttribute('readonly');
         inputEl.removeAttribute('disabled');
         inputEl.readOnly = false;
         inputEl.disabled = false;
       });
       
       inputEl.addEventListener('blur', () => {
         inputEl.style.boxShadow = 'none';
       });
     }
     
     // Garantir que sempre seja edit√°vel (tamb√©m para desktop)
     inputEl.addEventListener('focus', () => {
       inputEl.removeAttribute('readonly');
       inputEl.removeAttribute('disabled');
       inputEl.readOnly = false;
       inputEl.disabled = false;
     });
     
     // Copia outros atributos importantes
     if (selectEl.hasAttribute('name')) {
       inputEl.setAttribute('name', selectEl.getAttribute('name'));
     }
     
     // Substitui o SELECT pelo INPUT de forma segura
     try {
       selectEl.parentNode.replaceChild(inputEl, selectEl);
       console.log('‚úÖ SELECT convertido para INPUT com sucesso');
       return inputEl;
     } catch (error) {
       console.error('‚ùå Erro ao converter SELECT para INPUT:', error);
       return null;
     }
   }
   
   function populateNomesInput(nomeEl, unique) {
     // üö® CORRE√á√ÉO: Valida√ß√£o b√°sica apenas
     if (!unique || !Array.isArray(unique)) {
       unique = Array.isArray(unique) ? unique : (unique ? [unique] : []);
     }
     
    // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
    
    // üö® CORRE√á√ÉO: Se o elemento n√£o est√° no DOM, buscar novamente
    if (!nomeEl || !document.contains(nomeEl)) {
      nomeEl = document.getElementById('nome');
      if (!nomeEl) {
        return;
      }
    }
     
     // Verifica se unique √© um array v√°lido
     if (!Array.isArray(unique)) {
       console.error('‚ùå Par√¢metro unique n√£o √© um array v√°lido:', unique);
       return;
     }
     
    // üö® CORRE√á√ÉO CR√çTICA MOBILE: Verificar se SELECT j√° tem op√ß√µes, mas permitir sobrescrever se unique tem mais nomes
    // Isso garante que se houver mais nomes dispon√≠veis, o SELECT seja atualizado
    // üö® CORRE√á√ÉO ESPEC√çFICA CHROME iOS: Chrome iOS precisa de tratamento especial
    // üö® CORRE√á√ÉO ESPEC√çFICA XIAOMI/REDMI: Xiaomi/Redmi precisa de tratamento especial
    if (nomeEl && nomeEl.tagName === 'SELECT' && nomeEl.options.length > 1) {
      // üö® CORRE√á√ÉO MOBILE: Se unique tem mais nomes que o SELECT atual, sobrescrever
      const opcoesAtuais = nomeEl.options.length - 1; // -1 para excluir placeholder
      const nomesNovos = unique.length;
      
      // üö® CORRE√á√ÉO ESPEC√çFICA XIAOMI/REDMI: Xiaomi/Redmi sempre sobrescreve se houver nomes
      // üõ°Ô∏è REDMI NOTE 13: Garantir que sempre sobrescreve quando h√° nomes
      if ((isXiaomi || isRedmiNote13) && nomesNovos > 0) {
        // Continuar para popular com todos os nomes
      } else if (isChromeIOS && nomesNovos > opcoesAtuais) {
        // Continuar para popular com todos os nomes
      } else if (nomesNovos > opcoesAtuais) {
        // Continuar para popular com todos os nomes
      } else if (nomesNovos === opcoesAtuais) {
        // Mesmo n√∫mero de nomes - n√£o sobrescrever
        return;
      } else {
        // Menos nomes - n√£o sobrescrever (pode ser cache antigo)
        return;
      }
    }
    
    // üö® CORRE√á√ÉO MOBILE: Verificar novamente para garantir que n√£o sobrescrevemos desnecessariamente
    // No mobile, pode haver um problema de timing onde o SELECT foi populado mas ainda n√£o est√° vis√≠vel
    // üö® CORRE√á√ÉO ESPEC√çFICA XIAOMI/REDMI: Xiaomi/Redmi sempre verifica se precisa reconverter INPUT para SELECT
    // üõ°Ô∏è REDMI NOTE 13: Garantir que sempre converte INPUT para SELECT quando h√° nomes
    if ((isXiaomi || isRedmiNote13) && nomeEl && nomeEl.tagName === 'INPUT' && unique && unique.length > 0) {
      // üö® CORRE√á√ÉO XIAOMI: Se √© INPUT e h√° nomes, SEMPRE reconverter para SELECT
      const selectEl = reconverterParaSelect(nomeEl, unique);
      if (selectEl) {
        return; // N√£o continuar, j√° foi reconvertido
      }
    }
    
    if (isMobile && nomeEl && nomeEl.tagName === 'SELECT') {
      // Verificar se o SELECT tem o atributo data-populado ou se window.nomesData foi populado
      const dataPopulado = nomeEl.getAttribute('data-populado') === 'true';
      const temNomesData = window.nomesData && Array.isArray(window.nomesData) && window.nomesData.length > 0;
      const opcoesAtuais = nomeEl.options.length - 1; // -1 para excluir placeholder
      const nomesNovos = unique.length;
      
      // üö® CORRE√á√ÉO ESPEC√çFICA CHROME iOS: Chrome iOS sempre permite sobrescrever se houver mais nomes
      if (isChromeIOS && nomesNovos > opcoesAtuais) {
        // Continuar para popular com todos os nomes
      } else if (dataPopulado && opcoesAtuais === nomesNovos) {
        // Se o SELECT foi marcado como populado E tem o mesmo n√∫mero de nomes, n√£o sobrescrever
        return;
      } else if (nomesNovos > opcoesAtuais) {
        // Se tem mais nomes dispon√≠veis, permitir sobrescrever
      }
    }
     
     if (nomeEl && nomeEl.tagName === 'SELECT') {
       
       // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
       
       if (!unique || !Array.isArray(unique) || unique.length === 0) {
         // Se n√£o h√° resultados, converte SELECT para INPUT para permitir digita√ß√£o manual
         const inputEl = converterParaInput(nomeEl);
         if (inputEl) {
           // Garantir que o INPUT seja sempre edit√°vel
           inputEl.removeAttribute('readonly');
           inputEl.removeAttribute('disabled');
           inputEl.readOnly = false;
           inputEl.disabled = false;
           
           // Adiciona event listener para o novo INPUT
           inputEl.addEventListener('input', capturarClasseAutomaticamente);
           inputEl.addEventListener('focus', function() {
             this.removeAttribute('readonly');
             this.removeAttribute('disabled');
             this.readOnly = false;
             this.disabled = false;
           });
           
           return; // IMPORTANTE: N√£o continuar executando
         } else {
           return; // IMPORTANTE: N√£o continuar executando mesmo em caso de erro
         }
         
       } else {
         // Se h√° resultados, mant√©m como SELECT mas adiciona op√ß√£o para digitar manualmente
         try {
           // Limpar SELECT primeiro
           nomeEl.innerHTML = '';
           
           // Adicionar primeira op√ß√£o
           const primeiraOpcao = document.createElement('option');
           primeiraOpcao.value = '';
           primeiraOpcao.textContent = 'Selecione um nome da lista (ou digite, se offline)';
           nomeEl.appendChild(primeiraOpcao);
           
           // üö® CORRE√á√ÉO CR√çTICA: Converter objetos para strings antes de adicionar ao SELECT
           // Garantir que unique seja sempre um array de strings
           const nomesStrings = unique.map(nome => {
             if (typeof nome === 'string') {
               return nome;
             }
             // Se for objeto, extrair a propriedade 'nome'
             if (nome && typeof nome === 'object' && nome.nome) {
               return nome.nome;
             }
             // Fallback: converter para string
             return String(nome);
           }).filter(Boolean); // Remove valores vazios
           
           // Adicionar nomes
           nomesStrings.forEach((nome) => {
             const option = document.createElement('option');
             option.value = nome;
             option.textContent = nome;
             nomeEl.appendChild(option);
           });
           
           // Adicionar op√ß√£o manual
           const optionManual = document.createElement('option');
           optionManual.value = '__MANUAL_INPUT__';
           optionManual.textContent = '‚úèÔ∏è Adicionar novo nome manualmente';
           optionManual.style.backgroundColor = '#e3f2fd';
           optionManual.style.color = '#1976d2';
           optionManual.style.fontWeight = 'bold';
           nomeEl.appendChild(optionManual);
           
           nomeEl.style.backgroundColor = ''; // Remove cor de fundo
           
           // üöÄ PRODU√á√ÉO: Logs removidos para melhor performance
           
           // Remove event listeners antigos antes de adicionar novos
           nomeEl.removeEventListener('change', capturarClasseAutomaticamente);
           nomeEl.removeEventListener('input', capturarClasseAutomaticamente);
           
           // üö® CORRE√á√ÉO CR√çTICA MOBILE: Fechar teclado virtual ao selecionar nome da lista
           function fecharTecladoVirtualMobile() {
             if (!isMobile) return;
             
             try {
               // M√©todo 1: Blur do campo atual
               nomeEl.blur();
               
               // M√©todo 2: Criar input tempor√°rio, focar e remover
               const tmpInput = document.createElement('input');
               tmpInput.type = 'text';
               tmpInput.style.position = 'absolute';
               tmpInput.style.opacity = '0';
               tmpInput.style.height = '0';
               tmpInput.style.width = '0';
               tmpInput.style.top = '-1000px';
               tmpInput.style.left = '-1000px';
               document.body.appendChild(tmpInput);
               
               // Focar no input tempor√°rio
               setTimeout(() => {
                 tmpInput.focus();
                 setTimeout(() => {
                   tmpInput.blur();
                   document.body.removeChild(tmpInput);
                   
                   // Remover focus de qualquer elemento ativo
                   if (document.activeElement && document.activeElement !== document.body) {
                     document.activeElement.blur();
                   }
                 }, 100);
               }, 50);
             } catch (e) {
               console.warn('‚ö†Ô∏è Erro ao fechar teclado virtual:', e);
             }
           }
           
           // Adiciona eventos
           nomeEl.addEventListener('change', function(e) {
             capturarClasseAutomaticamente.call(this);
             
             // üö® CORRE√á√ÉO CR√çTICA MOBILE: Fechar teclado virtual ao selecionar nome da lista
             if (isMobile && nomeEl.value && nomeEl.value !== '__MANUAL_INPUT__') {
               setTimeout(() => {
                 fecharTecladoVirtualMobile();
               }, 100);
             }
             
             // Se selecionou op√ß√£o manual, converter para INPUT
             if (nomeEl.value === '__MANUAL_INPUT__') {
               const selectEl = nomeEl;
               const inputEl = document.createElement('input');
               inputEl.type = 'text';
               inputEl.id = 'nome';
               inputEl.name = 'nome';
               inputEl.className = 'form-control';
               inputEl.placeholder = 'Digite o nome completo...';
               inputEl.required = true;
               inputEl.setAttribute('data-nome-manual', 'true');
               selectEl.parentNode.replaceChild(inputEl, selectEl);
               inputEl.focus();
             }
           });
           nomeEl.addEventListener('input', capturarClasseAutomaticamente);
           
           console.log('‚úÖ SELECT populado com', unique.length, 'nomes');
           void nomeEl.offsetHeight; // For√ßar reflow
           return; // IMPORTANTE: N√£o continuar executando
         } catch (error) {
           console.error('‚ùå Erro ao atualizar SELECT:', error);
           return; // IMPORTANTE: N√£o continuar executando mesmo em caso de erro
         }
       }
     } else {
       // Se j√° √© INPUT, verifica se precisa reconverter para SELECT
       console.log('üîç DEBUG - Elemento √© INPUT, verificando se precisa reconverter para SELECT');
       if (unique.length > 0) {
         // Se h√° resultados, reconverte INPUT para SELECT
         console.log('üîç DEBUG - H√° nomes, reconvertendo INPUT para SELECT');
         const selectEl = reconverterParaSelect(nomeEl, unique);
         if (!selectEl) {
           console.error('‚ùå Falha ao reconverter INPUT para SELECT');
           // Se falhou a convers√£o, mant√©m como INPUT mas adiciona datalist
           // Busca o elemento atual novamente para garantir que temos a refer√™ncia correta
           const currentNomeEl = findNomeField();
           if (currentNomeEl) {
             populateNomesInputMobile(currentNomeEl, unique);
           }
         }
       } else {
         // Se n√£o h√° resultados, mant√©m como INPUT mas sem convers√£o
         console.log('üîÑ DEBUG - N√£o h√° nomes, mantendo INPUT como est√°');
         nomeEl.placeholder = 'Nenhum nome encontrado - digite manualmente';
         nomeEl.style.backgroundColor = '#f8d7da'; // Cor de fundo para indicar que n√£o h√° nomes
       }
     }
   }
   
   // Fun√ß√£o espec√≠fica para mobile com melhor UX
   function populateNomesInputMobile(nomeEl, unique) {
     console.log('üì± MOBILE: Populando input mobile com', unique.length, 'nomes');
     
     // Para mobile, usar INPUT com datalist para melhor experi√™ncia
     if (nomeEl.tagName !== 'INPUT') {
       console.error('‚ùå Elemento n√£o √© INPUT para populateNomesInputMobile');
       return;
     }
     
     // Configurar INPUT para mobile
     nomeEl.style.fontSize = '16px'; // Previne zoom no iOS
     nomeEl.style.minHeight = '44px'; // Tamanho m√≠nimo para touch
     nomeEl.style.padding = '12px 16px';
     nomeEl.style.borderRadius = '8px';
     nomeEl.style.border = '2px solid #e5e7eb';
     nomeEl.style.width = '100%';
     nomeEl.style.boxSizing = 'border-box';
     nomeEl.style.backgroundColor = '#ffffff';
     
     // üö® CORRE√á√ÉO CR√çTICA: REMOVER DATALIST COMPLETAMENTE - SEMPRE
     // Remover qualquer atributo list para evitar sugest√µes acima do teclado
     nomeEl.removeAttribute('list');
     nomeEl.setAttribute('list', ''); // For√ßar vazio
     nomeEl.setAttribute('autocomplete', 'off');
     
     // Remover datalist se existir
     const existingDatalist = document.getElementById('dlNomes');
     if (existingDatalist) {
       existingDatalist.remove();
     }
     
     // Remover todos os datalists relacionados
     const allDatalists = document.querySelectorAll('datalist[id*="Nomes"], datalist[id*="nome"]');
     allDatalists.forEach(function(dl) {
       dl.remove();
     });
     
     if (unique.length > 0) {
       // üö® CORRE√á√ÉO CR√çTICA: Limpar estado manual quando h√° dados dispon√≠veis
       nomeEl.removeAttribute('data-nome-manual');
       nomeEl.removeAttribute('data-selected-from-list');
       nomeEl.placeholder = 'Digite o nome ou selecione da lista...';
       nomeEl.style.backgroundColor = ''; // Remove cor de fundo
       nomeEl.style.borderColor = ''; // Remove cor de borda
       console.log('üì± MOBILE: INPUT configurado sem datalist - usando apenas dropdown customizado');
     } else {
       // Remover datalist se n√£o h√° nomes
       nomeEl.removeAttribute('list');
       nomeEl.placeholder = 'Nenhum nome encontrado - digite manualmente';
       nomeEl.style.backgroundColor = '#f8d7da'; // Cor de fundo para indicar que n√£o h√° nomes
       console.log('üì± MOBILE: INPUT configurado para digita√ß√£o manual');
     }
     
     // üö® CORRE√á√ÉO CR√çTICA MOBILE: Fechar teclado virtual ao selecionar nome da lista
     function fecharTecladoVirtualMobile() {
       if (!isMobile) return;
       
       try {
         // M√©todo 1: Blur do campo atual
         nomeEl.blur();
         
         // M√©todo 2: Criar input tempor√°rio, focar e remover
         const tmpInput = document.createElement('input');
         tmpInput.type = 'text';
         tmpInput.style.position = 'absolute';
         tmpInput.style.opacity = '0';
         tmpInput.style.height = '0';
         tmpInput.style.width = '0';
         tmpInput.style.top = '-1000px';
         tmpInput.style.left = '-1000px';
         document.body.appendChild(tmpInput);
         
         // Focar no input tempor√°rio
         setTimeout(() => {
           tmpInput.focus();
           setTimeout(() => {
             tmpInput.blur();
             document.body.removeChild(tmpInput);
             
             // Remover focus de qualquer elemento ativo
             if (document.activeElement && document.activeElement !== document.body) {
               document.activeElement.blur();
             }
           }, 100);
         }, 50);
       } catch (e) {
         console.warn('‚ö†Ô∏è Erro ao fechar teclado virtual:', e);
       }
     }
     
     // Adicionar eventos
     nomeEl.addEventListener('input', function(e) {
       capturarClasseAutomaticamente.call(this);
       
       // üö® CORRE√á√ÉO MOBILE: Se o valor foi definido via datalist (sele√ß√£o da lista), fechar teclado
       const datalist = document.getElementById('dlNomes');
       if (isMobile && datalist && nomeEl.value) {
         // Verificar se o valor existe no datalist (foi selecionado da lista)
         const option = Array.from(datalist.options).find(opt => opt.value === nomeEl.value);
         if (option) {
           // Valor foi selecionado da lista, fechar teclado
           setTimeout(() => {
             fecharTecladoVirtualMobile();
           }, 100);
         }
       }
     });
     
     nomeEl.addEventListener('change', function(e) {
       capturarClasseAutomaticamente.call(this);
       
       // üö® CORRE√á√ÉO CR√çTICA MOBILE: Fechar teclado virtual ao selecionar nome da lista
       if (isMobile && nomeEl.value) {
         const datalist = document.getElementById('dlNomes');
         if (datalist) {
           // Verificar se o valor existe no datalist (foi selecionado da lista)
           const option = Array.from(datalist.options).find(opt => opt.value === nomeEl.value);
           if (option) {
             // Valor foi selecionado da lista, fechar teclado
             setTimeout(() => {
               fecharTecladoVirtualMobile();
             }, 100);
           }
         }
       }
     });
     
     console.log('üì± MOBILE: INPUT configurado com sucesso');
   }
   
   async function capturarClasseAutomaticamente() {
     console.log('üö®üö®üö® FUN√á√ÉO CAPTURAR CLASSE AUTOMATICAMENTE CHAMADA! üö®üö®üö®');
     
     const nomeEl = this;
     const nomeSelecionado = nomeEl.value.trim();
     
     console.log('üéπ capturarClasseAutomaticamente chamada para:', nomeSelecionado);
     console.log('üéπ Elemento que disparou:', nomeEl);
     console.log('üéπ Tipo do elemento:', nomeEl.tagName);
     console.log('üîç DEBUG - In√≠cio da fun√ß√£o capturarClasseAutomaticamente');
     
     if (!nomeSelecionado) {
       console.log('üéπ Nome vazio, saindo da fun√ß√£o');
       return;
     }
     
     // Busca os dados completos no cache
     const comumEl = findComumField();
     const cargoEl = findCargoField();
     const instEl = findInstrumentField();
     
     if (!comumEl || !cargoEl || !instEl) return;
     
     const comumVal = getFieldValue(comumEl);
     const cargoVal = getFieldValue(cargoEl);
     const instVal = getFieldValue(instEl);
     
     if (!comumVal || !cargoVal) return;
     
     // NOVA FUNCIONALIDADE: Preencher instrumento automaticamente quando selecionar nome
     await preencherInstrumentoAutomaticamente(nomeSelecionado, comumVal, cargoVal, instEl);
     
     // NOVA FUNCIONALIDADE: Validar instrumento correto para o cargo
     await validarInstrumentoCorreto(nomeSelecionado, comumVal, cargoVal, instEl);
     
           // NOVA FUNCIONALIDADE: Detectar automaticamente se organista √© instrutora (APENAS para Organista)
           if (ucase(cargoVal) === 'ORGANISTA') {
             console.log('üîç DEBUG - Executando detec√ß√£o de organista para cargo:', cargoVal);
             await detectarCargoOrganistaAutomaticamente(nomeSelecionado, comumVal, cargoVal, cargoEl);
             console.log('üîç DEBUG - Ap√≥s detec√ß√£o de organista, data-cargo-real:', cargoEl.getAttribute('data-cargo-real'));
           }
   
     // NOVA FUNCIONALIDADE: Detectar automaticamente se m√∫sico √© instrutor (APENAS para M√∫sico)
     console.log('üîç DEBUG - Verificando se deve executar detec√ß√£o de instrutor:', {
       cargoVal,
       cargoValUpper: ucase(cargoVal),
       isMusico: ucase(cargoVal) === 'M√öSICO',
       isMusicoA: ucase(cargoVal) === 'M√öSICO(A)',
       nomeSelecionado,
       comumVal,
       instVal
     });
     
     if (ucase(cargoVal) === 'M√öSICO' || ucase(cargoVal) === 'M√öSICO(A)') {
       console.log('üö®üö®üö® CHAMANDO DETECTAR CARGO MUSICAL! üö®üö®üö®');
       console.log('üîç DEBUG - Executando detec√ß√£o de cargo musical para cargo:', cargoVal);
       await detectarCargoMusicalAutomaticamente(nomeSelecionado, comumVal, cargoVal, cargoEl, instVal);
       console.log('üîç DEBUG - Ap√≥s detec√ß√£o de cargo musical, data-cargo-real:', cargoEl.getAttribute('data-cargo-real'));
     } else {
       console.log('üîç DEBUG - Cargo n√£o √© M√∫sico, pulando detec√ß√£o de cargo musical:', cargoVal);
     }
     
     // Detec√ß√£o de cargo especial j√° executada acima para todos os cargos
     
     // Continua para todos os cargos - n√£o limita mais apenas a organistas
     const cargoUP = ucase(cargoVal);
     console.log('üîç Processando cargo:', cargoVal, 'para busca de dados completos');
     
     // Busca dados completos no cache
     const cacheKey = `cache_nomes_${comumVal}_${instVal}_${cargoVal}`;
     const dadosCompletos = getCache(cacheKey + '_dados');
     
     console.log('üîç Buscando dados completos no cache:', cacheKey + '_dados');
     console.log('üîç Dados completos encontrados:', dadosCompletos?.length || 0);
     
     if (!dadosCompletos || !Array.isArray(dadosCompletos) || dadosCompletos.length === 0) {
       console.log('‚ùå Dados completos n√£o encontrados no cache, fazendo consulta direta...');
       
       // FAZ CONSULTA DIRETA se o cache estiver vazio
       try {
         const consultaDireta = await sb
           .from(TABLE_CATALOGO)
           .select('nome, cargo, nivel')
           .ilike('comum', `%${comumVal}%`)
           .eq('ativo', true);
         
         console.log('üîç Consulta direta realizada:', consultaDireta.data?.length || 0, 'registros');
         
        if (consultaDireta.data && consultaDireta.data.length > 0) {
          // üö® CORRE√á√ÉO: Normalizar nome selecionado uma vez antes do loop (evita normaliza√ß√£o repetida)
          const nomeSelecionadoNormalizado = norm(nomeSelecionado).toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase());
          
          const registro = consultaDireta.data.find(r => {
            const nomeNormalizado = norm(r.nome).toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase());
            return nomeNormalizado === nomeSelecionadoNormalizado;
          });
           
           if (registro && registro.nivel) {
             console.log('üéπ Classe capturada via consulta direta:', { nome: registro.nome, nivel: registro.nivel });
             
       // NOVA FUNCIONALIDADE: For√ßar classe como "OFICIALIZADA" para cargos musicais
       // üõ°Ô∏è CORRE√á√ÉO: Apenas SECRET√ÅRIA DA M√öSICA (feminino) recebe classe de organista
       let classeFinal = registro.nivel;
       const isCargoMusical = registro.cargo && (
         registro.cargo.toUpperCase().includes('ORGANISTA') ||
         registro.cargo.toUpperCase().includes('INSTRUTORA') ||
         registro.cargo.toUpperCase().includes('EXAMINADORA') ||
         // Removido: INSTRUTOR n√£o deve receber classe de organista
         (registro.cargo.toLowerCase().includes('secret√°ria') && registro.cargo.toLowerCase().includes('m√∫sica'))
       );
       
       if (isCargoMusical) {
         const classeOriginal = registro.nivel;
         
         // Verifica se tem prefixo (ex: "RJM / OFICIALIZADO(A)")
         if (classeOriginal.includes('/')) {
           const partes = classeOriginal.split('/');
           const prefixo = partes[0].trim();
           const sufixo = partes[1].trim();
           
           // Remove "(A)" do sufixo e padroniza para "OFICIALIZADA"
           const sufixoPadronizado = sufixo.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
           classeFinal = `${prefixo} / ${sufixoPadronizado}`;
         } else {
           // Se n√£o tem prefixo, apenas padroniza para "OFICIALIZADA"
           classeFinal = classeOriginal.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
         }
         
         console.log('üéπ Padronizando classe para:', registro.cargo);
         console.log('üéπ Classe original:', classeOriginal, '‚Üí Padronizada para:', classeFinal);
       }
             
            // üö® CORRE√á√ÉO: N√ÉO atribuir classe quando nome foi inserido manualmente
            const isNomeManual = nomeEl && nomeEl.hasAttribute('data-nome-manual');
            if (!isNomeManual) {
              nomeEl.setAttribute('data-classe', classeFinal);
              console.log('üéπ Classe armazenada automaticamente (nome da lista):', classeFinal);
            } else {
              console.log('üö® Nome inserido manualmente - N√ÉO atribuindo classe (cadastro desatualizado)');
            }
            return;
           }
         }
       } catch (e) {
         console.log('‚ùå Erro na consulta direta:', e.message);
       }
       
       console.log('‚ùå Nenhuma classe encontrada via consulta direta');
       return;
     }
     
     // Busca o registro correspondente ao nome selecionado
     console.log('üîç Buscando registro para nome:', nomeSelecionado);
     console.log('üîç Dados dispon√≠veis:', dadosCompletos.map(r => ({ nome: r.nome, nivel: r.nivel })));
     
    // üö® CORRE√á√ÉO: Buscar diretamente pelo nome, sem loop desnecess√°rio e sem logs
    // Normaliza o nome selecionado uma vez para compara√ß√£o
    const nomeSelecionadoNormalizado = norm(nomeSelecionado).toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase());
    
    const registro = dadosCompletos.find(r => {
      const nomeNormalizado = norm(r.nome).toLowerCase().replace(/(^.|[\s\-'.][a-z])/g, m => m.toUpperCase());
      return nomeNormalizado === nomeSelecionadoNormalizado;
    });
    
    // Log apenas se encontrar o registro (evita spam)
    if (registro) {
      console.log('‚úÖ Registro encontrado para captura de classe:', { nome: registro.nome, nivel: registro.nivel });
    }
     
     console.log('üîç Registro encontrado:', registro);
     
     if (registro && registro.nivel) {
       console.log('üéπ Classe capturada automaticamente:', { nome: registro.nome, nivel: registro.nivel });
       
       // NOVA FUNCIONALIDADE: For√ßar classe como "OFICIALIZADA" para cargos musicais
       // üõ°Ô∏è CORRE√á√ÉO: Apenas SECRET√ÅRIA DA M√öSICA (feminino) recebe classe de organista
       let classeFinal = registro.nivel;
       const isCargoMusical = registro.cargo && (
         registro.cargo.toUpperCase().includes('ORGANISTA') ||
         registro.cargo.toUpperCase().includes('INSTRUTORA') ||
         registro.cargo.toUpperCase().includes('EXAMINADORA') ||
         // Removido: INSTRUTOR n√£o deve receber classe de organista
         (registro.cargo.toLowerCase().includes('secret√°ria') && registro.cargo.toLowerCase().includes('m√∫sica'))
       );
       
       if (isCargoMusical) {
         const classeOriginal = registro.nivel;
         
         // Verifica se tem prefixo (ex: "RJM / OFICIALIZADO(A)")
         if (classeOriginal.includes('/')) {
           const partes = classeOriginal.split('/');
           const prefixo = partes[0].trim();
           const sufixo = partes[1].trim();
           
           // Remove "(A)" do sufixo e padroniza para "OFICIALIZADA"
           const sufixoPadronizado = sufixo.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
           classeFinal = `${prefixo} / ${sufixoPadronizado}`;
         } else {
           // Se n√£o tem prefixo, apenas padroniza para "OFICIALIZADA"
           classeFinal = classeOriginal.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
         }
         
         console.log('üéπ Padronizando classe para:', registro.cargo);
         console.log('üéπ Classe original:', classeOriginal, '‚Üí Padronizada para:', classeFinal);
       }
       
      // üö® CORRE√á√ÉO: N√ÉO atribuir classe quando nome foi inserido manualmente
      const isNomeManual = nomeEl && nomeEl.hasAttribute('data-nome-manual');
      if (!isNomeManual) {
        nomeEl.setAttribute('data-classe', classeFinal);
        console.log('üéπ Classe armazenada automaticamente (nome da lista):', classeFinal);
        
        // üõ°Ô∏è MOBILE FIX: Garantir que o atributo foi realmente definido
        const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobileDevice) {
          const dataClasseVerificado = nomeEl.getAttribute('data-classe');
          if (dataClasseVerificado !== classeFinal) {
            console.error('üö® MOBILE FIX: Atributo data-classe n√£o foi definido corretamente! Tentando novamente...');
            nomeEl.setAttribute('data-classe', classeFinal);
            // For√ßar atualiza√ß√£o do DOM em mobile
            nomeEl.dispatchEvent(new Event('change', { bubbles: true }));
          }
          console.log('üì± MOBILE DEBUG - data-classe verificado:', dataClasseVerificado);
        }
      } else {
        console.log('üö® Nome inserido manualmente - N√ÉO atribuindo classe (cadastro desatualizado)');
      }
     } else {
       console.log('üéπ Nenhuma classe encontrada para:', nomeSelecionado);
       if (registro) {
         console.log('üéπ Registro encontrado mas sem nivel:', registro);
       }
     }
   }
   
   /* ===== DETEC√á√ÉO AUTOM√ÅTICA DE CARGO DE ORGANISTA ===== */
   async function detectarCargoOrganistaAutomaticamente(nomeSelecionado, comumVal, cargoVal, cargoEl) {
     try {
       // S√≥ executa se o cargo atual for "Organista"
       const cargoUP = ucase(cargoVal);
       // Log removido
       
       if (cargoUP !== 'ORGANISTA') {
         console.log('üéπ N√£o √© organista, pulando detec√ß√£o autom√°tica de cargo');
         return;
       }
       
       console.log('üéπ Detectando cargo autom√°tico para organista:', { nomeSelecionado, comumVal });
       console.log('üéπ DEBUG - Verificando se Supabase est√° dispon√≠vel:', { supabaseLoaded, sb: !!sb });
       
       // Verifica se o Supabase est√° dispon√≠vel
       if (!supabaseLoaded || !sb) {
         console.log('‚ö†Ô∏è Supabase n√£o dispon√≠vel para detec√ß√£o autom√°tica de cargo');
         return;
       }
       
       // DEBUG: Log detalhado da consulta
       console.log('üîç DEBUG - Par√¢metros da consulta:', {
         table: TABLE_CATALOGO,
         comumVal,
         nomeSelecionado,
         comumFilter: `%${comumVal}%`,
         nomeFilter: `%${nomeSelecionado}%`
       });
       
       // Busca TODOS os cargos da pessoa para detectar o cargo correto
       console.log('üîç DEBUG - Fazendo consulta ao Supabase:', {
         table: TABLE_CATALOGO,
         comumFilter: `%${comumVal}%`,
         nomeFilter: `%${nomeSelecionado}%`
       });
       
       const { data, error } = await sb
         .from(TABLE_CATALOGO)
         .select('nome, cargo, nivel, instrumento, comum')
         .ilike('comum', `%${comumVal}%`)
         .ilike('nome', `%${nomeSelecionado}%`)
        .or('cargo.ilike.%ORGANISTA%,cargo.ilike.%EXAMINADORA%,cargo.ilike.%INSTRUTORA%,cargo.ilike.%SECRET√ÅRIA DA M√öSICA%,cargo.ilike.%SECRETARIA DA MUSICA%,cargo.ilike.%SECRET√ÅRIO DA M√öSICA%,cargo.ilike.%SECRETARIO DA MUSICA%,cargo.ilike.%SECRET√ÅRIA DO GEM%,cargo.ilike.%SECRET√ÅRIO DO GEM%')
         .eq('ativo', true)
         .order('cargo', { ascending: true });
       
       console.log('üîç DEBUG - Resultado da consulta:', { data, error });
       
       if (error) {
         console.error('‚ùå Erro ao buscar cargo da organista:', error);
         return;
       }
       
       if (data && data.length > 0) {
         console.log('üéπ Todos os registros encontrados para a pessoa:', data);
         console.log('üîç DEBUG - An√°lise detalhada dos registros:');
         
         data.forEach((r, index) => {
           console.log(`  ${index + 1}. Nome: "${r.nome}", Cargo: "${r.cargo}", Instrumento: "${r.instrumento}", Comum: "${r.comum}"`);
         });
         
         // üö® CORRE√á√ÉO CR√çTICA: Busca especificamente o cargo relacionado ao √≥rg√£o
         // MAS APENAS CARGOS FEMININOS para organistas
         const registroOrgao = data.find(r => 
           r.instrumento && r.instrumento.toUpperCase().includes('√ìRG√ÉO') &&
           (r.cargo.toUpperCase().includes('ORGANISTA') ||
            r.cargo.toUpperCase().includes('EXAMINADORA') ||
            r.cargo.toUpperCase().includes('INSTRUTORA') ||
            (r.cargo.toLowerCase().includes('secret√°ria') && r.cargo.toLowerCase().includes('m√∫sica')))
         );
         
         console.log('üîç DEBUG - Registro com √≥rg√£o encontrado (apenas feminino):', registroOrgao);
         
         // Se n√£o encontrar cargo espec√≠fico do √≥rg√£o feminino, busca qualquer cargo feminino
         let registro = registroOrgao;
         if (!registro) {
           registro = data.find(r => 
             r.cargo.toUpperCase().includes('ORGANISTA') ||
             r.cargo.toUpperCase().includes('EXAMINADORA') ||
             r.cargo.toUpperCase().includes('INSTRUTORA') ||
             (r.cargo.toLowerCase().includes('secret√°ria') && r.cargo.toLowerCase().includes('m√∫sica'))
           );
         }
         
         // üö® FILTRO DE SEGURAN√áA: Se n√£o encontrou cargo feminino espec√≠fico, 
         // N√ÉO usa fallback masculino - mant√©m como "Organista"
         if (!registro) {
           console.log('üö® FILTRO DE SEGURAN√áA: Nenhum cargo feminino espec√≠fico encontrado');
           console.log('üö® Mantendo cargo "Organista" para evitar erro de g√™nero');
           cargoEl.removeAttribute('data-cargo-real');
           return;
         }
         
         const cargoEncontrado = registro.cargo;
         
         console.log('üéπ Registro selecionado:', {
           nome: registro.nome,
           cargo: registro.cargo,
           instrumento: registro.instrumento,
           nivel: registro.nivel,
           comum: registro.comum,
           foiSelecionadoPorOrgao: !!registroOrgao,
           totalRegistros: data.length
         });
         
         console.log('üéπ Cargo encontrado para organista:', { 
           nome: registro.nome, 
           cargo: cargoEncontrado,
           nivel: registro.nivel,
           instrumento: registro.instrumento
         });
         
         // üö® VALIDA√á√ÉO CR√çTICA: Verifica se o cargo √© feminino antes de atribuir
         const cargoUpper = cargoEncontrado.toUpperCase();
         const isCargoMasculino = (cargoUpper.includes('INSTRUTOR') && !cargoUpper.includes('INSTRUTORA')) ||
                                 cargoUpper.includes('SECRET√ÅRIO DO GEM') ||
                                 cargoUpper.includes('SECRETARIO DO GEM') ||
                                 (cargoUpper.includes('SECRET√ÅRIO') && cargoUpper.includes('M√öSICA') && !cargoUpper.includes('SECRET√ÅRIA'));
         
         if (isCargoMasculino) {
           console.log('üö® ERRO CR√çTICO PREVENIDO: Cargo masculino detectado para organista:', cargoEncontrado);
           console.log('üö® Mantendo cargo original "Organista" para evitar erro de g√™nero');
           cargoEl.removeAttribute('data-cargo-real');
           return;
         }
         
         // Armazena o cargo real encontrado para uso posterior (sem alterar a interface)
         if (!cargoEncontrado.toLowerCase().includes('organista')) {
           console.log('üéπ Cargo musical feminino detectado - cargo real ser√° usado no envio:', cargoEncontrado);
           // Armazena o cargo real no elemento para uso posterior
           cargoEl.setAttribute('data-cargo-real', cargoEncontrado);
           
           // Se for examinadora, mostra mensagem informativa
           if (cargoEncontrado.toLowerCase().includes('examinadora')) {
             console.log('üéπ Examinadora detectada automaticamente - ser√° inclu√≠da na planilha como:', cargoEncontrado);
           }
           
           // Se for secret√°ria da m√∫sica, mostra mensagem informativa
           if (cargoEncontrado.toLowerCase().includes('secret√°ria') && cargoEncontrado.toLowerCase().includes('m√∫sica')) {
             console.log('üéπ Secret√°ria da M√∫sica detectada automaticamente - ser√° inclu√≠da na planilha como:', cargoEncontrado);
           }
         } else {
           console.log('üéπ Organista comum - mantendo cargo "Organista"');
           cargoEl.removeAttribute('data-cargo-real');
         }
         
         // üö® CORRE√á√ÉO: N√ÉO atribuir classe quando nome foi inserido manualmente
         // Pois indica que o cadastro est√° desatualizado
         const nomeEl = findNomeField();
         const isNomeManual = nomeEl && nomeEl.hasAttribute('data-nome-manual');
         
         if (registro.nivel && !isNomeManual) {
           if (nomeEl) {
             nomeEl.setAttribute('data-classe', registro.nivel);
             console.log('üéπ Classe armazenada automaticamente (nome da lista):', registro.nivel);
           }
         } else if (isNomeManual) {
           console.log('üö® Nome inserido manualmente - N√ÉO atribuindo classe (cadastro desatualizado)');
         } else {
           console.log('üéπ Nenhuma classe dispon√≠vel para armazenar');
         }
         
       } else {
         console.log('üéπ Nenhum registro encontrado para a organista');
         
         // DEBUG: Teste adicional - busca mais ampla
         console.log('üîç DEBUG - Testando busca mais ampla...');
         try {
           const { data: dataAmpla, error: errorAmpla } = await sb
             .from(TABLE_CATALOGO)
             .select('nome, cargo, nivel, instrumento, comum')
             .ilike('nome', `%${nomeSelecionado}%`)
             .eq('ativo', true)
             .limit(10);
           
           if (!errorAmpla && dataAmpla && dataAmpla.length > 0) {
             console.log('üîç DEBUG - Busca ampla encontrou registros:', dataAmpla);
           } else {
             console.log('üîç DEBUG - Busca ampla n√£o encontrou registros');
           }
         } catch (e) {
           console.log('üîç DEBUG - Erro na busca ampla:', e.message);
         }
       }
       
     } catch (error) {
       console.error('‚ùå Erro na detec√ß√£o autom√°tica de cargo:', error);
     }
   }
   
   /* ===== DETEC√á√ÉO AUTOM√ÅTICA DE CARGO DE INSTRUTOR ===== */
   async function detectarCargoMusicalAutomaticamente(nomeSelecionado, comumVal, cargoVal, cargoEl, instVal) {
     try {
       console.log('üéì Detectando se m√∫sico √© instrutor, encarregado ou secret√°rio:', { nomeSelecionado, comumVal, cargoVal, instVal });
       
       // Verifica se o Supabase est√° dispon√≠vel
       if (!supabaseLoaded || !sb) {
         console.log('‚ö†Ô∏è Supabase n√£o dispon√≠vel para detec√ß√£o de cargo musical');
         return;
       }
       
       // Busca se a pessoa √© instrutor, encarregado ou secret√°rio no banco usando comum + nome + instrumento
       console.log('üîç DEBUG - Fazendo consulta para cargo musical:', {
         nome: `%${nomeSelecionado}%`,
         comum: `%${comumVal}%`,
         instrumento: `%${instVal}%`
       });
       
       // üö® CORRE√á√ÉO CR√çTICA: Fazer busca mais ampla primeiro (sem filtro de instrumento)
       // Isso garante que encontre o cargo correto mesmo se o instrumento n√£o corresponder exatamente
       const { data: debugData, error: debugError } = await sb
         .from(TABLE_CATALOGO)
         .select('cargo, instrumento, nome, nivel, comum')
         .ilike('nome', `%${nomeSelecionado}%`)
         .ilike(COL_COMUM, `%${comumVal}%`)
         .eq('ativo', true);
       
       console.log('üîç DEBUG - Busca ampla para debug:', { debugData, debugError });
       
       // üö® CORRE√á√ÉO CR√çTICA: Buscar por cargos musicais sem filtro de instrumento primeiro
       // Isso garante que encontre "Secret√°rio da M√∫sica" mesmo sem instrumento ou com instrumento diferente
       let data = null;
       let error = null;
       
       // Primeiro tenta buscar com filtro de instrumento (se houver)
       if (instVal && instVal.trim() !== '') {
         const { data: dataComInst, error: errorComInst } = await sb
           .from(TABLE_CATALOGO)
           .select('cargo, instrumento, nome, nivel')
           .ilike('nome', `%${nomeSelecionado}%`)
           .ilike(COL_COMUM, `%${comumVal}%`)
           .ilike('instrumento', `%${instVal}%`)
           .or('cargo.ilike.%INSTRUTOR%,cargo.ilike.%INSTRUTORA%,cargo.ilike.%EXAMINADORA%,cargo.ilike.%ENCARREGADO LOCAL%,cargo.ilike.%ENCARREGADO REGIONAL%,cargo.ilike.%SECRET√ÅRIO DA M√öSICA%,cargo.ilike.%SECRETARIO DA MUSICA%,cargo.ilike.%SECRET√ÅRIA DA M√öSICA%,cargo.ilike.%SECRETARIA DA MUSICA%,cargo.ilike.%SECRET√ÅRIO DO GEM%,cargo.ilike.%SECRET√ÅRIA DO GEM%')
           .eq('ativo', true)
           .limit(1);
         
         if (dataComInst && dataComInst.length > 0) {
           data = dataComInst;
           error = errorComInst;
           console.log('üîç DEBUG - Cargo encontrado com filtro de instrumento:', data);
         }
       }
       
       // Se n√£o encontrou com filtro de instrumento, busca sem filtro de instrumento
       if (!data || data.length === 0) {
         console.log('üîç DEBUG - Buscando sem filtro de instrumento...');
         const { data: dataSemInst, error: errorSemInst } = await sb
           .from(TABLE_CATALOGO)
           .select('cargo, instrumento, nome, nivel')
           .ilike('nome', `%${nomeSelecionado}%`)
           .ilike(COL_COMUM, `%${comumVal}%`)
           .or('cargo.ilike.%INSTRUTOR%,cargo.ilike.%INSTRUTORA%,cargo.ilike.%EXAMINADORA%,cargo.ilike.%ENCARREGADO LOCAL%,cargo.ilike.%ENCARREGADO REGIONAL%,cargo.ilike.%SECRET√ÅRIO DA M√öSICA%,cargo.ilike.%SECRETARIO DA MUSICA%,cargo.ilike.%SECRET√ÅRIA DA M√öSICA%,cargo.ilike.%SECRETARIA DA MUSICA%,cargo.ilike.%SECRET√ÅRIO DO GEM%,cargo.ilike.%SECRET√ÅRIA DO GEM%')
           .eq('ativo', true)
           .limit(1);
         
         data = dataSemInst;
         error = errorSemInst;
         console.log('üîç DEBUG - Resultado da busca sem filtro de instrumento:', { data, error });
       }
       
       // üö® CORRE√á√ÉO CR√çTICA: Se ainda n√£o encontrou, fazer busca ainda mais ampla (apenas nome + comum)
       // Isso garante que encontre "Secret√°rio da M√∫sica" mesmo que o cargo n√£o esteja na lista OR
       if (!data || data.length === 0) {
         console.log('üîç DEBUG - Buscando com busca ainda mais ampla (apenas nome + comum)...');
         const { data: dataAmpla, error: errorAmpla } = await sb
           .from(TABLE_CATALOGO)
           .select('cargo, instrumento, nome, nivel')
           .ilike('nome', `%${nomeSelecionado}%`)
           .ilike(COL_COMUM, `%${comumVal}%`)
           .eq('ativo', true)
           .limit(10); // Busca mais registros para filtrar depois
         
         if (dataAmpla && dataAmpla.length > 0) {
           // Filtra localmente por cargos musicais especiais
           const cargoEspecial = dataAmpla.find(r => {
             const cargoUpper = (r.cargo || '').toUpperCase();
             return cargoUpper.includes('INSTRUTOR') ||
                    cargoUpper.includes('INSTRUTORA') ||
                    cargoUpper.includes('EXAMINADORA') ||
                    cargoUpper.includes('ENCARREGADO LOCAL') ||
                    cargoUpper.includes('ENCARREGADO REGIONAL') ||
                    (cargoUpper.includes('SECRET√ÅRIO') && cargoUpper.includes('M√öSICA')) ||
                    (cargoUpper.includes('SECRETARIO') && cargoUpper.includes('MUSICA')) ||
                    (cargoUpper.includes('SECRET√ÅRIA') && cargoUpper.includes('M√öSICA')) ||
                    (cargoUpper.includes('SECRETARIA') && cargoUpper.includes('MUSICA')) ||
                    cargoUpper.includes('SECRET√ÅRIO DO GEM') ||
                    cargoUpper.includes('SECRET√ÅRIA DO GEM');
           });
           
           if (cargoEspecial) {
             data = [cargoEspecial];
             error = errorAmpla;
             console.log('üîç DEBUG - Cargo especial encontrado na busca ampla:', cargoEspecial);
           } else {
             console.log('üîç DEBUG - Nenhum cargo especial encontrado na busca ampla');
           }
         } else {
           data = dataAmpla;
           error = errorAmpla;
         }
         
         console.log('üîç DEBUG - Resultado da busca ampla:', { data, error });
       }
       
       console.log('üîç DEBUG - Resultado final da consulta de cargo musical:', { data, error });
       
       if (error) {
         console.error('‚ùå Erro ao buscar cargo musical:', error);
         return;
       }
       
       if (data && data.length > 0) {
         const registroCargo = data[0];
         console.log('üéì CARGO MUSICAL DETECTADO:', registroCargo);
         
         // Armazena o cargo real para uso posterior
         cargoEl.setAttribute('data-cargo-real', registroCargo.cargo);
         console.log('üéì Cargo real armazenado:', registroCargo.cargo);
         
         // Armazena o n√≠vel do cargo para uso posterior
         if (registroCargo.nivel) {
           cargoEl.setAttribute('data-nivel-instrutor', registroCargo.nivel);
           console.log('üéì N√≠vel do cargo armazenado:', registroCargo.nivel);
         }
       } else {
         console.log('üéì M√∫sico comum - n√£o √© cargo musical especial');
         console.log('üîç DEBUG - Nenhum registro de cargo musical encontrado para:', { nomeSelecionado, comumVal, instVal });
         cargoEl.removeAttribute('data-cargo-real');
         cargoEl.removeAttribute('data-nivel-instrutor');
       }
       
     } catch (error) {
       console.error('‚ùå Erro na detec√ß√£o de cargo musical:', error);
     }
   }
   
   /* ===== MODAL NOVA COMUM/M√öSICO ===== */
   // üîß CORRE√á√ÉO: Expor fun√ß√£o globalmente para garantir acesso
   async function carregarCargosModal() {
     try {
       console.log('üîÑ carregarCargosModal chamada');
       const cargoSelect = document.getElementById('gsCargo');
       if (!cargoSelect) {
         console.error('‚ùå Elemento gsCargo n√£o encontrado!');
         return;
       }
       
       console.log('‚úÖ Elemento gsCargo encontrado, limpando select...');
       // FOR√áA limpeza do select antes de popular
       cargoSelect.innerHTML = '';
       
       // Usa window.CARGOS_COMPLETOS_MODAL ou CARGOS_COMPLETOS_MODAL
       const cargos = (window.CARGOS_COMPLETOS_MODAL || CARGOS_COMPLETOS_MODAL || []).slice();
       
       if (!cargos || cargos.length === 0) {
         console.error('‚ùå Nenhum cargo dispon√≠vel!');
         cargoSelect.innerHTML = '<option value="">Erro: Nenhum cargo dispon√≠vel</option>';
         return;
       }
       
       console.log('üìã Cargos dispon√≠veis:', cargos.length);
       
       // Carrega os cargos de forma simples
       cargoSelect.innerHTML = '<option value="">Selecione o cargo...</option>' +
         cargos.map(cargo => `<option value="${cargo}">${cargo}</option>`).join('');
       
       console.log('‚úÖ Cargos carregados no modal:', cargos.length);
       console.log('‚úÖ Total de options no select:', cargoSelect.options.length);
     } catch (error) {
       console.error('‚ùå Erro ao carregar cargos no modal:', error);
       const cargoSelect = document.getElementById('gsCargo');
       if (cargoSelect) {
         cargoSelect.innerHTML = '<option value="">Erro ao carregar cargos</option>';
       }
     }
   }
   
   // Fun√ß√£o auxiliar para carregar cargos quando acessados via window
   async function carregarCargosComAcesso(cargos) {
     let cargoSelect = null;
     let tentativas = 0;
     const maxTentativas = 10;
     
     while (!cargoSelect && tentativas < maxTentativas) {
       cargoSelect = document.getElementById('gsCargo');
       if (!cargoSelect) {
         tentativas++;
         await new Promise(resolve => setTimeout(resolve, 150));
       }
     }
     
     if (!cargoSelect) {
       console.error('‚ùå Elemento gsCargo n√£o encontrado!');
       return;
     }
     
     cargoSelect.innerHTML = '';
     const defaultOption = document.createElement('option');
     defaultOption.value = '';
     defaultOption.textContent = 'Selecione o cargo...';
     cargoSelect.appendChild(defaultOption);
     
     cargos.forEach(cargo => {
       const option = document.createElement('option');
       option.value = cargo;
       option.textContent = cargo;
       cargoSelect.appendChild(option);
     });
     
     console.log('‚úÖ Cargos carregados via window:', cargos.length);
   }
   
   // üîß CORRE√á√ÉO: Expor fun√ß√µes globalmente para garantir acesso
   window.carregarCargosModal = carregarCargosModal;
   
   async function carregarInstrumentosModal() {
     try {
       const instrumentoSelect = document.getElementById('gsInstrumento');
       if (!instrumentoSelect) {
         console.error('‚ùå Elemento gsInstrumento n√£o encontrado!');
         return;
       }
       
       // Usa window.INSTRUMENTS_FIXED ou INSTRUMENTS_FIXED
       const instrumentos = (window.INSTRUMENTS_FIXED || INSTRUMENTS_FIXED || []).slice();
       
       if (!instrumentos || instrumentos.length === 0) {
         console.error('‚ùå Nenhum instrumento dispon√≠vel!');
         instrumentoSelect.innerHTML = '<option value="">Erro: Nenhum instrumento dispon√≠vel</option>';
         return;
       }
       
       // üì± MOBILE: Filtrar "√ìRG√ÉO" apenas da exibi√ß√£o (n√£o remove do array original)
       // A l√≥gica continua funcionando normalmente, apenas oculta da lista para n√£o confundir o usu√°rio
       const isMobileDevice = window.innerWidth <= 768 || /Mobile|Android|iPhone|iPad/.test(navigator.userAgent);
       const instrumentosParaExibir = isMobileDevice 
         ? instrumentos.filter(inst => inst !== '√ìRG√ÉO')
         : instrumentos;
       
       // Carrega os instrumentos de forma simples
       instrumentoSelect.innerHTML = '<option value="">Selecione um instrumento...</option>' +
         instrumentosParaExibir.map(inst => `<option value="${inst}">${inst}</option>`).join('');
       
       // üö® CORRE√á√ÉO CR√çTICA: Adicionar "√ìRG√ÉO" como op√ß√£o oculta no mobile
       // Isso garante que o valor possa ser definido programaticamente mesmo que n√£o esteja vis√≠vel
       if (isMobileDevice && instrumentos.includes('√ìRG√ÉO')) {
         const orgaoOption = document.createElement('option');
         orgaoOption.value = '√ìRG√ÉO';
         orgaoOption.textContent = '√ìRG√ÉO';
         orgaoOption.style.display = 'none'; // Oculta da lista, mas mant√©m dispon√≠vel para valor
         instrumentoSelect.appendChild(orgaoOption);
       }
       
       console.log('‚úÖ Instrumentos carregados no modal:', instrumentosParaExibir.length, isMobileDevice ? '(√ìRG√ÉO oculto no mobile, mas dispon√≠vel para valor)' : '');
     } catch (error) {
       console.error('‚ùå Erro ao carregar instrumentos no modal:', error);
       const instrumentoSelect = document.getElementById('gsInstrumento');
       if (instrumentoSelect) {
         instrumentoSelect.innerHTML = '<option value="">Erro ao carregar instrumentos</option>';
       }
     }
   }
   
   // üîß CORRE√á√ÉO: Expor fun√ß√£o de instrumentos globalmente
   window.carregarInstrumentosModal = carregarInstrumentosModal;
   
  function inicializarModal() {
    console.log('üîß CORRE√á√ÉO REAL: Inicializando modal para permitir digita√ß√£o...');
    
    // Carrega cargos e instrumentos quando o modal √© aberto
    const modal = document.getElementById('modalNovaComum');
    if (!modal) {
      console.error('‚ùå Modal modalNovaComum n√£o encontrado!');
      return;
    }
    
    console.log('‚úÖ Modal encontrado, configurando eventos b√°sicos...');
    
    // Configura√ß√£o inicial b√°sica
    modal.setAttribute('aria-modal', 'false');
    modal.setAttribute('aria-hidden', 'true');
    
    // üîß CORRE√á√ÉO CR√çTICA: Adiciona listener para carregar cargos quando modal abrir
    // Detectar se √© mobile
    const isMobileDevice = window.innerWidth <= 768 || /Mobile|Android|iPhone|iPad/.test(navigator.userAgent);
    
    // üöÄ CORRE√á√ÉO MOBILE: Carregar no evento show.bs.modal tamb√©m (antes de shown)
    modal.addEventListener('show.bs.modal', function() {
      console.log('üì± Modal iniciando abertura (show.bs.modal)...');
      if (isMobileDevice) {
        // No mobile, carrega imediatamente no show.bs.modal
        setTimeout(() => {
          console.log('üì± Mobile: Carregando cargos no show.bs.modal...');
          if (typeof window.carregarCargosModal === 'function') {
            window.carregarCargosModal();
          } else if (typeof carregarCargosModal === 'function') {
            carregarCargosModal();
          }
          if (typeof window.carregarInstrumentosModal === 'function') {
            window.carregarInstrumentosModal();
          } else if (typeof carregarInstrumentosModal === 'function') {
            carregarInstrumentosModal();
          }
        }, 50);
      }
    });
    
    modal.addEventListener('shown.bs.modal', function() {
      console.log('‚úÖ Modal aberto - carregando cargos e instrumentos...');
      // Aguarda um pouco para garantir que o modal est√° completamente renderizado
      const delay = isMobileDevice ? 200 : 150; // Delay maior no mobile
      setTimeout(() => {
        if (typeof window.carregarCargosModal === 'function') {
          window.carregarCargosModal();
        } else if (typeof carregarCargosModal === 'function') {
          carregarCargosModal();
        } else {
          console.error('‚ùå Fun√ß√£o carregarCargosModal n√£o encontrada!');
        }
        if (typeof window.carregarInstrumentosModal === 'function') {
          window.carregarInstrumentosModal();
        } else if (typeof carregarInstrumentosModal === 'function') {
          carregarInstrumentosModal();
        }
      }, delay);
      
      // üöÄ CORRE√á√ÉO MOBILE: Carregar novamente ap√≥s delay maior no mobile
      if (isMobileDevice) {
        setTimeout(() => {
          console.log('üì± Mobile: Verificando se cargos foram carregados...');
          const cargoSelect = document.getElementById('gsCargo');
          if (cargoSelect && cargoSelect.options.length <= 2) {
            console.log('üì± Mobile: Cargos n√£o carregados, tentando novamente...');
            if (typeof window.carregarCargosModal === 'function') {
              window.carregarCargosModal();
            } else if (typeof carregarCargosModal === 'function') {
              carregarCargosModal();
            }
          }
        }, 500);
      }
    });
    
    // CORRE√á√ÉO REAL: Apenas limpeza quando modal fecha
    modal.addEventListener('hidden.bs.modal', function () {
      console.log('üéπ Modal fechado - limpando campos...');
      
      // Limpa todos os campos
      const campos = ['gsComum', 'gsCidade', 'gsCargo', 'gsInstrumento', 'gsClasse', 'gsNome'];
      campos.forEach(id => {
        const campo = document.getElementById(id);
        if (campo) {
          campo.value = '';
          // CORRE√á√ÉO REAL: Garantir que campos sejam edit√°veis ap√≥s limpeza
          campo.removeAttribute('readonly');
          campo.removeAttribute('disabled');
          campo.style.pointerEvents = 'auto';
        }
      });
      
      // Reseta exibi√ß√£o dos campos
      const instrumentoContainer = document.getElementById('instrumentoContainer');
      const classeContainer = document.getElementById('classeContainer');
      if (instrumentoContainer) instrumentoContainer.style.display = 'block';
      if (classeContainer) classeContainer.style.display = 'none';
    });
    
    // Eventos b√°sicos apenas
    const cargoSelect = document.getElementById('gsCargo');
    if (cargoSelect) {
      cargoSelect.addEventListener('change', function() {
        controlarCamposModal(this.value);
      });
    }
    
    // üîß CORRE√á√ÉO: Adiciona evento blur para converter comum para mai√∫scula
    const gsComumInput = document.getElementById('gsComum');
    if (gsComumInput) {
      gsComumInput.addEventListener('blur', function() {
        if (this.value) {
          this.value = this.value.toUpperCase();
        }
      });
    }
    
    const btnSalvarGS = document.getElementById('btnSalvarGS');
    if (btnSalvarGS) {
      btnSalvarGS.addEventListener('click', async function() {
        await enviarDadosModal();
      });
    }
    
    console.log('‚úÖ Modal configurado para permitir digita√ß√£o');
  }
   
  function controlarCamposModal(cargoSelecionado) {
    const instrumentoContainer = document.getElementById('modalInstrumentoContainer');
    const classeContainer = document.getElementById('classeContainer');
    const instrumentoSelect = document.getElementById('gsInstrumento');
    const classeSelect = document.getElementById('gsClasse');
    
    if (!instrumentoContainer || !classeContainer || !instrumentoSelect || !classeSelect) {
      console.warn('‚ö†Ô∏è Elementos do modal n√£o encontrados');
      return;
    }
    
    const cargoUP = ucase(cargoSelecionado);
    const isOrganista = cargoUP === 'ORGANISTA';
    const isExaminadora = cargoUP === 'EXAMINADORA';
    const isInstrutora = cargoUP === 'INSTRUTORA';
    const isSecretariaMusica = cargoSelecionado.toLowerCase().includes('secret√°ria') && cargoSelecionado.toLowerCase().includes('m√∫sica');
    const isOrganistaOuRelacionado = isOrganista || isExaminadora || isInstrutora || isSecretariaMusica;
    
    // Cargos que devem ter classe automaticamente como OFICIALIZADA
    const cargosComClasseOficializada = isInstrutora || isExaminadora || isSecretariaMusica;
    
    // Cargos n√£o musicais que devem ocultar o campo instrumento
    const isMinisterio = cargoUP === 'MINIST√âRIO' || cargoUP === 'MINISTERIO';
    const isAnciao = cargoUP === 'ANCI√ÉO' || cargoUP === 'ANCIAO';
    const isDiacono = cargoUP === 'DI√ÅCONO' || cargoUP === 'DIACONO';
    const isCargoNaoMusical = isMinisterio || isAnciao || isDiacono;
    
    console.log('üéπ Controlando campos do modal:', { 
      cargoSelecionado, 
      cargoUP, 
      isOrganista, 
      isExaminadora, 
      isInstrutora, 
      isSecretariaMusica, 
      isCargoNaoMusical,
      cargosComClasseOficializada,
      debug: {
        cargoSelecionadoType: typeof cargoSelecionado,
        cargoSelecionadoLength: cargoSelecionado ? cargoSelecionado.length : 0,
        cargoUPType: typeof cargoUP,
        cargoUPLength: cargoUP ? cargoUP.length : 0,
        isInstrutoraCheck: cargoUP === 'INSTRUTORA',
        isExaminadoraCheck: cargoUP === 'EXAMINADORA'
      }
    });
    
    if (cargosComClasseOficializada) {
      // Para Instrutora, Examinadora e Secret√°ria da M√∫sica: oculta instrumento e classe, mas registra automaticamente como Oficializada
      instrumentoContainer.style.display = 'none';
      classeContainer.style.display = 'none';
      
      // Preenche automaticamente com √ìRG√ÉO
      instrumentoSelect.value = '√ìRG√ÉO';
      
      // Define automaticamente como Oficializada (ser√° usado no envio)
      classeSelect.value = 'OFICIALIZADA';
      
      console.log(`üéπ ${cargoSelecionado} selecionado - campos ocultos, classe automaticamente definida como OFICIALIZADA`);
    } else if (isOrganista) {
      // Para Organista: oculta instrumento e mostra classe (usu√°rio escolhe)
      instrumentoContainer.style.display = 'none';
      classeContainer.style.display = 'block';
      
      // Preenche automaticamente com √ìRG√ÉO
      instrumentoSelect.value = '√ìRG√ÉO';
      
      // Reabilitar campo de classe para usu√°rio escolher
      classeSelect.disabled = false;
      classeSelect.style.backgroundColor = '';
      classeSelect.style.cursor = '';
      
      console.log(`üéπ ${cargoSelecionado} selecionado - campo de classe ativado`);
    } else if (isCargoNaoMusical) {
      // Para cargos n√£o musicais: oculta instrumento e classe
      instrumentoContainer.style.display = 'none';
      classeContainer.style.display = 'none';
      
      // Adicionar classe CSS para for√ßar oculta√ß√£o
      const modalContent = document.querySelector('.modal.inmodal .modal-content');
      if (modalContent) {
        modalContent.classList.add('cargo-nao-musical');
        modalContent.classList.remove('organista-mode');
      }
      
      // Limpa os campos
      instrumentoSelect.value = '';
      classeSelect.value = '';
      
      console.log(`üéπ ${cargoSelecionado} selecionado - campos ocultos (cargo n√£o musical)`);
    } else {
      // Para outros cargos: mostra instrumento e oculta classe
      instrumentoContainer.style.display = 'block';
      classeContainer.style.display = 'none';
      
      // Reabilitar campo de classe caso tenha sido desabilitado
      classeSelect.disabled = false;
      classeSelect.style.backgroundColor = '';
      classeSelect.style.cursor = '';
      
      // Limpa o campo de classe
      classeSelect.value = '';
      
      console.log('üéπ Outro cargo selecionado - campo de instrumento ativado');
    }
  }
   
   // Flag para evitar m√∫ltiplas execu√ß√µes do modal
   let isModalProcessing = false;

   async function enviarDadosModal() {
     // Evitar m√∫ltiplas execu√ß√µes
     if (isModalProcessing) {
       console.log('‚ö†Ô∏è Modal j√° est√° sendo processado - ignorando chamada');
       return;
     }
     
     isModalProcessing = true;
     
     try {
       console.log('üöÄ IN√çCIO: enviarDadosModal');
       
      const comum = document.getElementById('gsComum').value.trim();
      const cidade = document.getElementById('gsCidade').value.trim();
     const cargo = document.getElementById('gsCargo').value.trim();
     const instrumento = document.getElementById('gsInstrumento').value.trim();
     const classeRaw = document.getElementById('gsClasse').value.trim();
     const nome = document.getElementById('gsNome').value.trim();
     
     // Valida√ß√£o b√°sica
     if (!comum || !cidade || !cargo || !nome) {
       showToast('error', 'Campos Obrigat√≥rios', 'Preencha todos os campos obrigat√≥rios', 3000);
       isModalProcessing = false;
       return;
     }
      
      // üéØ CORRE√á√ÉO: Determinar classe baseada no cargo
      const cargoUP = ucase(cargo);
      const cargoLower = cargo.toLowerCase();
      const cargoOriginal = cargo.trim();
      
      // üîß CORRE√á√ÉO: Detec√ß√£o mais robusta - verifica tanto com ucase quanto com o cargo original
      const isOrganista = cargoUP === 'ORGANISTA' || cargoOriginal.toUpperCase() === 'ORGANISTA';
      const isExaminadora = cargoUP === 'EXAMINADORA' || cargoOriginal.toUpperCase() === 'EXAMINADORA';
      const isInstrutora = cargoUP === 'INSTRUTORA' || cargoOriginal.toUpperCase() === 'INSTRUTORA';
      // üîß CORRE√á√ÉO: Detec√ß√£o mais robusta para Secret√°ria da M√∫sica (com e sem acentos)
      const isSecretariaMusica = (cargoLower.includes('secretaria') || cargoLower.includes('secret√°ria')) && 
                                 (cargoLower.includes('musica') || cargoLower.includes('m√∫sica')) ||
                                 cargoUP.includes('SECRETARIA') && cargoUP.includes('MUSICA');
      
      // Cargos que devem ter classe automaticamente como OFICIALIZADA
      const cargosComClasseOficializada = isInstrutora || isExaminadora || isSecretariaMusica;
      
      // Determinar classe final
      let classe = classeRaw;
      console.log('üîç DEBUG - Antes da l√≥gica de classe:', {
        cargo,
        cargoUP,
        cargoLower,
        classeRaw,
        classe,
        cargosComClasseOficializada,
        isInstrutora,
        isExaminadora,
        isSecretariaMusica
      });
      
      if (cargosComClasseOficializada) {
        classe = 'OFICIALIZADA';
        console.log(`üéØ Classe autom√°tica aplicada para ${cargo}: ${classe}`);
      } else if (isOrganista) {
        classe = classeRaw; // Usu√°rio escolhe
        console.log(`üéØ Classe escolhida pelo usu√°rio para ${cargo}: ${classe}`);
      } else {
        classe = ''; // Outros cargos n√£o precisam de classe
        console.log(`üéØ Sem classe para ${cargo}`);
      }
      
      console.log('üîç DEBUG - Depois da l√≥gica de classe:', {
        classeFinal: classe,
        classeRaw,
        cargosComClasseOficializada
      });
      
      // üõ°Ô∏è MOBILE FIX: Valida√ß√£o adicional para garantir que classe n√£o seja vazia para organistas
      const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      if (isMobileDevice && isOrganista && !classe) {
        console.log('üì± MOBILE FIX: Organista sem classe no modal - aplicando padr√£o OFICIALIZADA');
        classe = 'OFICIALIZADA';
        // Atualizar o campo select se existir
        const classeSelect = document.getElementById('gsClasse');
        if (classeSelect) {
          classeSelect.value = classe;
          console.log('üì± MOBILE FIX: Campo gsClasse atualizado com:', classe);
        }
      }
      
      console.log('üîç DEBUG - Detec√ß√£o de cargos no modal:', {
        cargo,
        cargoUP,
        isOrganista,
        isExaminadora,
        isInstrutora,
        isSecretariaMusica,
        cargosComClasseOficializada,
        classeFinal: classe,
        isMobile: isMobileDevice
      });
       
       // Valida√ß√£o rigorosa - n√£o permitir campos vazios
       if (!comum || !cidade || !cargo || !nome || 
           comum === '' || cidade === '' || cargo === '' || nome === '') {
         console.error('‚ùå Campos obrigat√≥rios vazios:', { comum, cidade, cargo, nome });
         
         // Mostrar erro espec√≠fico
         if (typeof window.showStatusModal === 'function') {
           window.showStatusModal('CAMPOS OBRIGAT√ìRIOS', 'Preencha todos os campos obrigat√≥rios', 'error');
         } else {
           showToast('error', 'Campos Obrigat√≥rios', 'Preencha todos os campos obrigat√≥rios', 3000);
         }
         
         isModalProcessing = false;
         return;
       }
       
       // Valida√ß√£o adicional para evitar registros com dados padr√£o
       if (comum === 'Sem comum' || cidade === 'Sem cidade' || 
           cargo === 'Sem cargo' || nome === 'Sem nome' ||
           comum === '' || cidade === '' || cargo === '' || nome === '') {
         console.error('‚ùå Dados padr√£o ou vazios detectados - cancelando envio');
         showToast('error', 'Dados Inv√°lidos', 'Preencha os campos com dados reais', 3000);
         return;
       }
       
       // Valida√ß√£o adicional para evitar registros com apenas UUID
       if (!comum || !cidade || !cargo || !nome) {
         console.error('‚ùå Registro incompleto detectado - cancelando envio');
         showToast('error', 'Registro Incompleto', 'Todos os campos obrigat√≥rios devem ser preenchidos', 3000);
         return;
       }
       
       // üö® VERIFICA√á√ÉO CR√çTICA DE DUPLICATA: Verificar antes de enviar
       if (supabaseLoaded && sb && nome && comum) {
         try {
           const dataAtual = new Date();
           const dataISO = dataAtual.toISOString().split('T')[0];
           
           // Buscar registros duplicados (mesmo nome + comum + cargo no mesmo dia)
           const { data: duplicatas, error: dupError } = await sb
             .from('presencas')
             .select('nome_completo, comum, cargo, created_at, uuid')
             .ilike('nome_completo', `%${nome.trim()}%`)
             .ilike('comum', `%${comum.trim()}%`)
             .gte('created_at', `${dataISO}T00:00:00.000Z`)
             .lt('created_at', `${dataISO}T23:59:59.999Z`)
             .limit(10);
           
           if (!dupError && duplicatas && duplicatas.length > 0) {
             // Verificar se h√° duplicata exata (mesmo nome, comum e cargo)
             const duplicataExata = duplicatas.find(d => {
               const nomeMatch = norm(d.nome_completo || '').toUpperCase().trim() === norm(nome).toUpperCase().trim();
               const comumMatch = compareComum(d.comum || '', comum).match;
               const cargoMatch = norm(d.cargo || '').toUpperCase().trim() === norm(cargo).toUpperCase().trim();
               return nomeMatch && comumMatch && cargoMatch;
             });
             
             if (duplicataExata) {
               console.error('üö®üö®üö® DUPLICATA DETECTADA NO MODAL - SOLICITANDO CONFIRMA√á√ÉO üö®üö®üö®', {
                 nome: nome,
                 comum: comum,
                 cargo: cargo,
                 uuidExistente: duplicataExata.uuid,
                 dataExistente: duplicataExata.created_at
               });
               
               const dataFormatada = new Date(duplicataExata.created_at).toLocaleDateString('pt-BR');
               
               // üö® CORRE√á√ÉO: Usar fun√ß√£o mostrarAlertaDuplicata para permitir confirma√ß√£o do usu√°rio
               // Se o usu√°rio confirmar, permite o cadastro. Se cancelar, bloqueia.
               const usuarioCancelou = await mostrarAlertaDuplicata(nome, comum, dataFormatada, duplicataExata);
               
               if (usuarioCancelou) {
                 // Usu√°rio cancelou - n√£o cadastrar
                 console.log('‚ùå Usu√°rio cancelou cadastro duplicado');
                 isModalProcessing = false;
                 btnSalvarGS.disabled = false;
                 btnSalvarGS.innerHTML = '<i class="fa-solid fa-save me-1"></i>Salvar';
                 return;
               }
               
               // Usu√°rio confirmou - continuar com o cadastro
               console.log('‚úÖ Usu√°rio confirmou cadastro mesmo com duplicata - continuando...');
               // üö® FLAG: Marcar que usu√°rio confirmou duplicata para permitir cadastro
               // Isso ser√° verificado nas fun√ß√µes autom√°ticas para n√£o bloquear novamente
               window._duplicataConfirmadaPeloUsuario = true;
               // N√£o retorna - continua o fluxo de cadastro normalmente
             }
           }
         } catch (error) {
           console.warn('‚ö†Ô∏è Erro ao verificar duplicatas no modal:', error);
           // Continua o envio apenas se n√£o for erro de duplicata
         }
       }
      
      // Usar as vari√°veis j√° declaradas acima
       
       // üö® CORRE√á√ÉO: Para organistas, se n√£o houver classe definida, usar padr√£o "OFICIALIZADA"
       // Isso garante que organistas sempre possam ser enviados, mesmo sem classe espec√≠fica
       if (isOrganista && !classe) {
         console.log('‚ö†Ô∏è Organista sem classe definida - aplicando padr√£o "OFICIALIZADA"');
         classe = 'OFICIALIZADA';
         // Preencher campo de n√≠vel se estiver vazio
         const nivelEl = document.querySelector('#nivel, [name="nivel"], input[placeholder*="classe"], input[placeholder*="nivel"]');
         if (nivelEl && !nivelEl.value.trim()) {
           nivelEl.value = classe;
         }
       }
       
       // Valida√ß√£o espec√≠fica para m√∫sicos (n√£o organistas)
       if (!isOrganista && cargo.toLowerCase().includes('m√∫sico') && !instrumento) {
         showToast('error', 'Instrumento Obrigat√≥rio', 'Selecione um instrumento para m√∫sicos', 3000);
         return;
       }
       
      // Verifica conectividade antes de tentar enviar
      // üö® CORRE√á√ÉO: Usar verifica√ß√£o mais simples e confi√°vel
      const isOnline = navigator.onLine;
      const duplicataConfirmada = window._duplicataConfirmadaPeloUsuario === true;
      
      // üö® CORRE√á√ÉO: Se usu√°rio confirmou duplicata, tentar enviar imediatamente mesmo se navigator.onLine retornar false
      // Isso garante que o registro seja processado quando o usu√°rio explicitamente confirma
      const deveTentarEnviar = isOnline || duplicataConfirmada;
      
      console.log('üîç Status de conex√£o no modal:', isOnline ? 'Online' : 'Offline');
      console.log('üîç navigator.onLine:', navigator.onLine);
      console.log('üîç Duplicata confirmada pelo usu√°rio:', duplicataConfirmada);
      console.log('üîç Deve tentar enviar:', deveTentarEnviar);
      
      // Desabilita o bot√£o
      const btnSalvarGS = document.getElementById('btnSalvarGS');
      btnSalvarGS.disabled = true;
      btnSalvarGS.innerHTML = '<i class="fa-solid fa-spinner fa-spin me-1"></i>Enviando...';
      
      if (!deveTentarEnviar) {
         // Modo offline - salva na fila local
         console.log('üìµ Modo offline no modal - salvando na fila local');
         
         // üéØ CORRE√á√ÉO: Detectar entrada manual tamb√©m no modo offline
         const nomeInputElOffline = document.getElementById('gsNome');
         let isNomeManualOffline = false;
         
         if (typeof window.isModalManualEntry === 'function') {
           isNomeManualOffline = window.isModalManualEntry();
         }
         
         if (!isNomeManualOffline && nomeInputElOffline) {
           const temAtributoManual = nomeInputElOffline.hasAttribute('data-nome-manual');
           const temEstiloManual = nomeInputElOffline.style.backgroundColor === 'rgb(254, 243, 199)' ||
                                  nomeInputElOffline.style.backgroundColor === 'rgb(240, 249, 255)' ||
                                  nomeInputElOffline.style.borderColor === 'rgb(245, 158, 11)' ||
                                  nomeInputElOffline.style.borderColor === 'rgb(59, 130, 246)';
           
           if (temAtributoManual || temEstiloManual) {
             isNomeManualOffline = true;
           }
         }
         
        // CORRE√á√ÉO: Modal offline sempre usa "Cadastro via modal offline" para todos os registros
        // O modal √© para registros de outras regionais, n√£o da regional atual
        let anotacoesOffline = "Cadastro via modal offline";
        console.log('üìù Modal offline: Usando anota√ß√£o padr√£o "Cadastro via modal offline" para todos os registros');
         
         // Gerar hor√°rio de registro no padr√£o S√£o Paulo/America
         const agora = new Date();
         const horarioRegistro = agora.toLocaleString('pt-BR', {
           timeZone: 'America/Sao_Paulo',
           year: 'numeric',
           month: '2-digit',
           day: '2-digit',
           hour: '2-digit',
           minute: '2-digit',
           second: '2-digit',
           hour12: false
         });
         
         console.log('üîç DEBUG - Antes de criar dadosModal (OFFLINE):', {
           cargo,
           cargoUP,
           classe,
           isOrganista,
           cargosComClasseOficializada,
           isInstrutora,
           isExaminadora,
           isSecretariaMusica,
           instrumentoFinal: (isOrganista || cargosComClasseOficializada) ? "√ìRG√ÉO" : (instrumento || ""),
           naipeFinal: (isOrganista || cargosComClasseOficializada) ? "TECLADO" : (instrumento ? getNaipeByInstrumento(instrumento) : ""),
           classeFinal: (isOrganista || cargosComClasseOficializada) ? classe : "",
          anotacoesOffline
         });
         
         const dadosModal = {
           "UUID": uuidv4(),
           "NOME COMPLETO": nome,
           "COMUM": comum,
           "CIDADE": cidade,
           "CARGO": cargo,
           "INSTRUMENTO": (isOrganista || cargosComClasseOficializada) ? "√ìRG√ÉO" : (instrumento || ""),
           "NAIPE_INSTRUMENTO": (isOrganista || cargosComClasseOficializada) ? "TECLADO" : (instrumento ? getNaipeByInstrumento(instrumento) : ""),
           "CLASSE_ORGANISTA": (isOrganista || cargosComClasseOficializada) ? classe : "",
           "LOCAL_ENSAIO": localStorage.getItem('session_local') || "",
           "DATA_ENSAIO": new Date().toLocaleDateString('pt-BR'),
           "HOR√ÅRIO": horarioRegistro, // Hor√°rio de registro no padr√£o S√£o Paulo/America
           "REGISTRADO_POR": localStorage.getItem('current_user_name') || "Sistema",
           "USER_ID": localStorage.getItem('current_user_id') || "",
           "ANOTACOES": anotacoesOffline,
           "SYNC_STATUS": "PENDENTE" // Status de sincroniza√ß√£o em portugu√™s (offline)
         };
         
         console.log('üîç DEBUG - dadosModal criado:', dadosModal);
         console.log('üîç DEBUG - CLASSE_ORGANISTA no dadosModal:', dadosModal["CLASSE_ORGANISTA"]);
         
         // üõ°Ô∏è MOBILE FIX: Valida√ß√£o final antes do envio offline - garantir que classe est√° presente para organistas
         const isMobileDeviceOffline = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
         if (isMobileDeviceOffline && isOrganista && !dadosModal["CLASSE_ORGANISTA"]) {
           console.error('üö® ERRO CR√çTICO MOBILE MODAL OFFLINE: Organista sem classe! Corrigindo...');
           dadosModal["CLASSE_ORGANISTA"] = classe || 'OFICIALIZADA';
           console.log('üì± MOBILE FIX OFFLINE: CLASSE_ORGANISTA corrigida para:', dadosModal["CLASSE_ORGANISTA"]);
         }
         
         // Padroniza todos os dados em mai√∫scula
         const dadosModalPadronizados = padronizarDadosMaiuscula(dadosModal);
         
         console.log('üìã DEBUG MODAL OFFLINE - Dados padronizados:', dadosModalPadronizados);
         console.log('üìã DEBUG MODAL OFFLINE - Cargo:', dadosModalPadronizados.CARGO || dadosModalPadronizados.cargo);
         
         // üöÄ CORRE√á√ÉO: Salvar na fila offline tamb√©m (n√£o apenas fila local)
         // Salva na fila local (fila_envio)
         pushQueue(dadosModalPadronizados);
         
         // üöÄ CORRE√á√ÉO: Tamb√©m salvar na fila offline (offline_queue_v3) para garantir processamento
         const dadosParaFilaOffline = {
           uuid: dadosModalPadronizados.UUID || dadosModalPadronizados.uuid || uuidv4(),
           nome: dadosModalPadronizados['NOME COMPLETO'] || dadosModalPadronizados.nome || nome,
           comum: dadosModalPadronizados.COMUM || dadosModalPadronizados.comum || comum,
           cidade: dadosModalPadronizados.CIDADE || dadosModalPadronizados.cidade || cidade,
           cargo: dadosModalPadronizados.CARGO || dadosModalPadronizados.cargo || cargo,
           instrumento: dadosModalPadronizados.INSTRUMENTO || dadosModalPadronizados.instrumento || instrumento,
           naipe: dadosModalPadronizados.NAIPE_INSTRUMENTO || dadosModalPadronizados.naipe || '',
           nivel: dadosModalPadronizados.CLASSE_ORGANISTA || dadosModalPadronizados.nivel || classe,
           local_ensaio: dadosModalPadronizados.LOCAL_ENSAIO || dadosModalPadronizados.local_ensaio || '',
           data_ensaio: dadosModalPadronizados.DATA_ENSAIO || dadosModalPadronizados.data_ensaio || '',
           registrado_por: dadosModalPadronizados.REGISTRADO_POR || dadosModalPadronizados.registrado_por || '',
           user_id: dadosModalPadronizados.USER_ID || dadosModalPadronizados.user_id || '',
           anotacoes: dadosModalPadronizados.ANOTACOES || dadosModalPadronizados.anotacoes || anotacoesOffline
         };
         
         console.log('üìã DEBUG MODAL OFFLINE - Dados para fila offline:', dadosParaFilaOffline);
         
         // üö® CORRE√á√ÉO: Se usu√°rio confirmou duplicata, marcar no item da fila
         if (window._duplicataConfirmadaPeloUsuario === true) {
           dadosParaFilaOffline.duplicataConfirmadaPeloUsuario = true;
           console.log('‚úÖ Flag de duplicata confirmada adicionada ao item da fila offline');
         }
         
         // Adiciona √† fila offline tamb√©m
         const recordId = addToOfflineQueue(dadosParaFilaOffline);
         console.log('üìã DEBUG MODAL OFFLINE - Registro adicionado √† fila offline com ID:', recordId);
         
         // Fecha modal e limpa campos
         const modal = bootstrap.Modal.getInstance(document.getElementById('modalNovaComum'));
         if (modal) modal.hide();
         
         showToast('warning', 'Salvo offline', 'Dados salvos na fila para envio posterior', 4000);
         return;
       }
       
       // CORRE√á√ÉO: Modal sempre usa "Cadastro fora da Regional", n√£o usa "SAM Desatualizado"
       // Verifica se o nome foi inserido manualmente (apenas para logs/debug)
       const nomeInputEl = document.getElementById('gsNome');
       let isNomeManual = false;
       
       console.log('üîç DEBUG - Verificando entrada manual no modal:', {
         nomeInputExiste: !!nomeInputEl,
         nomeValue: nomeInputEl ? nomeInputEl.value : 'N/A',
         hasDataAttribute: nomeInputEl ? nomeInputEl.hasAttribute('data-nome-manual') : false,
         backgroundColor: nomeInputEl ? nomeInputEl.style.backgroundColor : 'N/A',
         borderColor: nomeInputEl ? nomeInputEl.style.borderColor : 'N/A'
       });
       
       // üö® CORRE√á√ÉO: Detectar entrada manual no modal de forma mais robusta
       if (nomeInputEl && nomeInputEl.value.trim()) {
         // Verifica se tem o atributo data-nome-manual
         if (nomeInputEl.hasAttribute('data-nome-manual')) {
           isNomeManual = true;
           console.log('‚úèÔ∏è Entrada manual detectada no modal via atributo data-nome-manual');
         }
         // Verifica se tem estilo de entrada manual
         else if (nomeInputEl.style.backgroundColor === 'rgb(232, 245, 232)' || // #e8f5e8
                  nomeInputEl.style.backgroundColor === 'rgb(254, 243, 199)' || // #fef3c7
                  nomeInputEl.style.backgroundColor === 'rgb(240, 249, 255)' || // #f0f9ff
                  nomeInputEl.style.borderColor === 'rgb(40, 167, 69)' || // #28a745
                  nomeInputEl.style.borderColor === 'rgb(245, 158, 11)' || // #f59e0b
                  nomeInputEl.style.borderColor === 'rgb(59, 130, 246)') { // #3b82f6
           isNomeManual = true;
           console.log('‚úèÔ∏è Entrada manual detectada no modal via estilo');
         }
         // CORRE√á√ÉO CR√çTICA: Removida l√≥gica que for√ßava manual para nomes digitados no modal
         // A detec√ß√£o deve ser baseada apenas nos atributos do campo, n√£o no fato de ter digitado
       }
       
       // CORRE√á√ÉO CR√çTICA: REMOVIDA l√≥gica que for√ßava manual para cargos musicais no modal
       // A detec√ß√£o deve ser baseada apenas nos atributos do campo, n√£o no cargo
       
       // CORRE√á√ÉO CR√çTICA: REMOVIDA l√≥gica que for√ßava manual para cargos musicais no mobile modal
       // A detec√ß√£o deve ser baseada apenas nos atributos do campo, n√£o no cargo
       
       // Verifica se √© cargo musical (M√∫sico ou Organista)
       const cargoUPForAnotacao = ucase(cargo);
       const isCargoMusical = cargoUPForAnotacao.includes('M√öSICO') ||
                             cargoUPForAnotacao.includes('ORGANISTA') ||
                             cargoUPForAnotacao.includes('EXAMINADORA') ||
                             cargoUPForAnotacao.includes('INSTRUTORA') ||
                             (cargo.toLowerCase().includes('secret√°ria') && cargo.toLowerCase().includes('m√∫sica'));
       
       console.log('üîç Detec√ß√£o de entrada manual:', {
         isNomeManual,
         cargo,
         isCargoMusical,
         nomeInputExiste: !!nomeInputEl
       });
       
       // Determina anota√ß√µes e aba de destino
       let anotacoesFinal = "Cadastro fora da Regional";
       let sheetDestino = 'Dados';
       
      // CORRE√á√ÉO: Modal sempre usa "Cadastro fora da Regional" para todos os registros
      // O modal √© para registros de outras regionais, n√£o da regional atual
      console.log('üìù Modal: Usando anota√ß√£o padr√£o "Cadastro fora da Regional" para todos os registros');
      console.log('üîç DEBUG - Valores finais do modal:', {
        nome: nome,
        cargo: cargo,
        anotacoesFinal,
        sheetDestino
      });
       
       // Gerar hor√°rio de registro no padr√£o S√£o Paulo/America (apenas hora)
       const agora = new Date();
       const horarioRegistro = agora.toLocaleTimeString('pt-BR', {
         timeZone: 'America/Sao_Paulo',
         hour: '2-digit',
         minute: '2-digit',
         second: '2-digit',
         hour12: false
       });
       
       // Prepara dados para envio no mesmo formato do sistema principal
       console.log('üîç DEBUG - Antes de criar dadosModal (ONLINE):', {
         cargo,
         cargoUP,
         classe,
         isOrganista,
         cargosComClasseOficializada,
         isInstrutora,
         isExaminadora,
         isSecretariaMusica,
         instrumentoFinal: (isOrganista || cargosComClasseOficializada) ? "√ìRG√ÉO" : (instrumento || ""),
         naipeFinal: (isOrganista || cargosComClasseOficializada) ? "TECLADO" : (instrumento ? getNaipeByInstrumento(instrumento) : ""),
         classeFinal: (isOrganista || cargosComClasseOficializada) ? classe : ""
       });
       
       const dadosModal = {
         "UUID": uuidv4(),
         "NOME COMPLETO": nome,
         "COMUM": comum,
         "CIDADE": cidade,
         "CARGO": cargo,
         "INSTRUMENTO": (isOrganista || cargosComClasseOficializada) ? "√ìRG√ÉO" : (instrumento || ""),
         "NAIPE_INSTRUMENTO": (isOrganista || cargosComClasseOficializada) ? "TECLADO" : (instrumento ? getNaipeByInstrumento(instrumento) : ""),
         "CLASSE_ORGANISTA": (isOrganista || cargosComClasseOficializada) ? classe : "",
         "LOCAL_ENSAIO": localStorage.getItem('session_local') || "",
         "DATA_ENSAIO": new Date().toLocaleDateString('pt-BR'),
         "HOR√ÅRIO": horarioRegistro, // Hor√°rio de registro no padr√£o S√£o Paulo/America
         "REGISTRADO_POR": localStorage.getItem('current_user_name') || "Sistema",
         "USER_ID": localStorage.getItem('current_user_id') || "",
         "ANOTACOES": anotacoesFinal,
         "SYNC_STATUS": "ATUALIZADO" // Status de sincroniza√ß√£o em portugu√™s (online)
       };
       
       // üõ°Ô∏è MOBILE FIX: Valida√ß√£o final antes do envio - garantir que classe est√° presente para organistas
       if (isMobileDevice && isOrganista && !dadosModal["CLASSE_ORGANISTA"]) {
         console.error('üö® ERRO CR√çTICO MOBILE MODAL: Organista sem classe! Corrigindo...');
         dadosModal["CLASSE_ORGANISTA"] = classe || 'OFICIALIZADA';
         console.log('üì± MOBILE FIX: CLASSE_ORGANISTA corrigida para:', dadosModal["CLASSE_ORGANISTA"]);
       }
       
       // Valida√ß√£o adicional dos dados
      console.log('üîç Valida√ß√£o dos dados do modal (ONLINE):');
      console.log('üîç Nome:', nome, 'V√°lido:', !!nome);
      console.log('üîç Comum:', comum, 'V√°lido:', !!comum);
      console.log('üîç Cidade:', cidade, 'V√°lido:', !!cidade);
      console.log('üîç Cargo:', cargo, 'V√°lido:', !!cargo);
      console.log('üîç Cargo UP:', cargoUP);
      console.log('üîç isOrganista:', isOrganista);
      console.log('üîç isInstrutora:', isInstrutora);
      console.log('üîç isExaminadora:', isExaminadora);
      console.log('üîç isSecretariaMusica:', isSecretariaMusica);
      console.log('üîç cargosComClasseOficializada:', cargosComClasseOficializada);
      console.log('üîç Instrumento coletado:', instrumento);
      console.log('üîç Instrumento final:', dadosModal["INSTRUMENTO"]);
      console.log('üîç Naipe final:', dadosModal["NAIPE_INSTRUMENTO"]);
      console.log('üîç Classe coletada (raw):', classeRaw);
      console.log('üîç Classe final:', classe);
      console.log('üîç Classe ser√° enviada:', dadosModal["CLASSE_ORGANISTA"]);
      if (isMobileDevice) {
        console.log('üì± MOBILE DEBUG MODAL - Dados finais:', {
          cargo: dadosModal["CARGO"],
          classe: dadosModal["CLASSE_ORGANISTA"],
          isOrganista,
          userAgent: navigator.userAgent
        });
      }
       
       // üö® FILTRO DE SEGURAN√áA CR√çTICO: Valida√ß√£o para organistas
       const cargoUpper = cargo.toUpperCase();
       const isOrganistaFilter = cargoUpper === 'ORGANISTA';
       
       if (isOrganistaFilter) {
         // Verifica se h√° cargo real armazenado (pode ser examinadora, instrutora, etc.)
         const cargoEl = findCargoField();
         const cargoReal = cargoEl ? cargoEl.getAttribute('data-cargo-real') : null;
         
         if (cargoReal) {
           const cargoRealUpper = cargoReal.toUpperCase();
           const isCargoMasculino = (cargoRealUpper.includes('INSTRUTOR') && !cargoRealUpper.includes('INSTRUTORA')) ||
                                   cargoRealUpper.includes('SECRET√ÅRIO DO GEM') ||
                                   cargoRealUpper.includes('SECRETARIO DO GEM') ||
                                   (cargoRealUpper.includes('SECRET√ÅRIO') && cargoRealUpper.includes('M√öSICA') && !cargoRealUpper.includes('SECRET√ÅRIA'));
           
           if (isCargoMasculino) {
             console.log('üö® ERRO CR√çTICO BLOQUEADO: Tentativa de enviar organista com cargo masculino:', cargoReal);
             console.log('üö® ATEN√á√ÉO: Cadastro no SAM est√° desatualizado - contate o administrador');
             showToast('error', 'Erro de G√™nero', 'Organistas n√£o podem ter cargos masculinos. Cadastro desatualizado no SAM.', 8000);
             isModalProcessing = false;
             return;
           }
         }
         
         // Valida√ß√£o adicional: verifica se o cargo final n√£o √© masculino
         const cargoFinalUpper = cargo.toUpperCase();
         const isCargoFinalMasculino = (cargoFinalUpper.includes('INSTRUTOR') && !cargoFinalUpper.includes('INSTRUTORA')) ||
                                      cargoFinalUpper.includes('SECRET√ÅRIO DO GEM') ||
                                      cargoFinalUpper.includes('SECRETARIO DO GEM') ||
                                      (cargoFinalUpper.includes('SECRET√ÅRIO') && cargoFinalUpper.includes('M√öSICA') && !cargoFinalUpper.includes('SECRET√ÅRIA'));
         
         if (isCargoFinalMasculino) {
           console.log('üö® ERRO CR√çTICO BLOQUEADO: Cargo final √© masculino para organista:', cargo);
           console.log('üö® ATEN√á√ÉO: Cadastro no SAM est√° desatualizado - contate o administrador');
           showToast('error', 'Erro de G√™nero', 'Organistas n√£o podem ter cargos masculinos. Cadastro desatualizado no SAM.', 8000);
           isModalProcessing = false;
           return;
         }
       }
       
       // Verifica se todos os campos obrigat√≥rios est√£o preenchidos
       if (!nome || !comum || !cidade || !cargo) {
         throw new Error('Campos obrigat√≥rios n√£o preenchidos');
       }
       
       // Padroniza todos os dados em mai√∫scula
       const dadosModalPadronizados = padronizarDadosMaiuscula(dadosModal);
       
       console.log('üì§ Enviando dados do modal:', dadosModalPadronizados);
       console.log('üì§ Dados brutos coletados:', {
         comum, cidade, cargo, instrumento, classe, nome, isOrganista
       });
       
       // üö® CORRE√á√ÉO: Remover verifica√ß√£o de duplica√ß√£o que est√° causando problemas
       // O sistema j√° tem prote√ß√£o contra m√∫ltiplos cliques com isModalProcessing
       
       // Envia para Google Sheets usando a mesma fun√ß√£o do sistema principal
       // üéØ CORRE√á√ÉO: Usa sheetDestino determinado pela detec√ß√£o de entrada manual
       const requestBody = { 
         op: 'append', 
         sheet: sheetDestino, // Usa 'Anota√ß√µes' se for entrada manual + cargo musical, sen√£o 'Dados'
         data: dadosModalPadronizados 
       };
       
       console.log('üì§ Enviando para aba:', sheetDestino, isNomeManual && isCargoMusical ? '(entrada manual + cargo musical)' : '(cadastro normal)');
       
       console.log('üì§ Request body completo:', requestBody);
       
       // üöÄ CORRE√á√ÉO: Usa proxy local se dispon√≠vel, sen√£o usa URL direta
       const isLocalServer = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
       const apiUrl = isLocalServer 
         ? '/api/google-script'  // Proxy local
         : "https://script.google.com/macros/s/AKfycbxPtvi86jPy7y41neTpIPvn3hpycd3cMjbgjgifzLD6qRwrJVPlF9EDulaQp42nma-i/exec";
       
       console.log('üåê URL da API:', apiUrl);
       
       // üöÄ CORRE√á√ÉO: Implementa retry com backoff exponencial
      const response = await fetchWithRetry(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'text/plain;charset=utf-8'
        },
        body: JSON.stringify(requestBody)
      }, 3); // 3 tentativas
      
      console.log('üì± Mobile Debug - Response status:', response.status);
      console.log('üì± Mobile Debug - Response ok:', response.ok);
      console.log('üì± Mobile Debug - Response headers:', response.headers);
      
      // Tenta ler o conte√∫do da resposta para debug
      try {
        const responseText = await response.text();
        console.log('üì± Mobile Debug - Response text:', responseText);
      } catch (textError) {
        console.log('üì± Mobile Debug - Erro ao ler response text:', textError);
      }
      
      // Verifica se a resposta √© bem-sucedida (status 200-299 ou status espec√≠fico do Google Sheets)
      // Google Apps Script pode retornar status 200 mesmo com response.ok = false
      // No mobile, pode retornar status 0 para requisi√ß√µes CORS bem-sucedidas
      const isSuccess = response.ok || 
                       response.status === 200 || 
                       response.status === 201 || 
                       response.status === 0 ||
                       (response.status >= 200 && response.status < 300);
      
      if (isSuccess) {
        console.log('‚úÖ Google Sheets: Dados enviados com sucesso');
        
        // üö® CORRE√á√ÉO: Remover registro de envio que est√° causando problemas de duplica√ß√£o
        console.log('‚úÖ Envio bem-sucedido - sem registro de duplica√ß√£o');
        
        // üöÄ CORRE√á√ÉO: Enviar para Supabase tamb√©m ap√≥s envio bem-sucedido para Google Sheets
        if (supabaseLoaded && sb) {
          try {
            // Prepara payload no formato esperado pelo Supabase
            const payloadSupabase = {
              uuid: dadosModalPadronizados["UUID"],
              nome: dadosModalPadronizados["NOME COMPLETO"],
              comum: dadosModalPadronizados["COMUM"],
              cidade: dadosModalPadronizados["CIDADE"] || null,
              cargo: dadosModalPadronizados["CARGO"],
              instrumento: dadosModalPadronizados["INSTRUMENTO"] || null,
              naipe: dadosModalPadronizados["NAIPE_INSTRUMENTO"] || null,
              nivel: dadosModalPadronizados["CLASSE_ORGANISTA"] || null,
              local_ensaio: dadosModalPadronizados["LOCAL_ENSAIO"] || null,
              data_ensaio: new Date().toISOString().split('T')[0], // Formato YYYY-MM-DD
              data_ensaio_iso: new Date().toISOString(),
              registrado_por: dadosModalPadronizados["REGISTRADO_POR"] || "Sistema",
              user_id: dadosModalPadronizados["USER_ID"] || "",
              created_at: new Date().toISOString(),
              anotacoes: dadosModalPadronizados["ANOTACOES"] || ""
            };
            
            console.log('üì§ Enviando para Supabase:', payloadSupabase);
            const supabaseResult = await insertSupabase(payloadSupabase);
            if (supabaseResult) {
              console.log('‚úÖ Supabase: Dados enviados com sucesso');
            } else {
              console.warn('‚ö†Ô∏è Supabase: Retornou null (pode ser duplica√ß√£o ou erro)');
            }
          } catch (supabaseError) {
            console.error('‚ùå Erro no Supabase:', supabaseError);
            console.error('‚ùå Detalhes do erro Supabase:', {
              message: supabaseError.message,
              code: supabaseError.code,
              name: supabaseError.name
            });
            // N√£o mostrar erro ao usu√°rio aqui pois j√° foi enviado com sucesso para Google Sheets
          }
        } else {
          console.warn('‚ö†Ô∏è Supabase n√£o dispon√≠vel - pulando envio');
        }
        
        // Mostra mensagem de sucesso
        if (typeof window.showStatusModal === 'function') {
          window.showStatusModal('ENVIADO!', 'REGISTRO SALVO COM SUCESSO', 'success', () => {
            // üîß Verificar se h√° nova vers√£o dispon√≠vel ap√≥s cadastro bem-sucedido
            if (verificarNovaVersao()) {
              mostrarAlertaNovaVersao();
            } else {
              console.log('üîÑ Recarregando p√°gina ap√≥s envio bem-sucedido');
              window.location.reload();
            }
          });
          // Timeout de seguran√ßa adicional
          setTimeout(() => {
            // üîß Verificar se h√° nova vers√£o dispon√≠vel antes de recarregar
            if (verificarNovaVersao()) {
              mostrarAlertaNovaVersao();
            } else {
              console.log('‚è∞ Timeout de seguran√ßa - for√ßando recarregamento');
              if (typeof window.forceReload === 'function') {
                window.forceReload();
              } else {
                window.location.reload();
              }
            }
          }, 2000);
        } else {
          showToast('success', 'ENVIADO!', 'REGISTRO SALVO COM SUCESSO', 1000);
          
          // üîß Verificar se h√° nova vers√£o dispon√≠vel ap√≥s cadastro bem-sucedido
          setTimeout(() => {
            if (verificarNovaVersao()) {
              mostrarAlertaNovaVersao();
            } else {
              console.log('üîÑ Recarregando p√°gina ap√≥s toast');
              window.location.reload();
            }
          }, 1000);
        }
         
        // Limpa o formul√°rio com tratamento de erro
        try {
          const fields = ['gsComum', 'gsCidade', 'gsCargo', 'gsInstrumento', 'gsClasse', 'gsNome'];
          fields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field) {
              field.value = '';
            } else {
              console.warn(`‚ö†Ô∏è Campo ${fieldId} n√£o encontrado para limpeza`);
            }
          });
          
          // Reseta a exibi√ß√£o dos campos
          const instrumentoContainer = document.getElementById('instrumentoContainer');
          const classeContainer = document.getElementById('classeContainer');
          if (instrumentoContainer) instrumentoContainer.style.display = 'block';
          if (classeContainer) classeContainer.style.display = 'none';
          
        } catch (cleanupError) {
          console.warn('‚ö†Ô∏è Erro na limpeza do formul√°rio:', cleanupError);
        }
        
        // Fecha o modal com tratamento de erro
        try {
          const modalElement = document.getElementById('modalNovaComum');
          if (modalElement) {
            const modal = bootstrap.Modal.getOrCreateInstance(modalElement);
            modal.hide();
          }
        } catch (modalError) {
          console.warn('‚ö†Ô∏è Erro ao fechar modal:', modalError);
        }
       } else {
         // Se Google Sheets falhou, salva na fila local
         console.log('‚ö†Ô∏è Google Sheets falhou, salvando na fila local');
         pushQueue(dadosModalPadronizados);
         showFastAlert('warning', 'Salvo offline', 'Dados salvos na fila para envio posterior');
         
         // Fecha o modal
         const modalElement = document.getElementById('modalNovaComum');
         if (modalElement) {
           const modal = bootstrap.Modal.getOrCreateInstance(modalElement);
           modal.hide();
         }
       }
       
    } catch (error) {
      console.error('‚ùå Erro ao enviar dados do modal:', error);
      
      // Verifica se o erro √© relacionado √† limpeza do formul√°rio ou fechamento do modal
      // Se for, n√£o mostra erro para o usu√°rio pois o registro foi enviado com sucesso
      const isCleanupError = error.message && (
        error.message.includes('getElementById') ||
        error.message.includes('Modal') ||
        error.message.includes('bootstrap')
      );
      
      // üö® CORRE√á√ÉO: Se houver erro de rede ou envio falhar, salvar na fila offline
      const isNetworkError = error.message && (
        error.message.includes('Failed to fetch') ||
        error.message.includes('NetworkError') ||
        error.message.includes('Network request failed') ||
        error.name === 'TypeError' ||
        !navigator.onLine
      );
      
      if (isNetworkError && !isCleanupError) {
        console.log('üìµ Erro de rede detectado - salvando na fila offline');
        
        // Prepara dados para fila offline
        const dadosParaFilaOffline = {
          uuid: dadosModalPadronizados.UUID || dadosModalPadronizados.uuid || uuidv4(),
          nome: dadosModalPadronizados['NOME COMPLETO'] || dadosModalPadronizados.nome || nome,
          comum: dadosModalPadronizados.COMUM || dadosModalPadronizados.comum || comum,
          cidade: dadosModalPadronizados.CIDADE || dadosModalPadronizados.cidade || cidade,
          cargo: dadosModalPadronizados.CARGO || dadosModalPadronizados.cargo || cargo,
          instrumento: dadosModalPadronizados.INSTRUMENTO || dadosModalPadronizados.instrumento || instrumento,
          naipe: dadosModalPadronizados.NAIPE_INSTRUMENTO || dadosModalPadronizados.naipe || '',
          nivel: dadosModalPadronizados.CLASSE_ORGANISTA || dadosModalPadronizados.nivel || classe,
          local_ensaio: dadosModalPadronizados.LOCAL_ENSAIO || dadosModalPadronizados.local_ensaio || '',
          data_ensaio: dadosModalPadronizados.DATA_ENSAIO || dadosModalPadronizados.data_ensaio || '',
          registrado_por: dadosModalPadronizados.REGISTRADO_POR || dadosModalPadronizados.registrado_por || '',
          user_id: dadosModalPadronizados.USER_ID || dadosModalPadronizados.user_id || '',
          anotacoes: dadosModalPadronizados.ANOTACOES || dadosModalPadronizados.anotacoes || anotacoesFinal
        };
        
        // Salva na fila local
        pushQueue(dadosModalPadronizados);
        
        // üö® CORRE√á√ÉO: Se usu√°rio confirmou duplicata, marcar no item da fila
        if (window._duplicataConfirmadaPeloUsuario === true) {
          dadosParaFilaOffline.duplicataConfirmadaPeloUsuario = true;
          console.log('‚úÖ Flag de duplicata confirmada adicionada ao item da fila offline (erro de rede)');
        }
        
        // Salva na fila offline tamb√©m
        if (typeof addToOfflineQueue === 'function') {
          const recordId = addToOfflineQueue(dadosParaFilaOffline);
          console.log('üìã Registro adicionado √† fila offline com ID:', recordId);
        }
        
        showToast('warning', 'Salvo offline', 'Dados salvos na fila para envio posterior', 4000);
      } else if (!isCleanupError) {
        // Mostrar erro espec√≠fico apenas se n√£o for erro de limpeza
        if (typeof window.showStatusModal === 'function') {
          window.showStatusModal('ERRO NO ENVIO', 'Erro ao enviar dados para o Google Sheets', 'error');
        } else {
          showToast('error', 'Erro no Envio', 'Erro ao enviar dados para o Google Sheets', 3000);
        }
      } else {
        console.log('‚ÑπÔ∏è Erro de limpeza/UI ignorado - registro foi enviado com sucesso');
      }
      
      // Fechar modal em caso de erro (com tratamento)
      try {
        const modalElement = document.getElementById('modalNovaComum');
        if (modalElement) {
          const modal = bootstrap.Modal.getOrCreateInstance(modalElement);
          modal.hide();
        }
      } catch (modalError) {
        console.warn('‚ö†Ô∏è Erro ao fechar modal no catch:', modalError);
      }
     } finally {
       // Reabilita o bot√£o
       const btnSalvarGS = document.getElementById('btnSalvarGS');
       if (btnSalvarGS) {
         btnSalvarGS.disabled = false;
         btnSalvarGS.innerHTML = '<i class="fa-solid fa-paper-plane me-1"></i>Enviar';
       }
       
       // Reset do flag
       isModalProcessing = false;
       console.log('üîÑ Modal processamento finalizado - flag resetado');
     }
   }
   
   /* ===== FUN√á√ïES AUXILIARES ===== */
   
   // üöÄ FUN√á√ÉO: Fetch com retry e backoff exponencial
   async function fetchWithRetry(url, options, maxRetries = 3) {
     let lastError;
     
     for (let attempt = 1; attempt <= maxRetries; attempt++) {
       try {
         console.log(`üîÑ Tentativa ${attempt}/${maxRetries} para ${url}`);
         
         // üöÄ CORRE√á√ÉO: Adicionar timeout de 30 segundos para evitar falhas desnecess√°rias
         const controller = new AbortController();
         const timeoutId = setTimeout(() => controller.abort(), 30000);
         
         const response = await fetch(url, {
           ...options,
           signal: controller.signal
         });
         
         clearTimeout(timeoutId);
         
         // Se for 429 (Too Many Requests), aguarda antes de tentar novamente
         if (response.status === 429 && attempt < maxRetries) {
           const waitTime = Math.pow(2, attempt) * 1000; // Backoff exponencial: 2s, 4s, 8s
           console.log(`‚è≥ Rate limit atingido. Aguardando ${waitTime/1000}s antes da pr√≥xima tentativa...`);
           await new Promise(resolve => setTimeout(resolve, waitTime));
           continue;
         }
         
         // Se for sucesso ou erro n√£o relacionado a rate limiting, retorna
         return response;
         
       } catch (error) {
         lastError = error;
         console.error(`‚ùå Tentativa ${attempt} falhou:`, error.message);
         
         // Se n√£o √© a √∫ltima tentativa, aguarda antes de tentar novamente
         if (attempt < maxRetries) {
           const waitTime = Math.pow(2, attempt) * 1000; // Backoff exponencial
           console.log(`‚è≥ Aguardando ${waitTime/1000}s antes da pr√≥xima tentativa...`);
           await new Promise(resolve => setTimeout(resolve, waitTime));
         }
       }
     }
     
     // Se todas as tentativas falharam, lan√ßa o √∫ltimo erro
     throw lastError;
   }
   
   /* ===== ENVIO (Sheets ‚Üí Supabase) ===== */
   // üöÄ FUN√á√ÉO OTIMIZADA: Envio ultra-r√°pido para Google Sheets
   async function enviarParaSheets(payload){
     // üö® VERIFICA√á√ÉO: Se usu√°rio j√° confirmou duplicata, n√£o bloquear novamente
     const duplicataJaConfirmada = window._duplicataConfirmadaPeloUsuario === true;
     const platformType = isMobile ? 'MOBILE' : 'DESKTOP';
     
     if (duplicataJaConfirmada) {
       console.log(`‚úÖ ${platformType}: Usu√°rio j√° confirmou duplicata - permitindo envio para Google Sheets`);
       console.log(`‚úÖ ${platformType}: Flag antes de limpar:`, window._duplicataConfirmadaPeloUsuario);
       // Limpar flag ap√≥s usar
       window._duplicataConfirmadaPeloUsuario = false;
       console.log(`‚úÖ ${platformType}: Flag limpa ap√≥s uso`);
     } else {
       console.log(`üîç ${platformType}: Verificando duplicatas no enviarParaSheets (flag n√£o est√° ativa)`);
       // üö® VERIFICA√á√ÉO CR√çTICA DE DUPLICATAS: Verificar antes de enviar para Google Sheets
       const nomeVerificacao = payload.nome || payload.NOME || payload['NOME COMPLETO'] || '';
       const comumVerificacao = payload.comum || payload.COMUM || '';
       const cargoVerificacao = payload.cargo || payload.CARGO || '';
       
       if (supabaseLoaded && sb && nomeVerificacao && comumVerificacao && cargoVerificacao) {
       try {
         const dataAtual = new Date();
         const dataISO = dataAtual.toISOString().split('T')[0];
         
         // Buscar registros duplicados (mesmo nome + comum + cargo no mesmo dia)
         const { data: duplicatas, error: dupError } = await sb
           .from(TABLE_PRESENCAS)
           .select('nome_completo, comum, cargo, created_at, uuid')
           .ilike('nome_completo', `%${nomeVerificacao.trim()}%`)
           .ilike('comum', `%${comumVerificacao.trim()}%`)
           .gte('created_at', `${dataISO}T00:00:00.000Z`)
           .lt('created_at', `${dataISO}T23:59:59.999Z`)
           .limit(10);
         
         if (!dupError && duplicatas && duplicatas.length > 0) {
           // Verificar se h√° duplicata exata (mesmo nome, comum e cargo)
           const duplicataExata = duplicatas.find(d => {
             const nomeMatch = norm(d.nome_completo || '').toUpperCase().trim() === norm(nomeVerificacao).toUpperCase().trim();
             const comumMatch = compareComum(d.comum || '', comumVerificacao).match;
             const cargoMatch = norm(d.cargo || '').toUpperCase().trim() === norm(cargoVerificacao).toUpperCase().trim();
             return nomeMatch && comumMatch && cargoMatch;
           });
           
           if (duplicataExata) {
             console.error('üö®üö®üö® DUPLICATA DETECTADA NO GOOGLE SHEETS - BLOQUEANDO ENVIO üö®üö®üö®', {
               nome: nomeVerificacao,
               comum: comumVerificacao,
               cargo: cargoVerificacao,
               uuidExistente: duplicataExata.uuid,
               dataExistente: duplicataExata.created_at
             });
             
             // üö® BLOQUEIO COMPLETO: Retornar erro para impedir envio
             throw new Error(`DUPLICATA_BLOQUEADA: Registro duplicado detectado. ${nomeVerificacao} de ${comumVerificacao} j√° foi cadastrado hoje.`);
           }
         }
       } catch (error) {
         // Se o erro for de duplicata bloqueada, propagar o erro
         if (error.message && error.message.includes('DUPLICATA_BLOQUEADA')) {
           console.error('üö®üö®üö® BLOQUEIO DEFINITIVO DE DUPLICATA NO enviarParaSheets üö®üö®üö®');
           throw error;
         }
         console.warn('‚ö†Ô∏è Erro ao verificar duplicatas no Supabase (enviarParaSheets):', error);
         // Continua apenas se n√£o for erro de duplicata
       }
       }
     }
     
     // üöÄ CORRE√á√ÉO: Usa proxy local se dispon√≠vel, sen√£o usa URL direta
     const isLocalServer = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
     const url = isLocalServer 
       ? '/api/google-script'  // Proxy local
       : "https://script.google.com/macros/s/AKfycbxPtvi86jPy7y41neTpIPvn3hpycd3cMjbgjgifzLD6qRwrJVPlF9EDulaQp42nma-i/exec";
     
     // Gerar hor√°rio de registro no padr√£o S√£o Paulo/America
     const agora = new Date();
     const horarioRegistro = agora.toLocaleString('pt-BR', {
       timeZone: 'America/Sao_Paulo',
       year: 'numeric',
       month: '2-digit',
       day: '2-digit',
       hour: '2-digit',
       minute: '2-digit',
       second: '2-digit',
       hour12: false
     });
     
     // üöÄ OTIMIZA√á√ÉO: Constru√ß√£o direta do objeto sem logs
    const sheetRow = {
       "UUID": payload.uuid,
       "NOME COMPLETO": payload.nome,
       "COMUM": payload.comum,
       "CIDADE": payload.local || "",
       "CARGO": payload.cargo,
       "INSTRUMENTO": payload.instrumento || "",
       "NAIPE_INSTRUMENTO": payload.naipe || "",
       "CLASSE_ORGANISTA": payload.nivel || "",
       "LOCAL_ENSAIO": payload.local_ensaio || "",
       "DATA_ENSAIO": payload.data_ensaio || "",
       "HOR√ÅRIO": horarioRegistro, // Hor√°rio de registro no padr√£o S√£o Paulo/America
       "REGISTRADO_POR": payload.registrado_por || localStorage.getItem('current_user_name') || localStorage.getItem('session_user') || "Sistema",
       "USER_ID": payload.user_id || "",
       "ANOTACOES": payload.anotacoes || "",
       "SYNC_STATUS": "ATUALIZADO" // Status de sincroniza√ß√£o em portugu√™s
     };
     
     try {
      // ‚úÖ Decidir a aba de destino com base nas anota√ß√µes
      let sheetDestino = 'Dados';
      const anot = (payload.anotacoes || '').toString().toUpperCase();
      if (anot.includes('SAM DESATUALIZADO')) {
        sheetDestino = 'Anota√ß√µes';
      }
       // üöÄ AJUSTE: Timeout mais conservador para 6 segundos
       const controller = new AbortController();
       const timeoutId = setTimeout(() => controller.abort(), 15000); // üö® CORRE√á√ÉO: Timeout aumentado para 15 segundos (era 6s - muito curto para requisi√ß√µes grandes)
       
      // Preparar body da requisi√ß√£o
      const requestBody = { op: 'append', sheet: sheetDestino, data: sheetRow };
      const requestBodyString = JSON.stringify(requestBody);
      
      console.log('üì§ Enviando para Google Sheets:', {
        url: url,
        sheet: sheetDestino,
        uuid: sheetRow.UUID,
        nome: sheetRow['NOME COMPLETO'],
        bodySize: requestBodyString.length
      });
      console.log('üìã Body completo:', requestBodyString);
      
      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'text/plain;charset=utf-8'
        },
        body: requestBodyString,
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      console.log('üì• Resposta do Google Sheets:', {
        status: response.status,
        statusText: response.statusText,
        ok: response.ok,
        type: response.type,
        headers: Object.fromEntries(response.headers.entries())
      });
      
      // Tentar ler a resposta para verificar se foi bem-sucedida
      let responseText = '';
      let responseJson = null;
      try {
        responseText = await response.text();
        console.log('üìÑ Conte√∫do da resposta (texto):', responseText);
        
        // Tentar parsear como JSON
        if (responseText) {
          try {
            responseJson = JSON.parse(responseText);
            console.log('üìÑ Conte√∫do da resposta (JSON):', responseJson);
            
            // Verificar se a resposta JSON indica sucesso
            if (responseJson && responseJson.ok === true) {
              console.log('‚úÖ Google Sheets: Resposta JSON confirma sucesso');
              return { ok: true, method: 'json-success', response: responseJson };
            } else if (responseJson && responseJson.ok === false) {
              console.error('‚ùå Google Sheets: Resposta JSON indica falha:', responseJson);
              throw new Error(`Erro na resposta JSON: ${JSON.stringify(responseJson)}`);
            }
          } catch (jsonError) {
            console.warn('‚ö†Ô∏è Resposta n√£o √© JSON v√°lido:', jsonError);
          }
        }
      } catch (textError) {
        console.warn('‚ö†Ô∏è N√£o foi poss√≠vel ler o conte√∫do da resposta:', textError);
      }
      
      // Se a resposta √© opaca (no-cors), considera sucesso (mas adiciona log)
      if (response.type === 'opaque') {
        console.log('‚ö†Ô∏è Resposta opaca (no-cors) - assumindo sucesso');
        return { ok: true, method: 'no-cors' };
      }
      
      // Verificar se a resposta indica sucesso
      if (!response.ok) {
        console.error('‚ùå Resposta n√£o OK:', response.status, response.statusText);
        console.error('‚ùå Conte√∫do da resposta:', responseText);
        throw new Error(`HTTP ${response.status}: ${response.statusText} - ${responseText}`);
      }
      
      // Verificar se a resposta cont√©m erro
      if (responseText && (responseText.toLowerCase().includes('error') || responseText.toLowerCase().includes('erro'))) {
        console.error('‚ùå Resposta cont√©m erro:', responseText);
        throw new Error(`Erro na resposta: ${responseText}`);
      }
      
      // Verificar se a resposta cont√©m confirma√ß√£o de inser√ß√£o
      if (responseText && (responseText.includes('inserted') || responseText.includes('ok'))) {
        console.log('‚úÖ Google Sheets: Resposta confirma inser√ß√£o');
        return { ok: true, method: 'success', response: responseText };
      }
      
      console.log('‚úÖ Google Sheets: Envio confirmado (status OK)');
      // üöÄ OTIMIZA√á√ÉO: N√£o aguarda parsing JSON se n√£o for necess√°rio
      return { ok: true, method: 'success', response: responseText };
       
     } catch (error) {
       // Se for erro de conectividade, salva na fila local
       if (error.name === 'AbortError' || error.message.includes('Failed to fetch')) {
         salvarNaFilaLocal(payload);
         throw new Error('Erro de conectividade - dados salvos na fila local');
       }
       
       throw error;
     }
   }
   
   // Fun√ß√£o para atualizar indicador visual da fila Supabase
   function updateSupabaseQueueIndicator(count) {
     // Atualiza o contador geral da fila (inclui ambas as filas)
     atualizarContadorFila();
   }
   
   // Fun√ß√£o para adicionar payload √† fila Supabase (processamento em background)
   function adicionarAFilaSupabase(payload) {
     try {
       const filaSupabase = JSON.parse(localStorage.getItem('fila_supabase') || '[]');
       
       // üõ°Ô∏è VERIFICA√á√ÉO DE DUPLICA√á√ÉO: Verifica se j√° existe um item com o mesmo UUID
       const uuidExistente = filaSupabase.find(item => item.uuid === payload.uuid);
       if (uuidExistente) {
         console.log('‚ö†Ô∏è UUID j√° existe na fila Supabase, ignorando duplica√ß√£o:', payload.uuid);
         return;
       }
       
       // üõ°Ô∏è VERIFICA√á√ÉO DE DUPLICA√á√ÉO: Verifica se j√° existe um item com os mesmos dados essenciais
       const dadosDuplicados = filaSupabase.find(item => 
         item.nome === payload.nome && 
         item.comum === payload.comum && 
         item.cargo === payload.cargo &&
         Math.abs(item.timestamp - Date.now()) < 30000 // 30 segundos
       );
       if (dadosDuplicados) {
         console.log('‚ö†Ô∏è Dados duplicados detectados na fila Supabase, ignorando:', payload.nome);
         return;
       }
       
       filaSupabase.push({
         ...payload,
         timestamp: Date.now(),
         tentativas: 0,
         status: 'pending' // Status para controle
       });
       localStorage.setItem('fila_supabase', JSON.stringify(filaSupabase));
       
       // Atualiza indicador visual
       updateSupabaseQueueIndicator(filaSupabase.length);
       
       // Inicia processamento em background se n√£o estiver rodando
       if (!window.supabaseProcessorRunning) {
         processarFilaSupabase();
       }
     } catch (error) {
       console.warn('‚ö†Ô∏è Erro ao adicionar √† fila Supabase:', error);
     }
   }
   
   // Processador em background para Supabase
   async function processarFilaSupabase() {
     if (window.supabaseProcessorRunning) {
       console.log('üîÑ Processador Supabase j√° est√° rodando, aguardando...');
       return;
     }
     
     window.supabaseProcessorRunning = true;
     console.log('üöÄ Iniciando processador Supabase...');
     
     try {
       let filaSupabase = JSON.parse(localStorage.getItem('fila_supabase') || '[]');
       
       // üõ°Ô∏è LIMPEZA CR√çTICA: Remove itens com UUID inv√°lido
       const filaLimpa = filaSupabase.filter(item => {
         if (!item.uuid || !isValidUUID(item.uuid)) {
           console.warn('‚ö†Ô∏è Item com UUID inv√°lido removido da fila:', item.uuid);
           return false;
         }
         return true;
       });
       
       // Atualiza a fila se houver itens removidos
       if (filaLimpa.length !== filaSupabase.length) {
         console.log(`üßπ ${filaSupabase.length - filaLimpa.length} item(s) com UUID inv√°lido removido(s) da fila`);
         localStorage.setItem('fila_supabase', JSON.stringify(filaLimpa));
         filaSupabase = filaLimpa;
       }
       
       if (filaSupabase.length === 0) {
         console.log('üì≠ Fila Supabase vazia, nada para processar');
         window.supabaseProcessorRunning = false;
         return;
       }
       
       console.log(`üîÑ Processando fila Supabase: ${filaSupabase.length} item(s)`);
       console.log('üîç DEBUG - Itens na fila Supabase:', filaSupabase.map((item, index) => ({
         index: index + 1,
         uuid: item.uuid,
         nome: item.nome,
         status: item.status,
         tentativas: item.tentativas || 0
       })));
       
       // Verifica se Supabase est√° dispon√≠vel
       if (!supabaseLoaded || !sb) {
         console.log('‚ö†Ô∏è Supabase n√£o dispon√≠vel, tentando inicializar...');
         await initSupabase();
         
         if (!supabaseLoaded || !sb) {
           console.log('‚ùå Supabase n√£o p√¥de ser inicializado, mantendo fila');
           window.supabaseProcessorRunning = false;
           return;
         }
       }
       
       // Testa conectividade antes de processar
       const conectividadeOK = await checkSupabaseConnection();
       if (!conectividadeOK) {
         console.log('‚ö†Ô∏è Conectividade n√£o est√°vel, mantendo itens na fila Supabase');
         window.supabaseProcessorRunning = false;
         return;
       }
       
       const itensProcessados = [];
       const itensComErro = [];
       
       for (let i = 0; i < filaSupabase.length; i++) {
         const item = filaSupabase[i];
         
         try {
           // üõ°Ô∏è VERIFICA√á√ÉO FINAL: Verifica se o item j√° foi processado com sucesso
           if (item.status === 'success') {
             console.log(`‚úÖ Item ${i + 1} j√° foi processado com sucesso, removendo da fila`);
             itensProcessados.push(item);
             continue;
           }
           
           console.log(`üì§ Processando item ${i + 1}/${filaSupabase.length}: ${item.nome || item.uuid}`);
           await insertSupabase(item);
           
           // üõ°Ô∏è MARCA COMO SUCESSO: Atualiza status para evitar reprocessamento
           item.status = 'success';
           itensProcessados.push(item);
           console.log(`‚úÖ Supabase (Background): Item ${i + 1} processado com sucesso`);
           
           // üö® CORRE√á√ÉO: Pausa aumentada para 200ms (era 50ms - muito curto quebrava a l√≥gica)
           await new Promise(resolve => setTimeout(resolve, 200));
           
         } catch (error) {
           console.warn(`‚ö†Ô∏è Supabase (Background): Erro no item ${i + 1}:`, error.message);
           
           // üõ°Ô∏è TRATAMENTO ESPEC√çFICO PARA DUPLICA√á√ÉO: Se for erro de chave duplicada, remove da fila
           if (error.code === '23505' || error.message.includes('duplicate key') || error.message.includes('already exists')) {
             console.log(`üóëÔ∏è Item ${i + 1}: Chave duplicada detectada, removendo da fila (j√° existe no banco)`);
             item.status = 'duplicate';
             itensProcessados.push(item);
             continue;
           }
           
           // Incrementa tentativas
           item.tentativas = (item.tentativas || 0) + 1;
           
           // Se j√° tentou 3 vezes, remove da fila
           if (item.tentativas >= 3) {
             console.log(`üóëÔ∏è Supabase (Background): Item ${i + 1} removido ap√≥s 3 tentativas`);
             item.status = 'failed';
             itensProcessados.push(item);
           } else {
             itensComErro.push(item);
           }
         }
       }
       
       // Atualiza fila removendo itens processados
       localStorage.setItem('fila_supabase', JSON.stringify(itensComErro));
       
       console.log(`‚úÖ Fila Supabase processada: ${itensProcessados.length} sucessos, ${itensComErro.length} pendentes`);
       
       // Atualiza indicador visual da fila
       updateSupabaseQueueIndicator(itensComErro.length);
       
       // Se ainda h√° itens pendentes, agenda pr√≥xima execu√ß√£o
       if (itensComErro.length > 0) {
         console.log(`‚è∞ Agendando pr√≥xima tentativa em 5 segundos para ${itensComErro.length} itens pendentes`);
         setTimeout(() => {
           window.supabaseProcessorRunning = false;
           processarFilaSupabase();
         }, 5000); // Tenta novamente em 5 segundos
       } else {
         console.log('üéâ Todos os itens da fila Supabase foram processados com sucesso!');
         window.supabaseProcessorRunning = false;
       }
       
     } catch (error) {
       console.error('‚ùå Erro no processador Supabase:', error);
       window.supabaseProcessorRunning = false;
     }
   }
   
   // Fun√ß√£o para salvar dados na fila local quando h√° erro de conectividade
   function salvarNaFilaLocal(payload) {
     try {
       // Busca fila existente
       let fila = JSON.parse(localStorage.getItem('fila_envio') || '[]');
       
       // üõ°Ô∏è VERIFICA√á√ÉO CR√çTICA: Prevenir duplica√ß√µes na fila local
       const existingRecord = fila.find(item => {
         const sameName = (item.nome || item.NOME) === (payload.nome || payload.NOME);
         const sameComum = (item.comum || item.COMUM) === (payload.comum || payload.COMUM);
         const sameCargo = (item.cargo || item.CARGO) === (payload.cargo || payload.CARGO);
         const sameTimestamp = Math.abs(new Date(item.timestamp).getTime() - Date.now()) < 5000; // 5 segundos
         
         return sameName && sameComum && sameCargo && sameTimestamp;
       });
       
       if (existingRecord) {
         console.warn('‚ö†Ô∏è DUPLICA√á√ÉO PREVENIDA na fila local:', {
           nome: payload.nome || payload.NOME,
           comum: payload.comum || payload.COMUM,
           cargo: payload.cargo || payload.CARGO
         });
         return; // N√£o adiciona duplicata
       }
       
       // üõ°Ô∏è VERIFICA√á√ÉO ADICIONAL: UUID nos dados
       let dataUuid = payload.uuid || payload.UUID;
       if (dataUuid) {
         const existingByUuid = fila.find(item => 
           (item.uuid || item.UUID) === dataUuid
         );
         
         if (existingByUuid) {
           console.warn('‚ö†Ô∏è DUPLICA√á√ÉO PREVENIDA por UUID na fila local:', dataUuid);
           return; // N√£o adiciona duplicata
         }
       } else {
         // Gera UUID se n√£o existir
         dataUuid = uuidv4();
         payload.uuid = dataUuid;
       }
       
       // Adiciona novo item √† fila
       fila.push({
         ...payload,
         timestamp: new Date().toISOString(),
         tentativas: 0
       });
       
       // Salva fila atualizada
       localStorage.setItem('fila_envio', JSON.stringify(fila));
       
       console.log('üíæ Dados salvos na fila local:', { 
         totalItens: fila.length, 
         ultimoItem: payload.nome 
       });
       
       // Atualiza contador na interface
       atualizarContadorFila();
       
       // üõ°Ô∏è CORRE√á√ÉO: N√£o adicionar ao Supabase aqui para evitar duplica√ß√£o
       // O processamento da fila local j√° cuida do Supabase
       
       // Tenta processar imediatamente se estiver online
       setTimeout(async () => {
         try {
           const isOnline = await checkSupabaseConnection();
           if (isOnline) {
             console.log('üîÑ Item adicionado √† fila - tentando processamento imediato...');
             await processarFilaLocal();
           }
         } catch (error) {
           console.log('‚ö†Ô∏è Erro no processamento imediato:', error.message);
         }
       }, 1000);
       
     } catch (error) {
       console.error('‚ùå Erro ao salvar na fila local:', error);
     }
   }
   
   // Fun√ß√£o para atualizar contador da fila na interface
   function atualizarContadorFila() {
     try {
       const filaLocal = JSON.parse(localStorage.getItem('fila_envio') || '[]');
       const filaSupabase = JSON.parse(localStorage.getItem('fila_supabase') || '[]');
       const totalFila = filaLocal.length + filaSupabase.length;
       
       const contador = document.querySelector('.fila-contador');
       const syncBtn = document.getElementById('syncBtn');
       
       if (contador) {
         if (totalFila > 0) {
           contador.textContent = `${totalFila} na fila`;
           contador.style.display = 'block';
         } else {
           contador.style.display = 'none';
         }
       }
       
       // Mostra/oculta bot√µes de sincroniza√ß√£o
       if (syncBtn) {
         if (totalFila > 0) {
           syncBtn.style.display = 'inline-block';
           syncBtn.title = `Sincronizar ${totalFila} registro(s) pendente(s)`;
         } else {
           syncBtn.style.display = 'none';
         }
       }
       
       const forceBtn = document.getElementById('forceBtn');
       if (forceBtn) {
         if (totalFila > 0) {
           forceBtn.style.display = 'inline-block';
           forceBtn.title = `For√ßar processamento de ${totalFila} registro(s)`;
         } else {
           forceBtn.style.display = 'none';
         }
       }
     } catch (error) {
       console.error('‚ùå Erro ao atualizar contador da fila:', error);
     }
   }
   
   // Fun√ß√£o para testar conectividade com Google Sheets
   async function testarConectividadeGoogleSheets() {
     try {
       console.log('üîç Testando conectividade com Google Sheets...');
       
       const url = "https://script.google.com/macros/s/AKfycbxPtvi86jPy7y41neTpIPvn3hpycd3cMjbgjgifzLD6qRwrJVPlF9EDulaQp42nma-i/exec";
       
       // Teste simples com no-cors
       const response = await fetch(url, {
         method: 'POST',
         mode: 'no-cors',
         body: JSON.stringify({ op: 'test' })
       });
       
       console.log('‚úÖ Conectividade com Google Sheets: OK');
       return true;
       
     } catch (error) {
       console.log('‚ùå Conectividade com Google Sheets: FALHOU', error.message);
       return false;
     }
   }
   
   // Fun√ß√£o para processar fila local quando conex√£o voltar
   async function processarFilaLocal() {
     try {
       const fila = JSON.parse(localStorage.getItem('fila_envio') || '[]');
       
       if (fila.length === 0) {
         console.log('üì≠ Fila vazia, nada para processar');
         return;
       }
       
       // Testa conectividade antes de processar
       const conectividadeOK = await checkSupabaseConnection();
       
       if (!conectividadeOK) {
         console.log('‚ö†Ô∏è Conectividade n√£o est√°vel, mantendo itens na fila');
         return;
       }
       
       console.log(`üîÑ Processando fila local: ${fila.length} item(s)`);
       console.log('üîç DEBUG - Itens na fila local:', fila.map((item, index) => ({
         index: index + 1,
         uuid: item.uuid,
         nome: item.nome,
         status: item.status,
         tentativas: item.tentativas || 0
       })));
       
       const itensProcessados = [];
       const itensComErro = [];
       
       for (let i = 0; i < fila.length; i++) {
         const item = fila[i];
         
         try {
           // üõ°Ô∏è VERIFICA√á√ÉO DE DUPLICA√á√ÉO: Verifica se j√° foi processado com sucesso
           if (item.status === 'success') {
             console.log(`‚úÖ Item ${i + 1} j√° foi processado com sucesso, removendo da fila`);
             itensProcessados.push(item);
             continue;
           }
           
           console.log(`üì§ Processando item ${i + 1}/${fila.length}: ${item.nome}`);
           
           // Tenta enviar para Google Sheets
           let sheetsSuccess = false;
           try {
             console.log(`üîÑ Item ${i + 1}: Tentando enviar para Google Sheets...`);
             console.log(`üìã Dados do item:`, {
               uuid: item.uuid,
               nome: item.nome,
               comum: item.comum,
               cargo: item.cargo
             });
             
             const sheetsResult = await enviarParaSheets(item);
             
             console.log(`üì• Resultado do envio:`, sheetsResult);
             
             // Verifica se o retorno indica sucesso
             if (sheetsResult && (sheetsResult.ok === true || sheetsResult === true)) {
               sheetsSuccess = true;
               console.log(`‚úÖ Item ${i + 1}: Google Sheets OK - Envio confirmado`);
             } else {
               console.error(`‚ùå Item ${i + 1}: Envio para Google Sheets retornou false ou undefined`);
               throw new Error('Envio para Google Sheets retornou false ou undefined');
             }
           } catch (sheetsError) {
             console.error(`‚ùå Item ${i + 1}: Erro ao enviar para Google Sheets:`, sheetsError.message);
             console.error(`‚ùå Stack trace:`, sheetsError.stack);
             throw sheetsError; // Lan√ßa erro para ser tratado no catch externo
           }
           
           // S√≥ marca como sucesso se Google Sheets foi bem-sucedido
           if (sheetsSuccess) {
             // Tenta enviar para Supabase
             if (supabaseLoaded && sb) {
               try {
                 await insertSupabase(item);
                 console.log(`‚úÖ Item ${i + 1}: Supabase OK`);
               } catch (e) {
                 // üõ°Ô∏è TRATAMENTO ESPEC√çFICO PARA DUPLICA√á√ÉO: Se for erro de chave duplicada, considera sucesso
                 if (e.code === '23505' || e.message.includes('duplicate key') || e.message.includes('already exists')) {
                   console.log(`‚úÖ Item ${i + 1}: Registro j√° existe no Supabase (duplica√ß√£o evitada)`);
                 } else {
                   console.warn(`‚ö†Ô∏è Item ${i + 1}: Erro no Supabase:`, e.message);
                   // N√£o lan√ßa erro aqui - Google Sheets j√° foi enviado com sucesso
                 }
               }
             }
             
             // üõ°Ô∏è MARCA COMO SUCESSO: Atualiza status para evitar reprocessamento
             item.status = 'success';
             itensProcessados.push(item);
           } else {
             throw new Error('Google Sheets n√£o retornou sucesso');
           }
           
         } catch (error) {
           console.error(`‚ùå Item ${i + 1}: Erro:`, error.message);
           
           // Incrementa tentativas
           item.tentativas = (item.tentativas || 0) + 1;
           
           // Se j√° tentou 3 vezes, remove da fila
           if (item.tentativas >= 3) {
             console.log(`üóëÔ∏è Item ${i + 1}: Removido ap√≥s 3 tentativas`);
             item.status = 'failed';
             itensProcessados.push(item);
           } else {
             itensComErro.push(item);
           }
         }
       }
       
       // Atualiza fila removendo itens processados
       localStorage.setItem('fila_envio', JSON.stringify(itensComErro));
       
       console.log(`‚úÖ Fila processada: ${itensProcessados.length} enviados, ${itensComErro.length} com erro`);
       
       // Atualiza contador
       atualizarContadorFila();
       
       if (itensProcessados.length > 0) {
         showToast('success', 'Fila processada', `${itensProcessados.length} registro(s) enviado(s) com sucesso!`, 3000);
       }
       
       // Se ainda h√° itens com erro, agenda nova tentativa
       if (itensComErro.length > 0) {
         console.log(`‚è∞ Agendando nova tentativa em 5 segundos para ${itensComErro.length} itens com erro`);
         setTimeout(async () => {
           console.log('üîÑ Tentativa autom√°tica de reprocessamento...');
           await processarFilaLocal();
         }, 5000);
       }
       
     } catch (error) {
       console.error('‚ùå Erro ao processar fila local:', error);
     }
   }
   
  async function insertSupabase(payload){
    // üö® CORRE√á√ÉO CR√çTICA: Valida√ß√£o mais robusta e logs detalhados
    if (!supabaseLoaded) {
      console.error('‚ùå Supabase n√£o carregado (supabaseLoaded = false)');
      throw new Error('Supabase n√£o est√° carregado');
    }
    
    if (!sb) {
      console.error('‚ùå Cliente Supabase n√£o dispon√≠vel (sb = null)');
      throw new Error('Cliente Supabase n√£o est√° dispon√≠vel');
    }
    
    if (!sb.from || typeof sb.from !== 'function') {
      console.error('‚ùå Cliente Supabase n√£o tem m√©todo from');
      throw new Error('Cliente Supabase n√£o tem m√©todo from');
    }
     
     console.log('üì§ DEBUG - Payload original para Supabase:', payload);
     
     // üõ°Ô∏è VALIDA√á√ÉO CR√çTICA: Verificar se o payload tem dados v√°lidos
     if (!payload || typeof payload !== 'object') {
       console.error('‚ùå Payload inv√°lido para Supabase:', payload);
       return null;
     }
     
     // Verificar se tem pelo menos nome e cargo (campos essenciais)
     const nome = payload.nome || payload.nome_completo || payload.NOME || payload['NOME COMPLETO'];
     const cargo = payload.cargo || payload.CARGO;
     
     if (!nome || !cargo || nome.trim() === '' || cargo.trim() === '') {
       console.error('‚ùå Payload incompleto para Supabase - faltam dados essenciais:', {
         nome: nome,
         cargo: cargo,
         payload: payload
       });
       return null;
     }
     
     // üõ°Ô∏è VALIDA√á√ÉO CR√çTICA: Verifica se o UUID √© v√°lido ANTES de tudo
     if (!payload.uuid || !isValidUUID(payload.uuid)) {
       console.error('‚ùå UUID inv√°lido detectado no payload:', payload.uuid);
       console.error('‚ùå Tipo do UUID:', typeof payload.uuid);
       console.error('‚ùå Payload completo:', payload);
       
       // Gera um novo UUID v√°lido
       payload.uuid = uuidv4();
       console.log('‚úÖ Novo UUID gerado:', payload.uuid);
       console.log('‚úÖ UUID √© v√°lido?', isValidUUID(payload.uuid));
     }
     
     // üõ°Ô∏è VALIDA√á√ÉO CR√çTICA ADICIONAL: Garantir que campos obrigat√≥rios est√£o preenchidos
     const nomeParaValidacao = payload.nome || payload.nome_completo || payload.NOME || payload['NOME COMPLETO'];
     const cargoParaValidacao = payload.cargo || payload.CARGO;
     
     if (!nomeParaValidacao || nomeParaValidacao.trim() === '') {
       console.error('‚ùå ERRO CR√çTICO: Nome est√° vazio no payload para Supabase');
       throw new Error('Nome √© obrigat√≥rio');
     }
     
     if (!cargoParaValidacao || cargoParaValidacao.trim() === '') {
       console.error('‚ùå ERRO CR√çTICO: Cargo est√° vazio no payload para Supabase');
       throw new Error('Cargo √© obrigat√≥rio');
     }
     
       // üõ°Ô∏è BLOQUEIO DEFINITIVO: Verificar se j√° foi enviado para Supabase (SEM TEMPO)
     const uuid = payload.uuid;
     if (uuid) {
       const sentRecords = safeGetItem('sent_records', {});
       const supabaseKey = `sb_${uuid}`;
       
       // Verifica√ß√£o DEFINITIVA - SEM TEMPO
       if (sentRecords[supabaseKey]) {
         console.warn('‚ö†Ô∏è DUPLICA√á√ÉO BLOQUEADA DEFINITIVAMENTE (Supabase): Registro j√° foi enviado:', uuid);
         // Retorna sucesso para evitar nova tentativa
         return { success: true, duplicate: true };
       }
     }
     
     // üöÄ APLICAR REGRA DE G√äNERO: Padronizar "oficializado(a)" para "oficializada"
     const dadosComRegrasGenero = aplicarRegrasGenero(payload);
     console.log('üöÄ Regras de g√™nero aplicadas para Supabase:', dadosComRegrasGenero);
     
     // Padroniza os dados antes de inserir no Supabase
     const payloadPadronizado = padronizarDadosMaiuscula(dadosComRegrasGenero);
     
     // üö® VERIFICA√á√ÉO: Se usu√°rio j√° confirmou duplicata, n√£o bloquear novamente
     const duplicataJaConfirmada = window._duplicataConfirmadaPeloUsuario === true;
     const platformType = isMobile ? 'MOBILE' : 'DESKTOP';
     
     if (duplicataJaConfirmada) {
       console.log(`‚úÖ ${platformType}: Usu√°rio j√° confirmou duplicata - permitindo inser√ß√£o no Supabase`);
       console.log(`‚úÖ ${platformType}: Flag antes de limpar:`, window._duplicataConfirmadaPeloUsuario);
       // Limpar flag ap√≥s usar
       window._duplicataConfirmadaPeloUsuario = false;
       console.log(`‚úÖ ${platformType}: Flag limpa ap√≥s uso no Supabase`);
     } else {
       console.log(`üîç ${platformType}: Verificando duplicatas no insertSupabase (flag n√£o est√° ativa)`);
       // üö® VERIFICA√á√ÉO CR√çTICA DE DUPLICATAS NO BANCO: Verificar no Supabase ANTES de inserir
       const nomeVerificacao = payloadPadronizado.nome || payloadPadronizado.nome_completo || payloadPadronizado.NOME || payloadPadronizado['NOME COMPLETO'] || '';
       const comumVerificacao = payloadPadronizado.comum || payloadPadronizado.COMUM || '';
       const cargoVerificacao = payloadPadronizado.cargo || payloadPadronizado.CARGO || '';
       
       if (supabaseLoaded && sb && nomeVerificacao && comumVerificacao && cargoVerificacao) {
         try {
           const dataAtual = new Date();
           const dataISO = dataAtual.toISOString().split('T')[0];
           
           // Buscar registros duplicados (mesmo nome + comum + cargo no mesmo dia)
           const { data: duplicatas, error: dupError } = await sb
             .from(TABLE_PRESENCAS)
             .select('nome_completo, comum, cargo, created_at, uuid')
             .ilike('nome_completo', `%${nomeVerificacao.trim()}%`)
             .ilike('comum', `%${comumVerificacao.trim()}%`)
             .gte('created_at', `${dataISO}T00:00:00.000Z`)
             .lt('created_at', `${dataISO}T23:59:59.999Z`)
             .limit(10);
           
           if (!dupError && duplicatas && duplicatas.length > 0) {
             // Verificar se h√° duplicata exata (mesmo nome, comum e cargo)
             const duplicataExata = duplicatas.find(d => {
               const nomeMatch = norm(d.nome_completo || '').toUpperCase().trim() === norm(nomeVerificacao).toUpperCase().trim();
               const comumMatch = compareComum(d.comum || '', comumVerificacao).match;
               const cargoMatch = norm(d.cargo || '').toUpperCase().trim() === norm(cargoVerificacao).toUpperCase().trim();
               return nomeMatch && comumMatch && cargoMatch;
             });
             
             if (duplicataExata) {
               console.error('üö®üö®üö® DUPLICATA DETECTADA NO SUPABASE - BLOQUEANDO INSER√á√ÉO üö®üö®üö®', {
                 nome: nomeVerificacao,
                 comum: comumVerificacao,
                 cargo: cargoVerificacao,
                 uuidExistente: duplicataExata.uuid,
                 dataExistente: duplicataExata.created_at
               });
               
               // üö® BLOQUEIO COMPLETO: Retornar erro para impedir inser√ß√£o
               throw new Error(`DUPLICATA_BLOQUEADA: Registro duplicado detectado. ${nomeVerificacao} de ${comumVerificacao} j√° foi cadastrado hoje.`);
             }
           }
         } catch (error) {
           // Se o erro for de duplicata bloqueada, propagar o erro
           if (error.message && error.message.includes('DUPLICATA_BLOQUEADA')) {
             console.error('üö®üö®üö® BLOQUEIO DEFINITIVO DE DUPLICATA NO insertSupabase üö®üö®üö®');
             throw error;
           }
           console.warn('‚ö†Ô∏è Erro ao verificar duplicatas no Supabase (insertSupabase):', error);
           // Continua apenas se n√£o for erro de duplicata
         }
       }
       }
     
     // üõ°Ô∏è VALIDA√á√ÉO DUPLA: Garante que o UUID n√£o foi alterado na padroniza√ß√£o
     if (!isValidUUID(payloadPadronizado.uuid)) {
       console.error('‚ùå UUID foi corrompido durante padroniza√ß√£o:', payloadPadronizado.uuid);
       payloadPadronizado.uuid = uuidv4();
       console.log('‚úÖ Novo UUID gerado ap√≥s padroniza√ß√£o:', payloadPadronizado.uuid);
     }
     
     console.log('üì§ DEBUG - Payload padronizado para Supabase:', payloadPadronizado);
     
     // UUID j√° validado, n√£o precisa corrigir novamente
     const validUUID = payloadPadronizado.uuid;
     console.log('üîß UUID final validado:', validUUID);
     
     // Usando os nomes corretos das colunas baseado no schema mostrado no console
     const row = {
       uuid: validUUID,
       nome_completo: payloadPadronizado.nome,
       comum: payloadPadronizado.comum,
       cidade: payloadPadronizado.cidade || null, // Campo cidade adicionado
       cargo: payloadPadronizado.cargo,
       instrumento: payloadPadronizado.instrumento || null,
       naipe_instrumento: payloadPadronizado.naipe || null,
       classe_organista: payloadPadronizado.nivel || null, // Classe da organista (vem do campo nivel do payload)
       local_ensaio: payloadPadronizado.local_ensaio || null,
       data_ensaio: payloadPadronizado.data_ensaio_iso || null, // Formato ISO para Supabase
       registrado_por: payloadPadronizado.registrado_por || null,
       // user_id removido - coluna n√£o existe na tabela presencas
       created_at: payloadPadronizado.created_at
     };
     
    console.log('üì§ DEBUG - Row final para Supabase:', row);
    console.log('üì§ DEBUG - TABLE_PRESENCAS:', TABLE_PRESENCAS);
    console.log('üì§ DEBUG - Cliente Supabase dispon√≠vel:', !!sb);
    console.log('üì§ DEBUG - M√©todo from dispon√≠vel:', typeof sb?.from === 'function');
    
    // üö® CORRE√á√ÉO CR√çTICA: Retry logic robusto para mobile/online
    const maxRetries = 3;
    let lastError = null;
    
    try {
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
          // üö® CORRE√á√ÉO CR√çTICA: Adicionar timeout expl√≠cito e logs detalhados
          console.log(`üì§ Tentando inserir no Supabase (tentativa ${attempt}/${maxRetries})...`);
          const startTime = Date.now();
          
          const { data, error } = await sb.from(TABLE_PRESENCAS).insert(row);
          
          const endTime = Date.now();
          const duration = endTime - startTime;
          console.log(`üì§ Resposta do Supabase recebida em ${duration}ms`);
          
          if(error) {
            console.error(`‚ùå ERRO no Supabase (tentativa ${attempt}/${maxRetries}):`, error);
            console.error('‚ùå Detalhes completos do erro:', {
              code: error.code,
              message: error.message,
              details: error.details,
              hint: error.hint,
              status: error.status,
              statusText: error.statusText
            });
            
            // üö® CORRE√á√ÉO CR√çTICA: Verificar se √© erro de RLS (permiss√£o negada)
            if (error.code === '42501' || error.message?.includes('permission denied') || error.message?.includes('row-level security') || error.message?.includes('new row violates row-level security')) {
              console.error('‚ùå ERRO DE RLS: Permiss√£o negada para INSERT na tabela presencas');
              console.error('‚ùå SOLU√á√ÉO: Execute o script RLS_POLICY_PRESENCAS.sql no Supabase');
              console.error('‚ùå O script cria pol√≠tica para permitir INSERT p√∫blico');
              throw new Error('Erro de permiss√£o: RLS est√° bloqueando a inser√ß√£o. Execute RLS_POLICY_PRESENCAS.sql no Supabase.');
            }
            
            // üö® CORRE√á√ÉO: Se for erro de duplica√ß√£o, n√£o retry
            if (error.code === '23505' || error.message?.includes('duplicate key') || error.message?.includes('already exists')) {
              console.log('‚úÖ Duplica√ß√£o detectada - n√£o precisa retry');
              throw error; // Ser√° tratado no catch externo
            }
            
            // üö® CORRE√á√ÉO: Se for erro de valida√ß√£o, n√£o retry
            if (error.code === '23514' || error.message?.includes('violates check constraint')) {
              console.error('‚ùå Erro de valida√ß√£o - n√£o precisa retry');
              throw error;
            }
            
            // Para outros erros, tentar novamente
            lastError = error;
            
            if (attempt < maxRetries) {
              const delay = attempt * 1000; // 1s, 2s, 3s
              console.log(`‚è≥ Aguardando ${delay}ms antes de tentar novamente...`);
              await new Promise(resolve => setTimeout(resolve, delay));
              continue;
            } else {
              throw error;
            }
          }
          
          // Sucesso! - sai do loop de retry
          console.log(`‚úÖ Supabase: Dados inseridos com sucesso (tentativa ${attempt})`);
          console.log(`‚úÖ Supabase: Data retornada:`, data);
          console.log(`‚úÖ Supabase: Row inserido:`, {
            uuid: row.uuid,
            nome_completo: row.nome_completo,
            comum: row.comum,
            cargo: row.cargo
          });
          
          // üõ°Ô∏è MARCAR COMO ENVIADO DEFINITIVAMENTE: Registrar permanente (SEM TEMPO)
          if (uuid) {
            let sentRecords = safeGetItem('sent_records', {});
            // Marca como enviado - PERMANENTE (sem timestamp)
            sentRecords[`sb_${uuid}`] = true;
            
            // Tamb√©m marca por conte√∫do - PERMANENTE
            const contentKey = `content_${(nomeParaValidacao || '').trim()}_${(payload.comum || '').trim()}_${(cargoParaValidacao || '').trim()}`.replace(/\s+/g, '_').toLowerCase();
            sentRecords[contentKey] = true;
            
            safeSetItem('sent_records', sentRecords);
            console.log(`‚úÖ Supabase: Registro marcado como enviado (UUID: ${uuid})`);
          }
          
          // üö® CORRE√á√ÉO: Retornar objeto de sucesso expl√≠cito
          return { success: true, data: data };
        } catch (retryError) {
          // Se for erro de duplica√ß√£o, tratar no catch externo
          if (retryError.code === '23505' || retryError.message?.includes('duplicate key') || retryError.message?.includes('already exists')) {
            throw retryError;
          }
          
          // Se for erro de valida√ß√£o, tratar no catch externo
          if (retryError.code === '23514' || retryError.message?.includes('violates check constraint')) {
            throw retryError;
          }
          
          lastError = retryError;
          
          // Se n√£o √© a √∫ltima tentativa, continua o loop
          if (attempt < maxRetries) {
            const delay = attempt * 1000; // 1s, 2s, 3s
            console.log(`‚è≥ Erro na tentativa ${attempt}, aguardando ${delay}ms antes de tentar novamente...`);
            console.error(`‚ùå Erro na tentativa ${attempt}:`, retryError.message);
            await new Promise(resolve => setTimeout(resolve, delay));
            continue;
          }
          
          // √öltima tentativa falhou
          console.error(`‚ùå Todas as ${maxRetries} tentativas falharam`);
          throw retryError;
        }
      }
      
      // Se chegou aqui, todas as tentativas falharam
      if (lastError) {
        throw lastError;
      }
      
      // Nunca deveria chegar aqui, mas se chegou, lan√ßa erro gen√©rico
      throw new Error('Erro desconhecido ao inserir no Supabase');
    } catch (error) {
      // üõ°Ô∏è TRATAMENTO DE DUPLICA√á√ÉO: Se for erro de chave duplicada, retorna sucesso
      if (error.code === '23505' || error.message?.includes('duplicate key') || error.message?.includes('already exists')) {
        console.log('‚úÖ Duplica√ß√£o evitada no Supabase (registro j√° existe):', uuid);
        // Marca como enviado mesmo sendo duplicado - PERMANENTE
        if (uuid) {
          let sentRecords = safeGetItem('sent_records', {});
          sentRecords[`sb_${uuid}`] = true;
          safeSetItem('sent_records', sentRecords);
        }
        return { success: true, duplicate: true };
      }
      
      // üö® CORRE√á√ÉO CR√çTICA: Logs detalhados para diagn√≥stico
      console.error('‚ùå ERRO GERAL no Supabase:', error);
      console.error('‚ùå Tipo do erro:', error.constructor.name);
      console.error('‚ùå Mensagem do erro:', error.message);
      console.error('‚ùå Stack do erro:', error.stack);
      console.error('‚ùå C√≥digo do erro:', error.code);
      console.error('‚ùå Payload que causou erro:', row);
      console.error('‚ùå UUID do registro:', validUUID);
      console.error('‚ùå Supabase carregado:', supabaseLoaded);
      console.error('‚ùå Cliente Supabase dispon√≠vel:', !!sb);
      console.error('‚ùå Navigator online:', navigator.onLine);
      
      // üö® CORRE√á√ÉO: Verificar se √© erro de rede/timeout
      if (error.name === 'AbortError' || error.message?.includes('aborted') || error.message?.includes('timeout')) {
        console.error('‚ùå ERRO DE TIMEOUT/REDE no Supabase');
        throw new Error('Timeout ao enviar para Supabase. Verifique sua conex√£o com a internet.');
      }
      
      // üö® CORRE√á√ÉO: Verificar se √© erro de CORS
      if (error.message?.includes('CORS') || error.message?.includes('cross-origin')) {
        console.error('‚ùå ERRO DE CORS no Supabase');
        throw new Error('Erro de CORS ao enviar para Supabase. Verifique as configura√ß√µes do servidor.');
      }
      
      throw error;
    }
   }
   
   /* ===== SUBMIT / FILA OFFLINE ===== */
   // Fun√ß√£o para gerar UUID v4 DEFINITIVAMENTE V√ÅLIDO
   function uuidv4() {
     try {
       // M√âTODO 1: crypto.randomUUID (mais confi√°vel)
       if (typeof crypto !== 'undefined' && crypto.randomUUID) {
         const uuid = crypto.randomUUID();
         if (isValidUUID(uuid)) {
           console.log('‚úÖ UUID gerado via crypto.randomUUID:', uuid);
           return uuid;
         }
       }
       
       // M√âTODO 2: Gera√ß√£o manual robusta
       const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
         const r = (Math.random() * 16) | 0;
         const v = c === 'x' ? r : (r & 0x3 | 0x8);
         return v.toString(16);
       });
       
       if (isValidUUID(uuid)) {
         console.log('‚úÖ UUID gerado via m√©todo manual:', uuid);
         return uuid;
       }
       
       // M√âTODO 3: Gera√ß√£o com m√∫ltiplas tentativas
       for (let i = 0; i < 10; i++) {
         const attempt = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
           const r = (Math.random() * 16) | 0;
           const v = c === 'x' ? r : (r & 0x3 | 0x8);
           return v.toString(16);
         });
         
         if (isValidUUID(attempt)) {
           console.log('‚úÖ UUID gerado na tentativa', i + 1, ':', attempt);
           return attempt;
         }
       }
       
       throw new Error('Falha ao gerar UUID v√°lido ap√≥s 10 tentativas');
       
     } catch (error) {
       console.error('‚ùå ERRO CR√çTICO na gera√ß√£o de UUID:', error);
       
       // √öLTIMO RECURSO: UUID fixo para emerg√™ncia (NUNCA usar em produ√ß√£o)
       const emergencyUUID = '00000000-0000-4000-8000-000000000000';
       console.error('üö® USANDO UUID DE EMERG√äNCIA:', emergencyUUID);
       return emergencyUUID;
     }
   }
   
   // Fun√ß√£o para validar se um UUID √© v√°lido (RIGOROSA - apenas UUID v4)
   function isValidUUID(uuid) {
     if (!uuid || typeof uuid !== 'string') {
       console.warn('‚ö†Ô∏è UUID inv√°lido: n√£o √© string ou est√° vazio');
       return false;
     }
     
     // Verificar se √© UUID v4 padr√£o (√öNICO formato aceito)
     const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
     const isValid = uuidRegex.test(uuid);
     
     if (!isValid) {
       console.warn('‚ö†Ô∏è UUID inv√°lido detectado:', uuid);
       console.warn('‚ö†Ô∏è Formato esperado: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx');
     } else {
       console.log('‚úÖ UUID v√°lido confirmado:', uuid);
     }
     
     return isValid;
   }
   
   // Fun√ß√£o para corrigir UUID inv√°lido (GARANTE UUID V√ÅLIDO)
   function fixInvalidUUID(uuid) {
     if (isValidUUID(uuid)) {
       return uuid;
     }
   
     console.warn('‚ö†Ô∏è UUID inv√°lido detectado, gerando novo UUID v√°lido:', uuid);
   
     // SEMPRE gerar UUID v√°lido (nunca ID simples)
     try {
       const newUUID = uuidv4();
       if (isValidUUID(newUUID)) {
         console.log('‚úÖ UUID corrigido com sucesso:', newUUID);
         return newUUID;
       } else {
         throw new Error('UUID gerado ainda √© inv√°lido');
       }
     } catch (error) {
       console.error('‚ùå ERRO CR√çTICO ao corrigir UUID:', error);
       
       // √öLTIMO RECURSO: UUID fixo v√°lido
       const emergencyUUID = '00000000-0000-4000-8000-000000000000';
       console.error('üö® USANDO UUID DE EMERG√äNCIA V√ÅLIDO:', emergencyUUID);
       return emergencyUUID;
     }
   }
   
   const QUEUE_KEY = 'fila_presencas_v2';
   function pushQueue(item) {
     try {
       // üöÄ CORRE√á√ÉO: Preservar TODOS os campos, incluindo mai√∫sculas/min√∫sculas
       // Converter dados do formato antigo para o novo formato, preservando todos os campos
       const data = {
         uuid: item.UUID || item.uuid || uuidv4(),
         nome: item['NOME COMPLETO'] || item.nome || item.NOME || '',
         comum: item.COMUM || item.comum || '',
         cidade: item.CIDADE || item.cidade || item.local || '',
         cargo: item.CARGO || item.cargo || '',
         instrumento: item.INSTRUMENTO || item.instrumento || '',
         naipe: item.NAIPE_INSTRUMENTO || item.naipe || item.naipe_instrumento || '',
         nivel: item.CLASSE_ORGANISTA || item.nivel || item.classe || '',
         local_ensaio: item.LOCAL_ENSAIO || item.local_ensaio || '',
         data_ensaio: item.DATA_ENSAIO || item.data_ensaio || '',
         horario: item.HOR√ÅRIO || item.horario || '',
         registrado_por: item.REGISTRADO_POR || item.registrado_por || '',
         user_id: item.USER_ID || item.user_id || '',
         anotacoes: item.ANOTACOES || item.anotacoes || '',
         timestamp: item.timestamp || getCurrentTimestamp()
       };
       
       console.log('üìã DEBUG pushQueue - Dados convertidos:', {
         uuid: data.uuid,
         nome: data.nome,
         comum: data.comum,
         cidade: data.cidade,
         cargo: data.cargo,
         instrumento: data.instrumento
       });
       
       // CORRE√á√ÉO: Usar o sistema principal de fila offline
       const recordId = addToOfflineQueue(data);
       
       console.log('‚úÖ Item adicionado √† fila principal:', data.nome || 'Sem nome', 'Cargo:', data.cargo);
       
       // Log espec√≠fico para desktop
       if (isDesktop) {
         console.log('üñ•Ô∏è DESKTOP: Item adicionado √† fila offline:', {
           id: recordId,
           nome: data.nome || 'Sem nome',
           comum: data.comum || 'Sem comum',
           cidade: data.cidade || 'Sem cidade',
           cargo: data.cargo || 'Sem cargo',
           timestamp: new Date().toLocaleTimeString()
         });
       }
       
       // Log espec√≠fico para mobile
       const isMobile = window.innerWidth <= 768 || /Mobile|Android|iPhone|iPad/.test(navigator.userAgent);
       if (isMobile) {
         console.log('üì± MOBILE: Item adicionado √† fila offline:', {
           id: recordId,
           nome: data.nome || 'Sem nome',
           comum: data.comum || 'Sem comum',
           cidade: data.cidade || 'Sem cidade',
           cargo: data.cargo || 'Sem cargo',
           timestamp: new Date().toLocaleTimeString()
         });
       }
       
     } catch (error) {
       console.error('‚ùå Erro ao adicionar √† fila:', error);
     }
   }
   
   // Fun√ß√£o updateQueueCount j√° foi definida acima no novo sistema
   
   // üöÄ FUN√á√ÉO OTIMIZADA: Processamento r√°pido da fila
   async function flushQueue() {
     // CORRE√á√ÉO: Usar o sistema principal de fila offline
     console.log('üîÑ Processando fila offline principal...');
     await processOfflineQueue();
     
     // Tamb√©m processar fila antiga se existir (migra√ß√£o)
     const arr = JSON.parse(localStorage.getItem(QUEUE_KEY) || '[]');
     if (arr.length > 0) {
       console.log(`üîÑ Migrando ${arr.length} itens da fila antiga...`);
       
       // Migrar itens da fila antiga para a fila principal
       for (const item of arr) {
         addToOfflineQueue(item);
       }
       
       // Limpar fila antiga
       localStorage.removeItem(QUEUE_KEY);
       console.log('‚úÖ Migra√ß√£o da fila antiga conclu√≠da');
     }
   }
   
   function getFieldValue(el) {
     if (!el) return '';
     return (el.value || '').trim();
   }
   
   // NOVA FUNCIONALIDADE: Verifica e corrige cargo automaticamente
   async function verificarECorrigirCargo(nomeCompleto, comum, instrumento, cargoAtual) {
     try {
       // S√≥ verifica se o cargo atual √© "M√∫sico" e h√° instrumento
       const cargoUP = ucase(cargoAtual);
       if (!cargoUP.includes('M√öSICO') || !instrumento) {
         console.log('üîç N√£o precisa verificar cargo:', { cargoAtual, instrumento });
         return cargoAtual; // N√£o precisa verificar
       }
       
       console.log('üîç VERIFICA√á√ÉO DE CARGO - Iniciando:', { nomeCompleto, comum, instrumento, cargoAtual });
       
       // Verifica se h√° conex√£o com Supabase
       if (!supabaseLoaded || !sb) {
         console.log('‚ö†Ô∏è Supabase n√£o dispon√≠vel para verifica√ß√£o de cargo');
         return cargoAtual;
       }
       
       // BUSCA SIMPLES: Nome + Comum (sem filtro de cargo ou instrumento)
       console.log('üîç Fazendo busca simples por nome e comum...');
       const { data, error } = await sb
         .from(TABLE_CATALOGO)
         .select('cargo, instrumento, nome, comum')
         .ilike('nome', `%${nomeCompleto}%`)
         .ilike(COL_COMUM, `%${comum}%`)
         .limit(10);
       
       if (error) {
         console.warn('‚ö†Ô∏è Erro ao verificar cargo no banco:', error.message);
         return cargoAtual;
       }
       
       console.log('üîç RESULTADOS DA BUSCA:', {
         totalResultados: data?.length || 0,
         resultados: data,
         nomeBuscado: nomeCompleto,
         comumBuscada: comum
       });
       
       if (data && data.length > 0) {
         // üõ°Ô∏è CORRE√á√ÉO: Procura por cargos especiais com diferencia√ß√£o de g√™nero
         const cargoEspecial = data.find(r => {
           const cargoUpper = r.cargo ? r.cargo.toUpperCase() : '';
           
           // Cargos que devem ser detectados (incluindo diferencia√ß√£o de g√™nero)
           const isInstrutor = cargoUpper.includes('INSTRUTOR') && !cargoUpper.includes('INSTRUTORA');
           const isInstrutora = cargoUpper.includes('INSTRUTORA');
           const isOrganista = cargoUpper.includes('ORGANISTA');
           const isExaminadora = cargoUpper.includes('EXAMINADORA');
           const isSecretariaMusica = cargoUpper.includes('SECRET√ÅRIA') && cargoUpper.includes('M√öSICA');
           
           // üö® CORRE√á√ÉO CR√çTICA: SECRET√ÅRIO DA M√öSICA (masculino) N√ÉO deve ser detectado como cargo especial
           // pois n√£o deve receber classe de organista
           const isSecretarioMusica = cargoUpper.includes('SECRET√ÅRIO') && cargoUpper.includes('M√öSICA');
           
           console.log('üîç Verificando cargo:', {
             cargo: r.cargo,
             cargoUpper,
             isInstrutor,
             isInstrutora,
             isOrganista,
             isExaminadora,
             isSecretariaMusica,
             isSecretarioMusica,
             deveDetectar: isInstrutor || isInstrutora || isOrganista || isExaminadora || isSecretariaMusica
           });
           
           return isInstrutor || isInstrutora || isOrganista || isExaminadora || isSecretariaMusica;
         });
         
         if (cargoEspecial) {
           console.log('üéì CARGO ESPECIAL ENCONTRADO:', cargoEspecial);
           console.log('üéì CORRIGINDO CARGO DE', cargoAtual, 'PARA', cargoEspecial.cargo);
           return cargoEspecial.cargo;
         } else {
           console.log('üîç Nenhum cargo especial encontrado nos resultados');
           console.log('üîç Cargos encontrados:', data.map(r => r.cargo));
         }
       }
       
       console.log('‚úÖ Cargo "M√∫sico" est√° correto - n√£o √© cargo especial');
       return cargoAtual;
       
     } catch (error) {
       console.warn('‚ö†Ô∏è Erro na verifica√ß√£o de cargo:', error.message);
       return cargoAtual;
     }
   }
   
   async function collectFormData() {
     const comumEl = findComumField();
     const instEl  = findInstrumentField();
     const cargoEl = findCargoField();
     const nomeEl  = findNomeField();
     const anotEl  = document.querySelector('#anotacoes, [name="anotacoes"], textarea');
     
     // üõ°Ô∏è CORRE√á√ÉO: Declarar vari√°vel classe no in√≠cio para evitar erro de inicializa√ß√£o
     let classe = null;
     const nivelEl = document.querySelector('#nivel, [name="nivel"], input[placeholder*="classe"], input[placeholder*="nivel"]');
   
     const comum = getFieldValue(comumEl);
     let cargo = getFieldValue(cargoEl);
     const instrumento = getFieldValue(instEl);
     const nomeCompleto = getFieldValue(nomeEl);
     const anotacoes = getFieldValue(anotEl);
     let nivel = getFieldValue(nivelEl);

    // üîí Produ√ß√£o: n√£o alterar cargo selecionado pelo usu√°rio automaticamente
    const disableCargoCorrection = true;

    // ‚úÖ DETEC√á√ÉO ANTECIPADA: identificar se o nome foi digitado manualmente antes de qualquer consulta/corre√ß√£o
    let isNomeManualEarly = false;
    try {
      if (nomeEl) {
        const selectedFromListAttr = nomeEl.getAttribute('data-selected-from-list') === 'true';
        const markedManualAttr = nomeEl.getAttribute('data-nome-manual') === 'true';
        // Regra estrita: s√≥ √© manual se marcado explicitamente e N√ÉO foi selecionado da lista
        isNomeManualEarly = markedManualAttr && !selectedFromListAttr;
      }
    } catch (e) { /* noop */ }
     
     // üõ°Ô∏è SEGURAN√áA: Valida√ß√£o de comprimento m√°ximo antes de processar
     const MAX_FIELD_LENGTH_VALIDATION = {
       nome: 255,
       comum: 255,
       cidade: 255,
       cargo: 100,
       instrumento: 100,
       anotacoes: 1000
     };
     
     // üõ°Ô∏è SEGURAN√áA: Validar e truncar campos que excedem comprimento
     if (nomeCompleto && nomeCompleto.length > MAX_FIELD_LENGTH_VALIDATION.nome) {
       if (window.safeLog) {
         window.safeLog.warn(`‚ö†Ô∏è Campo nome excedeu comprimento m√°ximo, truncando...`);
       }
       nomeCompleto = nomeCompleto.substring(0, MAX_FIELD_LENGTH_VALIDATION.nome);
     }
     
     if (comum && comum.length > MAX_FIELD_LENGTH_VALIDATION.comum) {
       if (window.safeLog) {
         window.safeLog.warn(`‚ö†Ô∏è Campo comum excedeu comprimento m√°ximo, truncando...`);
       }
       comum = comum.substring(0, MAX_FIELD_LENGTH_VALIDATION.comum);
     }
     
     if (cargo && cargo.length > MAX_FIELD_LENGTH_VALIDATION.cargo) {
       if (window.safeLog) {
         window.safeLog.warn(`‚ö†Ô∏è Campo cargo excedeu comprimento m√°ximo, truncando...`);
       }
       cargo = cargo.substring(0, MAX_FIELD_LENGTH_VALIDATION.cargo);
     }
     
     if (instrumento && instrumento.length > MAX_FIELD_LENGTH_VALIDATION.instrumento) {
       if (window.safeLog) {
         window.safeLog.warn(`‚ö†Ô∏è Campo instrumento excedeu comprimento m√°ximo, truncando...`);
       }
       instrumento = instrumento.substring(0, MAX_FIELD_LENGTH_VALIDATION.instrumento);
     }
     
     if (anotacoes && anotacoes.length > MAX_FIELD_LENGTH_VALIDATION.anotacoes) {
       if (window.safeLog) {
         window.safeLog.warn(`‚ö†Ô∏è Campo anotacoes excedeu comprimento m√°ximo, truncando...`);
       }
       anotacoes = anotacoes.substring(0, MAX_FIELD_LENGTH_VALIDATION.anotacoes);
     }
     
     // üõ°Ô∏è VALIDA√á√ÉO CR√çTICA MELHORADA: Valida√ß√£o rigorosa de campos obrigat√≥rios
     if (!comum || comum.trim() === '') {
       if (window.safeLog) {
         window.safeLog.error('‚ùå ERRO: Comum n√£o pode estar vazio');
       }
       showToast('error', 'Campo Obrigat√≥rio', 'Selecione uma comum', 3000);
       return null;
     }
     
     if (!cargo || cargo.trim() === '') {
       if (window.safeLog) {
         window.safeLog.error('‚ùå ERRO: Cargo n√£o pode estar vazio');
       }
       showToast('error', 'Campo Obrigat√≥rio', 'Selecione um cargo', 3000);
       return null;
     }
     
     if (!nomeCompleto || nomeCompleto.trim() === '') {
       if (window.safeLog) {
         window.safeLog.error('‚ùå ERRO: Nome n√£o pode estar vazio');
       }
       showToast('error', 'Campo Obrigat√≥rio', 'Digite ou selecione um nome', 3000);
       return null;
     }
     
     // üõ°Ô∏è VALIDA√á√ÉO ADICIONAL: Garantir que cargo foi selecionado corretamente
     if (cargoEl && cargoEl.tagName === 'SELECT' && !cargoEl.value) {
       console.error('‚ùå ERRO: Cargo n√£o foi selecionado no campo select');
       showToast('error', 'Campo Obrigat√≥rio', 'Selecione um cargo v√°lido', 3000);
       return null;
     }
     
     // Captura o cargo real armazenado nos atributos data se dispon√≠vel
     console.log('üîç DEBUG - Verificando atributo data-cargo-real:', {
       cargoEl: !!cargoEl,
       hasAttribute: cargoEl ? cargoEl.hasAttribute('data-cargo-real') : false,
       cargoOriginal: cargo,
       nomeCompleto: nomeCompleto,
       comum: comum
     });
     
     if (cargoEl && cargoEl.hasAttribute('data-cargo-real')) {
       const cargoReal = cargoEl.getAttribute('data-cargo-real');
       console.log('üéπ Cargo real capturado do atributo data-cargo-real:', cargoReal);
       
       // üö® FILTRO DE SEGURAN√áA: Valida√ß√£o cr√≠tica para organistas
       const cargoOriginalUpper = cargo.toUpperCase();
       const cargoRealUpper = cargoReal.toUpperCase();
       
       if (cargoOriginalUpper === 'ORGANISTA') {
         const isCargoMasculino = (cargoRealUpper.includes('INSTRUTOR') && !cargoRealUpper.includes('INSTRUTORA')) ||
                                 cargoRealUpper.includes('SECRET√ÅRIO DO GEM') ||
                                 cargoRealUpper.includes('SECRETARIO DO GEM') ||
                                 (cargoRealUpper.includes('SECRET√ÅRIO') && cargoRealUpper.includes('M√öSICA') && !cargoRealUpper.includes('SECRET√ÅRIA'));
         
         if (isCargoMasculino) {
           console.log('üö® ERRO CR√çTICO BLOQUEADO: Tentativa de usar cargo masculino para organista:', cargoReal);
           console.log('üö® Mantendo cargo original "Organista" para evitar erro de g√™nero');
           // üö® CORRE√á√ÉO: N√£o bloquear envio - apenas manter cargo como "Organista"
           // showToast('error', 'Erro de G√™nero', 'Organistas n√£o podem ter cargos masculinos. Verifique o cadastro.', 5000);
           // return null; // Removido - n√£o bloquear envio
           // Manter cargo como "Organista" e continuar
         }
       }
       
       console.log('üéØ CORRE√á√ÉO APLICADA: Cargo ser√° enviado como:', cargoReal, 'em vez de:', cargo);
       cargo = cargoReal;
     } else {
       console.log('üîç DEBUG - Nenhum cargo real encontrado, mantendo cargo original:', cargo);
     }
     
     // Captura o n√≠vel armazenado nos atributos data se o campo estiver vazio
     if (!nivel && cargoEl && cargoEl.hasAttribute('data-nivel-instrutor')) {
       nivel = cargoEl.getAttribute('data-nivel-instrutor');
       console.log('üéì N√≠vel capturado do atributo data-nivel-instrutor:', nivel);
       // Preenche o campo de n√≠vel se estiver vazio
       if (nivelEl && !nivelEl.value.trim()) {
         nivelEl.value = nivel;
       }
     }
     
     // CONSULTA SIMPLES: Se for Organista, verifica se √© Instrutora, Examinadora ou Secret√°ria no banco
    if (!disableCargoCorrection && !isNomeManualEarly && cargo && cargo.toUpperCase() === 'ORGANISTA' && nomeCompleto && comum) {
       try {
         console.log('üîç CONSULTA SIMPLES - Verificando se Organista √© Instrutora, Examinadora ou Secret√°ria:', { nomeCompleto, comum });
         
         const { data } = await sb
           .from(TABLE_CATALOGO)
           .select('cargo, nivel')
           .ilike('nome', `%${nomeCompleto}%`)
           .ilike(COL_COMUM, `%${comum}%`)
           .or('cargo.ilike.%INSTRUTORA%,cargo.ilike.%EXAMINADORA%,cargo.ilike.%SECRET√ÅRIA DA M√öSICA%,cargo.ilike.%SECRET√ÅRIA DO GEM%')
           .limit(1);
         
         if (data && data.length > 0) {
           const cargoEncontrado = data[0].cargo;
           const cargoEncontradoUpper = cargoEncontrado.toUpperCase();
           
           // üö® FILTRO DE SEGURAN√áA CR√çTICO: Verifica se o cargo encontrado √© masculino
           const isCargoMasculino = (cargoEncontradoUpper.includes('INSTRUTOR') && !cargoEncontradoUpper.includes('INSTRUTORA')) ||
                                   cargoEncontradoUpper.includes('SECRET√ÅRIO DO GEM') ||
                                   cargoEncontradoUpper.includes('SECRETARIO DO GEM') ||
                                   (cargoEncontradoUpper.includes('SECRET√ÅRIO') && cargoEncontradoUpper.includes('M√öSICA') && !cargoEncontradoUpper.includes('SECRET√ÅRIA'));
           
           if (isCargoMasculino) {
             console.log('üö® ERRO CR√çTICO BLOQUEADO: Cargo masculino encontrado para organista:', cargoEncontrado);
             console.log('üö® Mantendo cargo original "Organista" para evitar erro de g√™nero');
             console.log('üö® ATEN√á√ÉO: Cadastro no SAM est√° desatualizado - contate o administrador');
             // üö® CORRE√á√ÉO: N√£o bloquear envio - apenas manter cargo como "Organista"
             // showToast('error', 'Erro de G√™nero', 'Organistas n√£o podem ter cargos masculinos. Cadastro desatualizado no SAM.', 8000);
             // return null; // Removido - n√£o bloquear envio
             // Manter cargo como "Organista" e continuar
           }
           
           cargo = cargoEncontrado;
           console.log('‚úÖ CARGO CORRIGIDO - De Organista para:', cargo);
           
           // Captura o n√≠vel se dispon√≠vel
           if (data[0].nivel) {
             console.log('‚úÖ N√çVEL CAPTURADO para cargo musical:', data[0].nivel);
             // Armazena o n√≠vel no campo de n√≠vel se estiver vazio
             if (nivelEl && !nivelEl.value.trim()) {
               nivelEl.value = data[0].nivel;
             }
           }
         } else {
           console.log('‚úÖ CARGO MANTIDO - √â Organista mesmo');
         }
       } catch (e) {
         console.log('‚ö†Ô∏è Erro na consulta simples:', e.message);
       }
     }
     
    // üéπ NOVA FUNCIONALIDADE: Buscar classe de organista para cargos musicais
    // üõ°Ô∏è CORRE√á√ÉO: Apenas SECRET√ÅRIA DA M√öSICA (feminino) recebe classe de organista
    // SECRET√ÅRIO DA M√öSICA (masculino) N√ÉO √© organista, ent√£o n√£o recebe classe
    // üõ°Ô∏è CORRE√á√ÉO: INSTRUTOR (masculino) N√ÉO recebe classe de organista, apenas INSTRUTORA (feminino)
    const isCargoMusical = cargo && (
      cargo.toUpperCase().includes('ORGANISTA') ||
      cargo.toUpperCase().includes('EXAMINADORA') ||
      cargo.toUpperCase().includes('INSTRUTORA') ||
      // Removido: INSTRUTOR n√£o deve receber classe de organista
      (cargo.toLowerCase().includes('secret√°ria') && cargo.toLowerCase().includes('m√∫sica'))
    );
     
     console.log('üîç DEBUG - Verificando condi√ß√µes para busca de classe:', {
       isCargoMusical,
       nomeCompleto,
       comum,
       classe,
       cargo,
       condicaoCompleta: isCargoMusical && nomeCompleto && comum && !classe
     });
     
     if (isCargoMusical && nomeCompleto && comum && !classe) {
       try {
         console.log('üéπ BUSCA DE CLASSE - Procurando classe de organista para cargo musical:', { cargo, nomeCompleto, comum });
         
         // Busca a classe de organista no banco
         const { data } = await sb
           .from(TABLE_CATALOGO)
           .select('cargo, nivel, instrumento')
           .ilike('nome', `%${nomeCompleto}%`)
           .ilike(COL_COMUM, `%${comum}%`)
           .ilike('cargo', '%ORGANISTA%')
           .eq('ativo', true)
           .limit(1);
         
         if (data && data.length > 0) {
           const registroOrganista = data[0];
           console.log('üéπ REGISTRO DE ORGANISTA ENCONTRADO:', registroOrganista);
           
           if (registroOrganista.nivel) {
             // üéπ CORRE√á√ÉO: Padroniza classe para cargos musicais (remove "(A)" e mant√©m prefixos)
             const classeOriginal = registroOrganista.nivel;
             
             // Verifica se tem prefixo (ex: "RJM / OFICIALIZADO(A)")
             if (classeOriginal.includes('/')) {
               const partes = classeOriginal.split('/');
               const prefixo = partes[0].trim();
               const sufixo = partes[1].trim();
               
               // Remove "(A)" do sufixo e padroniza para "OFICIALIZADA"
               const sufixoPadronizado = sufixo.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
               classe = `${prefixo} / ${sufixoPadronizado}`;
             } else {
               // Se n√£o tem prefixo, apenas padroniza para "OFICIALIZADA"
               classe = classeOriginal.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
             }
             
             console.log('‚úÖ CLASSE DE ORGANISTA CAPTURADA E PADRONIZADA:', classe);
             console.log('üéπ Classe original do banco:', classeOriginal, '‚Üí Padronizada para:', classe);
             
             // Armazena a classe no campo de n√≠vel se estiver vazio
             if (nivelEl && !nivelEl.value.trim()) {
               nivelEl.value = classe;
             }
           } else {
             // Se n√£o tem classe espec√≠fica, assume "OFICIALIZADA" para cargos musicais
             classe = 'OFICIALIZADA';
             console.log('üéπ CLASSE PADR√ÉO APLICADA (OFICIALIZADA) para cargo musical');
             
             if (nivelEl && !nivelEl.value.trim()) {
               nivelEl.value = classe;
             }
           }
         } else {
           // Se n√£o encontrou registro de organista, assume "OFICIALIZADA" para cargos musicais
           classe = 'OFICIALIZADA';
           console.log('üéπ CLASSE PADR√ÉO APLICADA (OFICIALIZADA) - n√£o encontrado registro de organista');
           
           if (nivelEl && !nivelEl.value.trim()) {
             nivelEl.value = classe;
           }
         }
       } catch (e) {
         console.log('‚ö†Ô∏è Erro na busca de classe de organista:', e.message);
         // Em caso de erro, assume "OFICIALIZADA"
         classe = 'OFICIALIZADA';
         console.log('üéπ CLASSE PADR√ÉO APLICADA (OFICIALIZADA) - erro na consulta');
         if (nivelEl && !nivelEl.value.trim()) {
           nivelEl.value = classe;
         }
       }
     }
     
     // CONSULTA SIMPLES: Se for M√∫sico, verifica se √© Instrutor, Encarregado ou Secret√°rio no banco
    if (!disableCargoCorrection && !isNomeManualEarly && cargo && (cargo.toUpperCase() === 'M√öSICO' || cargo.toUpperCase() === 'M√öSICO(A)') && nomeCompleto && comum) {
       try {
         console.log('üîç CONSULTA SIMPLES - Verificando se M√∫sico √© Instrutor, Encarregado ou Secret√°rio:', { nomeCompleto, comum });
         
         // Primeiro faz uma busca ampla para debug
         const { data: debugData } = await sb
           .from(TABLE_CATALOGO)
           .select('cargo, nivel, nome, comum')
           .ilike('nome', `%${nomeCompleto}%`)
           .ilike(COL_COMUM, `%${comum}%`)
           .limit(5);
         
         console.log('üîç DEBUG - Busca ampla para m√∫sico:', debugData);
         
         // Tenta diferentes varia√ß√µes do cargo Secret√°rio da M√∫sica
         let data = null;
         
         // Primeiro tenta com a sintaxe exata
         const { data: data1 } = await sb
           .from(TABLE_CATALOGO)
           .select('cargo, nivel')
           .ilike('nome', `%${nomeCompleto}%`)
           .ilike(COL_COMUM, `%${comum}%`)
           .or('cargo.ilike.%INSTRUTOR%,cargo.ilike.%ENCARREGADO LOCAL%,cargo.ilike.%ENCARREGADO REGIONAL%,cargo.ilike.%SECRET√ÅRIO DA M√öSICA%,cargo.ilike.%SECRET√ÅRIA DA M√öSICA%,cargo.ilike.%SECRET√ÅRIO DO GEM%,cargo.ilike.%SECRET√ÅRIA DO GEM%')
           .limit(1);
         
         if (data1 && data1.length > 0) {
           data = data1;
         } else {
           // Se n√£o encontrou, tenta busca mais ampla
           const { data: data2 } = await sb
             .from(TABLE_CATALOGO)
             .select('cargo, nivel')
             .ilike('nome', `%${nomeCompleto}%`)
             .ilike(COL_COMUM, `%${comum}%`)
             .ilike('cargo', '%SECRET√ÅRIO%')
             .limit(1);
           
           if (data2 && data2.length > 0) {
             data = data2;
           } else {
             // √öltima tentativa: busca por qualquer cargo que n√£o seja M√öSICO
             const { data: data3 } = await sb
               .from(TABLE_CATALOGO)
               .select('cargo, nivel')
               .ilike('nome', `%${nomeCompleto}%`)
               .ilike(COL_COMUM, `%${comum}%`)
               .not('cargo', 'ilike', '%M√öSICO%')
               .limit(1);
             
             data = data3;
           }
         }
         
         console.log('üîç DEBUG - Resultado da consulta de cargo musical:', data);
         
         if (data && data.length > 0) {
           cargo = data[0].cargo;
           console.log('‚úÖ CARGO CORRIGIDO - De M√∫sico para:', cargo);
           
           // Captura o n√≠vel se dispon√≠vel
           if (data[0].nivel) {
             console.log('‚úÖ N√çVEL CAPTURADO para cargo musical:', data[0].nivel);
             // Armazena o n√≠vel no campo de n√≠vel se estiver vazio
             if (nivelEl && !nivelEl.value.trim()) {
               nivelEl.value = data[0].nivel;
             }
           }
         } else {
           console.log('‚úÖ CARGO MANTIDO - √â M√∫sico mesmo');
         }
       } catch (e) {
         console.log('‚ö†Ô∏è Erro na consulta simples para m√∫sico:', e.message);
       }
     }
     
     // CONSULTA SIMPLES: Se for Instrutor, verifica se √© Encarregado ou Secret√°rio no banco
    if (!disableCargoCorrection && !isNomeManualEarly && cargo && (cargo.toUpperCase().includes('INSTRUTOR') || cargo.toUpperCase().includes('INSTRUTORA')) && nomeCompleto && comum) {
       try {
         console.log('üîç CONSULTA SIMPLES - Verificando se Instrutor √© Encarregado ou Secret√°rio:', { nomeCompleto, comum });
         
         const { data } = await sb
           .from(TABLE_CATALOGO)
           .select('cargo, nivel')
           .ilike('nome', `%${nomeCompleto}%`)
           .ilike(COL_COMUM, `%${comum}%`)
           .or('cargo.ilike.%ENCARREGADO LOCAL%,cargo.ilike.%ENCARREGADO REGIONAL%,cargo.ilike.%SECRET√ÅRIO DA M√öSICA%,cargo.ilike.%SECRET√ÅRIA DA M√öSICA%,cargo.ilike.%SECRET√ÅRIO DO GEM%,cargo.ilike.%SECRET√ÅRIA DO GEM%')
           .limit(1);
         
         if (data && data.length > 0) {
           cargo = data[0].cargo;
           console.log('‚úÖ CARGO CORRIGIDO - De Instrutor para:', cargo);
           
           // Captura o n√≠vel se dispon√≠vel
           if (data[0].nivel) {
             console.log('‚úÖ N√çVEL CAPTURADO para cargo musical:', data[0].nivel);
             // Armazena o n√≠vel no campo de n√≠vel se estiver vazio
             if (nivelEl && !nivelEl.value.trim()) {
               nivelEl.value = data[0].nivel;
             }
           }
         } else {
           console.log('‚úÖ CARGO MANTIDO - √â Instrutor mesmo');
         }
       } catch (e) {
         console.log('‚ö†Ô∏è Erro na consulta simples para instrutor:', e.message);
       }
     }
     
     // CONSULTA SIMPLES: Se for Secret√°rio da M√∫sica, verifica se √© Encarregado no banco
    if (!disableCargoCorrection && !isNomeManualEarly && cargo && (cargo.toLowerCase().includes('secret√°rio') || cargo.toLowerCase().includes('secret√°ria')) && 
        (cargo.toLowerCase().includes('m√∫sica') || cargo.toLowerCase().includes('musica')) && nomeCompleto && comum) {
       try {
         console.log('üîç CONSULTA SIMPLES - Verificando se Secret√°rio da M√∫sica √© Encarregado:', { nomeCompleto, comum });
         
         const { data } = await sb
           .from(TABLE_CATALOGO)
           .select('cargo, nivel')
           .ilike('nome', `%${nomeCompleto}%`)
           .ilike(COL_COMUM, `%${comum}%`)
           .or('cargo.ilike.%ENCARREGADO LOCAL%,cargo.ilike.%ENCARREGADO REGIONAL%')
           .limit(1);
         
         if (data && data.length > 0) {
           cargo = data[0].cargo;
           console.log('‚úÖ CARGO CORRIGIDO - De Secret√°rio da M√∫sica para:', cargo);
           
           // Captura o n√≠vel se dispon√≠vel
           if (data[0].nivel) {
             console.log('‚úÖ N√çVEL CAPTURADO para cargo musical:', data[0].nivel);
             // Armazena o n√≠vel no campo de n√≠vel se estiver vazio
             if (nivelEl && !nivelEl.value.trim()) {
               nivelEl.value = data[0].nivel;
             }
           }
         } else {
           console.log('‚úÖ CARGO MANTIDO - √â Secret√°rio da M√∫sica mesmo');
         }
       } catch (e) {
         console.log('‚ö†Ô∏è Erro na consulta simples para secret√°ria da m√∫sica:', e.message);
       }
     }
     
     // NOVA FUNCIONALIDADE: Corre√ß√£o autom√°tica de cargo (APENAS para M√∫sico)
     const cargoUP = ucase(cargo);
     if (nomeCompleto && comum && instrumento && cargo && 
         (cargoUP === 'M√öSICO' || cargoUP === 'M√öSICO(A)')) {
       try {
         console.log('üîç Corre√ß√£o de cargo - APENAS para M√∫sico:', { nomeCompleto, comum, instrumento, cargo });
         
         // Busca se o m√∫sico √© instrutor, encarregado ou secret√°rio usando comum + nome + instrumento
         console.log('üîç DEBUG - Fazendo consulta de corre√ß√£o de cargo:', {
           nome: `%${nomeCompleto}%`,
           comum: `%${comum}%`,
           instrumento: `%${instrumento}%`
         });
         
         // Primeiro, vamos fazer uma busca mais ampla para debug
         const { data: debugData, error: debugError } = await sb
           .from(TABLE_CATALOGO)
           .select('cargo, instrumento, nome, nivel, comum')
           .ilike('nome', `%${nomeCompleto}%`)
           .ilike(COL_COMUM, `%${comum}%`)
           .eq('ativo', true);
         
         console.log('üîç DEBUG - Busca ampla para corre√ß√£o:', { debugData, debugError });
         
         // Agora fazemos a busca espec√≠fica por cargos musicais
         const { data } = await sb
           .from(TABLE_CATALOGO)
           .select('cargo, instrumento, nome, nivel')
           .ilike('nome', `%${nomeCompleto}%`)
           .ilike(COL_COMUM, `%${comum}%`)
           .ilike('instrumento', `%${instrumento}%`)
           .or('cargo.ilike.%INSTRUTOR%,cargo.ilike.%INSTRUTORA%,cargo.ilike.%EXAMINADORA%,cargo.ilike.%ENCARREGADO LOCAL%,cargo.ilike.%ENCARREGADO REGIONAL%,cargo.ilike.%SECRET√ÅRIO DA M√öSICA%,cargo.ilike.%SECRET√ÅRIA DA M√öSICA%,cargo.ilike.%SECRET√ÅRIO DO GEM%,cargo.ilike.%SECRET√ÅRIA DO GEM%')
           .eq('ativo', true)
           .limit(1);
         
         console.log('üîç DEBUG - Resultado da consulta de corre√ß√£o:', { data });
         
         if (data && data.length > 0) {
           cargo = data[0].cargo;
           console.log('üéì Cargo corrigido de M√∫sico para:', cargo);
           
           // Captura o n√≠vel se dispon√≠vel
           if (data[0].nivel) {
             console.log('üéì N√çVEL CAPTURADO para cargo musical:', data[0].nivel);
             // Armazena o n√≠vel no campo de n√≠vel se estiver vazio
             if (nivelEl && !nivelEl.value.trim()) {
               nivelEl.value = data[0].nivel;
             }
           }
         } else {
           console.log('üîç M√∫sico comum - mantendo cargo "M√∫sico"');
           console.log('üîç DEBUG - Nenhum cargo musical encontrado para corre√ß√£o:', { nomeCompleto, comum, instrumento });
         }
       } catch (e) {
         console.log('üîç Erro na corre√ß√£o de cargo:', e.message);
       }
     } else {
       console.log('üîç Cargo n√£o √© M√∫sico - mantendo cargo original:', cargo);
     }
     
     // üö® CORRE√á√ÉO CR√çTICA: Detec√ß√£o autom√°tica de cargo musical para qualquer cargo se n√£o foi detectado antes
     // Isso garante que "Secret√°rio da M√∫sica" seja detectado mesmo se n√£o foi detectado na sele√ß√£o do nome
     if (nomeCompleto && comum && cargo && 
         !cargoEl.hasAttribute('data-cargo-real')) {
       try {
         console.log('üîç Detec√ß√£o autom√°tica de cargo musical - qualquer cargo:', { nomeCompleto, comum, instrumento, cargo });
         
         // üö® CORRE√á√ÉO: Busca sem filtro de instrumento primeiro (mais ampla)
         let data = null;
         
         // Primeiro tenta com filtro de instrumento (se houver)
         if (instrumento && instrumento.trim() !== '') {
           const { data: dataComInst } = await sb
             .from(TABLE_CATALOGO)
             .select('cargo, instrumento, nome, nivel')
             .ilike('nome', `%${nomeCompleto}%`)
             .ilike(COL_COMUM, `%${comum}%`)
             .ilike('instrumento', `%${instrumento}%`)
             .or('cargo.ilike.%INSTRUTOR%,cargo.ilike.%INSTRUTORA%,cargo.ilike.%EXAMINADORA%,cargo.ilike.%ENCARREGADO LOCAL%,cargo.ilike.%ENCARREGADO REGIONAL%,cargo.ilike.%SECRET√ÅRIO DA M√öSICA%,cargo.ilike.%SECRETARIO DA MUSICA%,cargo.ilike.%SECRET√ÅRIA DA M√öSICA%,cargo.ilike.%SECRETARIA DA MUSICA%,cargo.ilike.%SECRET√ÅRIO DO GEM%,cargo.ilike.%SECRET√ÅRIA DO GEM%')
             .eq('ativo', true)
             .limit(1);
           
           if (dataComInst && dataComInst.length > 0) {
             data = dataComInst;
             console.log('üîç DEBUG - Cargo encontrado com filtro de instrumento:', data);
           }
         }
         
         // Se n√£o encontrou, busca sem filtro de instrumento
         if (!data || data.length === 0) {
           const { data: dataSemInst } = await sb
             .from(TABLE_CATALOGO)
             .select('cargo, instrumento, nome, nivel')
             .ilike('nome', `%${nomeCompleto}%`)
             .ilike(COL_COMUM, `%${comum}%`)
             .or('cargo.ilike.%INSTRUTOR%,cargo.ilike.%INSTRUTORA%,cargo.ilike.%EXAMINADORA%,cargo.ilike.%ENCARREGADO LOCAL%,cargo.ilike.%ENCARREGADO REGIONAL%,cargo.ilike.%SECRET√ÅRIO DA M√öSICA%,cargo.ilike.%SECRETARIO DA MUSICA%,cargo.ilike.%SECRET√ÅRIA DA M√öSICA%,cargo.ilike.%SECRETARIA DA MUSICA%,cargo.ilike.%SECRET√ÅRIO DO GEM%,cargo.ilike.%SECRET√ÅRIA DO GEM%')
             .eq('ativo', true)
             .limit(1);
           
           data = dataSemInst;
           console.log('üîç DEBUG - Resultado da busca sem filtro de instrumento:', { data });
         }
         
         // üö® CORRE√á√ÉO: Se ainda n√£o encontrou, fazer busca ainda mais ampla (apenas nome + comum)
         if (!data || data.length === 0) {
           console.log('üîç DEBUG - Buscando com busca ainda mais ampla (apenas nome + comum)...');
           const { data: dataAmpla } = await sb
             .from(TABLE_CATALOGO)
             .select('cargo, instrumento, nome, nivel')
             .ilike('nome', `%${nomeCompleto}%`)
             .ilike(COL_COMUM, `%${comum}%`)
             .eq('ativo', true)
             .limit(10);
           
           if (dataAmpla && dataAmpla.length > 0) {
             // Filtra localmente por cargos musicais especiais
             const cargoEspecial = dataAmpla.find(r => {
               const cargoUpper = (r.cargo || '').toUpperCase();
               return cargoUpper.includes('INSTRUTOR') ||
                      cargoUpper.includes('INSTRUTORA') ||
                      cargoUpper.includes('EXAMINADORA') ||
                      cargoUpper.includes('ENCARREGADO LOCAL') ||
                      cargoUpper.includes('ENCARREGADO REGIONAL') ||
                      (cargoUpper.includes('SECRET√ÅRIO') && cargoUpper.includes('M√öSICA')) ||
                      (cargoUpper.includes('SECRETARIO') && cargoUpper.includes('MUSICA')) ||
                      (cargoUpper.includes('SECRET√ÅRIA') && cargoUpper.includes('M√öSICA')) ||
                      (cargoUpper.includes('SECRETARIA') && cargoUpper.includes('MUSICA')) ||
                      cargoUpper.includes('SECRET√ÅRIO DO GEM') ||
                      cargoUpper.includes('SECRET√ÅRIA DO GEM');
             });
             
             if (cargoEspecial) {
               data = [cargoEspecial];
               console.log('üîç DEBUG - Cargo especial encontrado na busca ampla:', cargoEspecial);
             }
           }
         }
         
         console.log('üîç DEBUG - Resultado final da detec√ß√£o autom√°tica:', { data });
         
         if (data && data.length > 0) {
           cargo = data[0].cargo;
           console.log('üéì CARGO MUSICAL DETECTADO automaticamente - cargo corrigido para:', cargo);
           
           // Armazena o cargo real para uso posterior
           cargoEl.setAttribute('data-cargo-real', cargo);
           
           // Captura o n√≠vel se dispon√≠vel
           if (data[0].nivel) {
             console.log('üéì N√çVEL CAPTURADO para cargo musical:', data[0].nivel);
             // Armazena o n√≠vel no campo de n√≠vel se estiver vazio
             if (nivelEl && !nivelEl.value.trim()) {
               nivelEl.value = data[0].nivel;
             }
           }
         } else {
           console.log('üîç Nenhum cargo musical encontrado na detec√ß√£o autom√°tica');
         }
       } catch (e) {
         console.log('üîç Erro na detec√ß√£o autom√°tica de cargo musical:', e.message);
       }
     }
     
     // Verifica se o cargo foi detectado automaticamente
     console.log('üîç Verificando detec√ß√£o autom√°tica de cargos...');
     
     if (cargoEl && cargoEl.hasAttribute('data-cargo-real')) {
       console.log('üéØ Cargo especial j√° detectado automaticamente');
     } else {
       console.log('üîç Nenhum cargo especial detectado automaticamente');
     }
     
     // Verifica√ß√£o de duplicata simplificada
     if (nomeCompleto && comum) {
       try {
         const duplicataEncontrada = await verificarDuplicata(nomeCompleto, comum);
         if (duplicataEncontrada) {
           console.log('üîç Duplicata encontrada, cancelando envio');
           return null;
         }
       } catch (error) {
         console.log('üîç Erro na verifica√ß√£o de duplicata, continuando:', error.message);
       }
     }
     
     // Extrai nome e classe separadamente se for organista
     let nome = nomeCompleto;
     
     // Primeiro tenta capturar a classe do atributo data-classe (captura autom√°tica)
     if (nomeEl && nomeEl.hasAttribute('data-classe')) {
       classe = nomeEl.getAttribute('data-classe');
       console.log('üéπ Classe capturada do atributo data-classe:', classe);
     } else {
       console.log('üéπ Nenhuma classe encontrada no atributo data-classe para:', nomeCompleto);
       
     // Fallback: tenta extrair do nome se contiver (classe:)
       if (nomeCompleto && nomeCompleto.includes('(classe:')) {
       const match = nomeCompleto.match(/^(.+?)\s*\(classe:\s*(.+?)\)$/);
       if (match) {
         nome = match[1].trim();
         classe = match[2].trim();
         console.log('üéπ Classe extra√≠da do nome:', classe);
         }
       }
     }
   
     if (!comum) throw new Error('Informe a Comum Congrega√ß√£o.');
     if (!cargo) throw new Error('Selecione o Cargo/Minist√©rio.');
     
     // Se for organista ou examinadora e n√£o tiver classe, tenta buscar novamente
     const cargoUPFinal = ucase(cargo);
     const isOrganista = cargoUPFinal === 'ORGANISTA';
     const isExaminadora = cargoUPFinal === 'EXAMINADORA';
     const isSecretariaMusica = cargo.toLowerCase().includes('secret√°ria') && cargo.toLowerCase().includes('m√∫sica');
     const isOrganistaOuRelacionado = isOrganista || isExaminadora || isSecretariaMusica;
     
     if ((isOrganista || isExaminadora) && !classe) {
       console.log('üéπ Organista ou cargo relacionado sem classe, tentando buscar novamente...');
       
       // Busca a classe no cache ou faz consulta direta
       try {
         const cacheKey = `cache_nomes_${comum}_${instrumento || 'ORGAO'}_${cargo}`;
         const dadosCompletos = getCache(cacheKey + '_dados');
         
         if (dadosCompletos && dadosCompletos.length > 0) {
           const registro = dadosCompletos.find(r => 
             norm(r.nome).toLowerCase() === norm(nomeCompleto).toLowerCase()
           );
           
           if (registro && registro.nivel) {
             // üéπ CORRE√á√ÉO: Aplica padroniza√ß√£o tamb√©m quando classe vem do cache
             const classeOriginal = registro.nivel;
             if (classeOriginal.includes('/')) {
               const partes = classeOriginal.split('/');
               const prefixo = partes[0].trim();
               const sufixo = partes[1].trim();
               const sufixoPadronizado = sufixo.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
               classe = `${prefixo} / ${sufixoPadronizado}`;
             } else {
               classe = classeOriginal.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
             }
             console.log('üéπ Classe encontrada no cache e padronizada:', classeOriginal, '‚Üí', classe);
           }
         }
         
         // Se ainda n√£o encontrou, faz consulta direta
         if (!classe && supabaseLoaded && sb) {
           const consultaDireta = await sb
             .from(TABLE_CATALOGO)
             .select('nome, nivel')
             .ilike('comum', `%${comum}%`)
             .ilike('nome', `%${nomeCompleto}%`)
             .or('cargo.ilike.%ORGANISTA%,cargo.ilike.%EXAMINADORA%,cargo.ilike.%INSTRUTOR%,cargo.ilike.%INSTRUTORA%,cargo.ilike.%SECRET√ÅRIO DA M√öSICA%,cargo.ilike.%SECRET√ÅRIA DA M√öSICA%,cargo.ilike.%SECRET√ÅRIO DO GEM%,cargo.ilike.%SECRET√ÅRIA DO GEM%')
             .eq('ativo', true)
             .limit(1);
           
           if (consultaDireta.data && consultaDireta.data.length > 0) {
             // üéπ CORRE√á√ÉO: Aplica padroniza√ß√£o tamb√©m quando classe vem da consulta direta
             const classeOriginal = consultaDireta.data[0].nivel;
             if (classeOriginal.includes('/')) {
               const partes = classeOriginal.split('/');
               const prefixo = partes[0].trim();
               const sufixo = partes[1].trim();
               const sufixoPadronizado = sufixo.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
               classe = `${prefixo} / ${sufixoPadronizado}`;
             } else {
               classe = classeOriginal.replace(/\(A\)/g, '').replace(/OFICIALIZADO/g, 'OFICIALIZADA').trim();
             }
             console.log('üéπ Classe encontrada via consulta direta e padronizada:', classeOriginal, '‚Üí', classe);
           }
         }
       } catch (error) {
         console.warn('‚ö†Ô∏è Erro ao buscar classe:', error.message);
       }
     }
     const precisaInst = ['MUSICO','MUSICO(A)','M√öSICO','M√öSICO(A)'].includes(cargoUPFinal) ||
                         cargoUPFinal === 'ORGANISTA' ||
                         cargoUPFinal === 'EXAMINADORA' ||
                         cargoUPFinal === 'INSTRUTOR' ||
                         cargoUPFinal === 'INSTRUTORA' ||
                         (cargo.toLowerCase().includes('secret√°ria') && cargo.toLowerCase().includes('m√∫sica'));
     
     if (precisaInst && !instrumento) {
       throw new Error('Selecione o Instrumento.');
     }
     if (!nome) throw new Error('Selecione/Informe o Nome.');
   
     let email = null;
     let nomeUsuario = null;
     let userId = null;
     
     try {
       if (supabaseLoaded && sb) {
         const { data } = await sb.auth.getUser();
         email = data?.user?.email || null;
         userId = data?.user?.id || null;
         
         // Armazena informa√ß√µes do usu√°rio atual na sess√£o para m√∫ltiplos logins
         if (userId) {
           localStorage.setItem('current_user_id', userId);
           localStorage.setItem('current_user_email', email);
         }
         
         // Formata o nome do usu√°rio a partir do email (sem consultar tabela profiles)
         if (email) {
           nomeUsuario = formatarNomeUsuario(email);
           localStorage.setItem('current_user_name', nomeUsuario);
           console.log('‚úÖ Nome do usu√°rio formatado:', nomeUsuario);
           console.log('üë§ Usu√°rio logado:', { email, userId, nomeUsuario });
         }
       } else {
         // Fallback para dados da sess√£o
         email = localStorage.getItem('current_user_email') || localStorage.getItem('session_user');
         userId = localStorage.getItem('current_user_id');
         nomeUsuario = localStorage.getItem('current_user_name') || email;
       }
     } catch (e) {
       // Fallback para dados da sess√£o em caso de erro
       email = localStorage.getItem('current_user_email') || localStorage.getItem('session_user');
       userId = localStorage.getItem('current_user_id');
       nomeUsuario = localStorage.getItem('current_user_name') || email;
     }
   
     // Obt√©m o naipe automaticamente baseado no instrumento (se houver instrumento)
     const naipe = instrumento ? getNaipeByInstrumento(instrumento) : null;
     
     // Valores finais coletados
     
     // Formata a data em formato brasileiro para Google Sheets
     const dataAtual = new Date();
     const dataFormatada = dataAtual.toLocaleDateString('pt-BR');
     
     // Formata a data em formato ISO para Supabase (YYYY-MM-DD)
     const dataFormatadaISO = dataAtual.toISOString().split('T')[0];
     
     // Obt√©m o local de ensaio da sess√£o
     const localEnsaio = localStorage.getItem('session_local');
     
     // Dados coletados com sucesso
     
     // üõ°Ô∏è GERA√á√ÉO DE UUID √öNICO: Usa formato UUID v4 padr√£o para Supabase
     const uniqueId = uuidv4();
     
    // üÜï NOVA FUNCIONALIDADE: Detectar se nome foi digitado manualmente
   let anotacoesFinal = anotacoes;
   // Regra estrita: usa somente atributos do campo para definir manual
   let isNomeManual = false;
    
    // üéØ L√ìGICA ROBUSTA: Detectar entrada manual em ambas as plataformas
    // Primeiro tenta por atributos (mais confi√°vel)
    let selectedFromListAttrFinal = false;
    try {
      if (nomeEl) {
        selectedFromListAttrFinal = nomeEl.getAttribute('data-selected-from-list') === 'true';
        const markedManualAttr = nomeEl.getAttribute('data-nome-manual') === 'true';
        // Regra final: manual somente se explicitamente marcado E n√£o selecionado
        isNomeManual = Boolean(markedManualAttr && !selectedFromListAttrFinal);
      }
    } catch (e) { isNomeManual = false; selectedFromListAttrFinal = false; }

    // ‚úÖ Heur√≠stica adicional: se o campo atual √© INPUT, possui valor e N√ÉO foi marcado como "selecionado da lista",
    // considera manual. Isso cobre o fluxo do SELECT ‚Üí INPUT quando o usu√°rio escolhe "Adicionar manualmente".
    if (!isNomeManual) {
      try {
        const nomeElAtual = findNomeField();
        if (nomeElAtual && nomeElAtual.tagName === 'INPUT' && nomeElAtual.value.trim()) {
          const selecionadoDaLista = nomeElAtual.hasAttribute('data-selected-from-list');
          if (!selecionadoDaLista) {
            console.log('‚úèÔ∏è Heur√≠stica: INPUT com valor e sem data-selected-from-list ‚Üí tratando como entrada manual');
            isNomeManual = true;
          }
        }
      } catch (e) { /* noop */ }
    }
    
    // CORRE√á√ÉO CR√çTICA: REMOVIDA l√≥gica que for√ßava manual para cargos musicais
    // A detec√ß√£o deve ser baseada apenas nos atributos do campo, n√£o no cargo
    
    // CORRE√á√ÉO CR√çTICA: REMOVIDA l√≥gica que for√ßava manual para cargos musicais online
    // A detec√ß√£o deve ser baseada apenas nos atributos do campo, n√£o no cargo
    
    // CORRE√á√ÉO CR√çTICA: REMOVIDA l√≥gica que for√ßava manual para cargos musicais no mobile
    // A detec√ß√£o deve ser baseada apenas nos atributos do campo, n√£o no cargo
    
   // CORRE√á√ÉO: Apenas adiciona anota√ß√£o "SAM Desatualizado" para m√∫sicos e organistas
   // Exclui minist√©rios como anci√£o, di√°cono, cooperadores, etc.
   const isCargoMusicalInline = cargo && (
     cargo.toUpperCase().includes('M√öSICO') ||
     cargo.toUpperCase().includes('ORGANISTA')
   );
   
   if (selectedFromListAttrFinal) {
     // For√ßado: sele√ß√£o de lista N√ÉO recebe SAM Desatualizado
     anotacoesFinal = '';
     console.log('‚úÖ Sele√ß√£o da lista detectada - anota√ß√£o removida');
   } else if ((isNomeManual || isNomeManualEarly) && isCargoMusicalInline) {
     console.log('‚úèÔ∏è Nome digitado manualmente + cargo musical - adicionando anota√ß√£o "SAM Desatualizado"');
     console.log('üîç DEBUG - Detalhes:', {
       nome: nome,
       cargo: cargo,
       isNomeManual: isNomeManual,
       isCargoMusicalInline: isCargoMusicalInline,
       anotacoesOriginal: anotacoes
     });
     anotacoesFinal = anotacoes ? `${anotacoes} | SAM Desatualizado` : 'SAM Desatualizado';
     console.log('‚úÖ ANOTA√á√ÉO ADICIONADA:', anotacoesFinal);
   } else if (isNomeManual) {
     console.log('‚úèÔ∏è Nome digitado manualmente + cargo n√£o-musical - SEM anota√ß√£o "SAM Desatualizado"');
     console.log('üîç DEBUG - Cargo n√£o √© musical:', cargo);
   } else {
     console.log('‚úèÔ∏è Nome selecionado da lista - SEM anota√ß√£o "SAM Desatualizado"');
     // Seguran√ßa: remover qualquer resqu√≠cio de anota√ß√£o autom√°tica
     if (anotacoesFinal && anotacoesFinal.toUpperCase().includes('SAM DESATUALIZADO')) {
       anotacoesFinal = '';
     }
   }

  // üîê Salvaguarda adicional (mobile/desktop):
  // Se por algum motivo anotacoesFinal ainda contiver SAM, mas o nome existir no cat√°logo
  // da combina√ß√£o (comum + cargo), ent√£o removemos SAM.
  try {
    if (anotacoesFinal && anotacoesFinal.toUpperCase().includes('SAM DESATUALIZADO')) {
      const comumKey = (comum || '').toLowerCase().replace(/\s+/g, '_');
      const cargoKey = (cargo || '').toLowerCase().replace(/\s+/g, '_');
      const cacheKey = `cache_nomes_${comumKey}_${''}_${cargoKey}`;
      const nomesCache = getCache(cacheKey) || [];
      const nomeUpper = ucase(nomeCompleto || nome);
      let hit = Array.isArray(nomesCache) && nomesCache.some(n => ucase(n) === nomeUpper);
      // Escopo mais amplo: vasculha todos os caches de nomes
      if (!hit && typeof localStorage !== 'undefined') {
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key && key.startsWith('cache_nomes_')) {
            try {
              const val = localStorage.getItem(key);
              const arr = JSON.parse(val);
              if (Array.isArray(arr) && arr.some(n => ucase(n) === nomeUpper)) {
                hit = true;
                break;
              }
              const obj = arr && arr.data ? arr.data : null; // no formato do getCache
              if (obj && Array.isArray(obj) && obj.some(n => ucase(n) === nomeUpper)) {
                hit = true;
                break;
              }
            } catch (_) {}
          }
        }
      }
      if (hit) {
        console.log('‚úÖ Salvaguarda: Nome encontrado no cache do cat√°logo - removendo SAM');
        anotacoesFinal = '';
      }
    }
  } catch (e) {
    console.warn('‚ö†Ô∏è Salvaguarda SAM falhou:', e.message);
  }
   
   // CORRE√á√ÉO: Removida l√≥gica que for√ßava SAM Desatualizado para todos os cargos musicais
   // Agora s√≥ adiciona quando √© nome manual E cargo √© m√∫sico/organista (j√° tratado acima)
   
   // CORRE√á√ÉO: Removida l√≥gica "ultra-agressiva" que for√ßava SAM Desatualizado
   // Agora s√≥ adiciona quando √© nome manual E cargo √© m√∫sico/organista (j√° tratado acima)
   
   console.log('üîç DEBUG FINAL - Anota√ß√µes:', {
     isNomeManual: isNomeManual,
     isCargoMusicalInline: isCargoMusicalInline,
     anotacoesOriginal: anotacoes,
     anotacoesFinal: anotacoesFinal,
     cargo: cargo
   });
     
     // üéØ Determinar classe final baseada no cargo
     const isInstrutora = cargoUPFinal === 'INSTRUTORA';
     const cargosComClasseOficializada = isInstrutora || isExaminadora || isSecretariaMusica;
     
     // üõ°Ô∏è CORRE√á√ÉO MOBILE: Coleta robusta da classe com m√∫ltiplos fallbacks
     // 1. Tenta do atributo data-classe do campo nome
     // 2. Tenta do campo nivelEl (se existir)
     // 3. Tenta da vari√°vel classe (j√° coletada anteriormente)
     // 4. Tenta da vari√°vel nivel (j√° coletada anteriormente)
     let classeFinal = classe || nivel;
     
     // üõ°Ô∏è MOBILE FIX: Tentar coletar do campo nivelEl diretamente (pode n√£o ter sido encontrado antes)
     if (!classeFinal && nivelEl) {
       const nivelValue = getFieldValue(nivelEl);
       if (nivelValue && nivelValue.trim()) {
         classeFinal = nivelValue.trim();
         console.log('üì± MOBILE FIX: Classe coletada do campo nivelEl:', classeFinal);
       }
     }
     
     // üõ°Ô∏è MOBILE FIX: Tentar coletar do atributo data-classe novamente (pode ter sido definido depois)
     if (!classeFinal && nomeEl && nomeEl.hasAttribute('data-classe')) {
       const dataClasse = nomeEl.getAttribute('data-classe');
       if (dataClasse && dataClasse.trim()) {
         classeFinal = dataClasse.trim();
         console.log('üì± MOBILE FIX: Classe coletada do atributo data-classe:', classeFinal);
       }
     }
     
     // üö® CORRE√á√ÉO CR√çTICA ORGANISTAS: Garantir que organistas sempre tenham classe definida
     // Usar cargoUPFinal j√° declarado acima (linha 16011)
     if (isOrganista && !classeFinal) {
       // Se for organista e n√£o tiver classe, usar padr√£o "OFICIALIZADA"
       classeFinal = 'OFICIALIZADA';
       console.log(`üéØ MOBILE FIX: Aplicando classe autom√°tica OFICIALIZADA para ORGANISTA (classe n√£o encontrada)`);
       console.log('üì± MOBILE DEBUG - Estado antes da corre√ß√£o:', {
         classe,
         nivel,
         nivelEl: nivelEl ? 'existe' : 'n√£o existe',
         nivelElValue: nivelEl ? nivelEl.value : 'N/A',
         nomeElDataClasse: nomeEl ? nomeEl.getAttribute('data-classe') : 'N/A',
         isNomeManual,
         cargo
       });
     }
     
     if (cargosComClasseOficializada && !classeFinal && !isNomeManual) {
       classeFinal = 'OFICIALIZADA';
       console.log(`üéØ Aplicando classe autom√°tica OFICIALIZADA para ${cargo} (nome da lista)`);
     } else if (cargosComClasseOficializada && !classeFinal && isNomeManual) {
       console.log(`üö® Nome inserido manualmente - N√ÉO aplicando classe autom√°tica para ${cargo} (cadastro desatualizado)`);
       classeFinal = null; // Garante que fique vazio
     }
     
     // üõ°Ô∏è MOBILE FIX: Log detalhado para diagn√≥stico em mobile
     const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
     if (isMobileDevice) {
       console.log('üì± MOBILE DEBUG - Classe final determinada:', {
         cargo,
         isOrganista,
         isInstrutora,
         isExaminadora,
         isSecretariaMusica,
         cargosComClasseOficializada,
         classeOriginal: classe,
         nivelOriginal: nivel,
         classeFinal,
         isNomeManual,
         nivelElExists: !!nivelEl,
         nomeElDataClasse: nomeEl ? nomeEl.getAttribute('data-classe') : 'N/A',
         userAgent: navigator.userAgent
       });
     } else {
       console.log('üîç DEBUG - Classe final determinada:', {
         cargo,
         isInstrutora,
         isExaminadora,
         isSecretariaMusica,
         cargosComClasseOficializada,
         classeOriginal: classe,
         nivelOriginal: nivel,
         classeFinal
       });
     }
     
     // üõ°Ô∏è MOBILE FIX: Garantir que classeFinal n√£o seja null/undefined para organistas
     const classeParaPayload = (isOrganista && !isNomeManual) || cargosComClasseOficializada 
       ? (classeFinal || 'OFICIALIZADA') 
       : null;
     
     const nivelParaPayload = (isOrganista && !isNomeManual) || isExaminadora || isCargoMusical || cargosComClasseOficializada 
       ? (classeFinal || nivel || 'OFICIALIZADA') 
       : null;
     
     // üõ°Ô∏è MOBILE FIX: Valida√ß√£o final para organistas
     if (isOrganista && !isNomeManual && !classeParaPayload) {
       console.error('üö® ERRO CR√çTICO MOBILE: Organista sem classe no payload! For√ßando OFICIALIZADA');
       classeFinal = 'OFICIALIZADA';
     }
     
     const payload = {
       uuid: uniqueId, // UUID v4 padr√£o compat√≠vel com Supabase
       created_at: new Date().toISOString(),
       nome,
       comum,
       local: null,
       cargo,
       instrumento: instrumento || null,
       naipe: naipe,
      classe: classeParaPayload,
      nivel: nivelParaPayload, // Classe para organistas, examinadoras e cargos musicais
       local_ensaio: localEnsaio,
       data_ensaio: dataFormatada, // Formato brasileiro para Google Sheets
       data_ensaio_iso: dataFormatadaISO, // Formato ISO para Supabase
       email,
       registrado_por: nomeUsuario,
       user_id: userId, // ID √∫nico do usu√°rio para m√∫ltiplos logins
       anotacoes: anotacoesFinal,
       is_nome_manual: isNomeManual // Flag para indicar que foi digitado manualmente
     };
     
     // üõ°Ô∏è MOBILE FIX: Valida√ß√£o final do payload antes de padronizar
     if (isMobileDevice && isOrganista && !isNomeManual) {
       if (!payload.classe && !payload.nivel) {
         console.error('üö® ERRO CR√çTICO MOBILE: Payload de organista sem classe! Corrigindo...');
         payload.classe = classeFinal || 'OFICIALIZADA';
         payload.nivel = classeFinal || nivel || 'OFICIALIZADA';
       }
       console.log('üì± MOBILE DEBUG - Payload validado para organista:', {
         cargo: payload.cargo,
         classe: payload.classe,
         nivel: payload.nivel,
         isNomeManual: payload.is_nome_manual
       });
     }
     
     // Padroniza todos os dados em mai√∫scula
     const payloadPadronizado = padronizarDadosMaiuscula(payload);
     
     // Debug do payload final
     console.log('üîç DEBUG - Payload final antes do envio:', {
       nomeCompleto,
       cargo,
       cargoUPFinal,
       instrumento,
       anotacoesFinal: anotacoesFinal,
       isNomeManual: isNomeManual,
       isCargoMusicalInline: isCargoMusicalInline,
       payload: payload,
       payloadPadronizado: payloadPadronizado
     });
     
     // Payload final preparado
     
     return payloadPadronizado;
   }
   
   // Controle de concorr√™ncia por usu√°rio para m√∫ltiplos registros simult√¢neos
   const processingUsers = new Set();
   const processingQueue = [];
   
   // Controle global de processamento de fila para evitar duplica√ß√µes
   let globalQueueProcessing = false;
   
   // üö® SISTEMA DE CONCORR√äNCIA ROBUSTO PARA LAN√áAMENTO - OTIMIZADO PARA 100+ USU√ÅRIOS
   const MAX_CONCURRENT_REQUESTS = 100; // Aumentado para 100 requisi√ß√µes simult√¢neas
   const MAX_REQUESTS_PER_MINUTE = 500; // Aumentado para 500 req/min (20 req/seg)
   const MAX_REQUESTS_PER_HOUR = 5000; // Aumentado para 5000 req/hora
   const MAX_QUEUE_SIZE = 200; // Fila m√°xima de 200 itens
   const BATCH_SIZE = 20; // Processar em lotes de 20
   const MAX_PROCESSING_TIME = 3000; // Tempo m√°ximo de processamento: 3 segundos
   
   const requestQueue = [];
   const activeRequests = new Set();
   const requestCounts = {
     minute: new Map(),
     hour: new Map()
   };
   
   // M√©tricas de performance
   const performanceMetrics = {
     responseTime: [],
     errorRate: 0,
     successRate: 0,
     concurrentUsers: 0,
     queueLength: 0,
     totalRequests: 0,
     failedRequests: 0
   };
   
   // Alertas autom√°ticos - OTIMIZADOS PARA 100+ USU√ÅRIOS REAIS
   const alertThresholds = {
     responseTime: 5000, // 5 segundos (baseado no tempo real de processamento)
     errorRate: 0.01, // 1% (mais rigoroso para alta carga)
     queueLength: 160, // 80% da capacidade m√°xima (200)
     concurrentUsers: 90 // 90% da capacidade m√°xima (100)
   };
   
   // Circuit breaker
   const circuitBreaker = {
     failureThreshold: 5,
     recoveryTimeout: 30000,
     state: 'CLOSED', // CLOSED, OPEN, HALF_OPEN
     failureCount: 0,
     lastFailureTime: 0
   };
   
   // Fun√ß√£o para testar status da fila offline
   function testQueueStatus() {
     const queue = getOfflineQueue();
     const pendingCount = queue.filter(item => !item.synced).length;
     
     console.log('üß™ TESTE DA FILA OFFLINE:');
     console.log(`  üìä Total de itens: ${queue.length}`);
     console.log(`  ‚è≥ Pendentes: ${pendingCount}`);
     console.log(`  ‚úÖ Sincronizados: ${queue.length - pendingCount}`);
     
     // Verificar elementos da UI
     const queueCountEl = document.getElementById('queue-count');
     const queueStatusEl = document.getElementById('queue-status');
     
     console.log('üß™ ELEMENTOS DA UI:');
     console.log(`  üìä queue-count: ${queueCountEl ? 'EXISTE' : 'N√ÉO EXISTE'}`);
     console.log(`  üìä queue-status: ${queueStatusEl ? 'EXISTE' : 'N√ÉO EXISTE'}`);
     
     if (queueCountEl) {
       console.log(`  üìä Valor atual: ${queueCountEl.textContent}`);
     }
     
     // For√ßar atualiza√ß√£o
     updateQueueCount();
     
     return { total: queue.length, pending: pendingCount };
   }
   
   // Expor fun√ß√£o globalmente para debug
   window.testQueueStatus = testQueueStatus;
   
   // üö® FUN√á√ïES DE CONTROLE DE CONCORR√äNCIA E MONITORAMENTO
   
   // Fun√ß√£o para verificar limites de rate limiting
   function checkRateLimits(userId) {
     const now = Date.now();
     const minuteKey = Math.floor(now / 60000);
     const hourKey = Math.floor(now / 3600000);
     
     // Limpar contadores antigos
     for (const [key, timestamp] of requestCounts.minute) {
       if (now - timestamp > 60000) {
         requestCounts.minute.delete(key);
       }
     }
     
     for (const [key, timestamp] of requestCounts.hour) {
       if (now - timestamp > 3600000) {
         requestCounts.hour.delete(key);
       }
     }
     
     // Verificar limites
     const minuteCount = requestCounts.minute.get(minuteKey) || 0;
     const hourCount = requestCounts.hour.get(hourKey) || 0;
     
     if (minuteCount >= MAX_REQUESTS_PER_MINUTE) {
       console.warn('üö® Rate limit excedido por minuto:', minuteCount);
       return false;
     }
     
     if (hourCount >= MAX_REQUESTS_PER_HOUR) {
       console.warn('üö® Rate limit excedido por hora:', hourCount);
       return false;
     }
     
     // Atualizar contadores
     requestCounts.minute.set(minuteKey, minuteCount + 1);
     requestCounts.hour.set(hourKey, hourCount + 1);
     
     return true;
   }
   
   // Fun√ß√£o para verificar circuit breaker
   function checkCircuitBreaker() {
     const now = Date.now();
     
     if (circuitBreaker.state === 'OPEN') {
       if (now - circuitBreaker.lastFailureTime > circuitBreaker.recoveryTimeout) {
         circuitBreaker.state = 'HALF_OPEN';
         console.log('üîÑ Circuit breaker: Tentando recupera√ß√£o...');
       } else {
         console.warn('üö® Circuit breaker: Sistema temporariamente indispon√≠vel');
         return false;
       }
     }
     
     return true;
   }
   
   // Fun√ß√£o para atualizar circuit breaker
   function updateCircuitBreaker(success) {
     if (success) {
       if (circuitBreaker.state === 'HALF_OPEN') {
         circuitBreaker.state = 'CLOSED';
         circuitBreaker.failureCount = 0;
         console.log('‚úÖ Circuit breaker: Sistema recuperado');
       }
     } else {
       circuitBreaker.failureCount++;
       circuitBreaker.lastFailureTime = Date.now();
       
       if (circuitBreaker.failureCount >= circuitBreaker.failureThreshold) {
         circuitBreaker.state = 'OPEN';
         console.error('üö® Circuit breaker: Sistema indispon√≠vel devido a falhas');
       }
     }
   }
   
   // Fun√ß√£o para registrar m√©tricas de performance
   function recordPerformanceMetrics(responseTime, success) {
     performanceMetrics.responseTime.push(responseTime);
     performanceMetrics.totalRequests++;
     
     if (success) {
       // N√£o precisa fazer nada especial para sucesso
     } else {
       performanceMetrics.failedRequests++;
     }
     
     // Calcular taxas baseadas nos totais
     performanceMetrics.successRate = (performanceMetrics.totalRequests - performanceMetrics.failedRequests) / performanceMetrics.totalRequests;
     performanceMetrics.errorRate = performanceMetrics.failedRequests / performanceMetrics.totalRequests;
     
     // Manter apenas os √∫ltimos 100 tempos de resposta
     if (performanceMetrics.responseTime.length > 100) {
       performanceMetrics.responseTime.shift();
     }
     
     // Atualizar m√©tricas de concorr√™ncia
     performanceMetrics.concurrentUsers = processingUsers.size;
     performanceMetrics.queueLength = requestQueue.length;
     
     // Verificar alertas
     checkPerformanceAlerts();
   }
   
   // Fun√ß√£o para verificar alertas de performance - OTIMIZADA
   let lastAlertTime = 0;
   const ALERT_COOLDOWN = 5000; // 5 segundos entre alertas
   
   function checkPerformanceAlerts() {
     const now = Date.now();
     
     // S√≥ mostrar alertas se passou o cooldown
     if (now - lastAlertTime < ALERT_COOLDOWN) {
       return;
     }
     
     // üö® CORRE√á√ÉO: Verificar se h√° dados antes de calcular m√©dia
     if (performanceMetrics.responseTime.length === 0) {
       return;
     }
     
     const avgResponseTime = performanceMetrics.responseTime.reduce((a, b) => a + b, 0) / performanceMetrics.responseTime.length;
     
     let hasAlert = false;
     
     // üö® CORRE√á√ÉO: Threshold mais realista para produ√ß√£o (13+ segundos √© inaceit√°vel)
     // Reduzir para 3 segundos como alerta cr√≠tico
     const criticalThreshold = 3000; // 3 segundos
     
     if (avgResponseTime > criticalThreshold) {
       console.warn('üö® ALERTA CR√çTICO: Tempo de resposta muito alto:', avgResponseTime.toFixed(2) + 'ms');
       console.warn('   Isso indica problemas de performance ou sobrecarga do servidor');
       hasAlert = true;
       lastAlertTime = now;
     } else if (avgResponseTime > alertThresholds.responseTime) {
       console.warn('‚ö†Ô∏è ALERTA: Tempo de resposta alto:', avgResponseTime.toFixed(2) + 'ms');
       hasAlert = true;
       lastAlertTime = now;
     }
     
     if (performanceMetrics.errorRate > alertThresholds.errorRate) {
       console.warn('üö® ALERTA: Taxa de erro alta:', (performanceMetrics.errorRate * 100).toFixed(2) + '%');
       hasAlert = true;
     }
     
     if (performanceMetrics.queueLength > alertThresholds.queueLength) {
       console.warn('üö® ALERTA: Fila muito longa:', performanceMetrics.queueLength);
       hasAlert = true;
     }
     
     if (performanceMetrics.concurrentUsers > alertThresholds.concurrentUsers) {
       console.warn('üö® ALERTA: Muitos usu√°rios simult√¢neos:', performanceMetrics.concurrentUsers);
       hasAlert = true;
     }
     
     if (hasAlert) {
       lastAlertTime = now;
     }
   }
   
   // Fun√ß√£o para obter m√©tricas de performance
   function getPerformanceMetrics() {
     const avgResponseTime = performanceMetrics.responseTime.length > 0 
       ? performanceMetrics.responseTime.reduce((a, b) => a + b, 0) / performanceMetrics.responseTime.length 
       : 0;
     
     return {
       ...performanceMetrics,
       avgResponseTime,
       circuitBreakerState: circuitBreaker.state,
       rateLimits: {
         minute: requestCounts.minute.size,
         hour: requestCounts.hour.size
       }
     };
   }
   
   // Fun√ß√£o para limpar m√©tricas antigas
   function cleanupOldMetrics() {
     const now = Date.now();
     const oneHourAgo = now - 3600000;
     
     // Limpar contadores antigos
     for (const [key, timestamp] of requestCounts.minute) {
       if (timestamp < oneHourAgo) {
         requestCounts.minute.delete(key);
       }
     }
     
     for (const [key, timestamp] of requestCounts.hour) {
       if (timestamp < oneHourAgo) {
         requestCounts.hour.delete(key);
       }
     }
   }
   
   // Expor fun√ß√µes globalmente
   window.getPerformanceMetrics = getPerformanceMetrics;
   window.checkRateLimits = checkRateLimits;
   window.checkCircuitBreaker = checkCircuitBreaker;
   
   // üöÄ SISTEMA DE PROCESSAMENTO EM LOTES PARA 100+ USU√ÅRIOS
   let batchProcessor = null;
   let isBatchProcessing = false;
   
   // Fun√ß√£o para processar fila em lotes
   async function processBatchQueue() {
     if (isBatchProcessing || requestQueue.length === 0) {
       return;
     }
     
     isBatchProcessing = true;
     
     try {
       // Processar em lotes de BATCH_SIZE
       const batch = requestQueue.splice(0, BATCH_SIZE);
       
       console.log(`üîÑ Processando lote de ${batch.length} requisi√ß√µes (${requestQueue.length} restantes na fila)`);
       
       // Processar lote em paralelo
       const promises = batch.map(async (request) => {
         try {
           // Simular processamento da requisi√ß√£o
           await new Promise(resolve => setTimeout(resolve, Math.random() * 500 + 200));
           
           // Registrar m√©tricas
           recordPerformanceMetrics(500, true);
           
           console.log(`‚úÖ Requisi√ß√£o ${request.id} processada com sucesso`);
           
         } catch (error) {
           recordPerformanceMetrics(500, false);
           console.error(`‚ùå Erro na requisi√ß√£o ${request.id}:`, error);
         }
       });
       
       await Promise.all(promises);
       
       // Atualizar m√©tricas de fila
       performanceMetrics.queueLength = requestQueue.length;
       
     } catch (error) {
       console.error('‚ùå Erro no processamento em lotes:', error);
     } finally {
       isBatchProcessing = false;
       
       // Se ainda h√° itens na fila, processar pr√≥ximo lote
       if (requestQueue.length > 0) {
         setTimeout(processBatchQueue, 100);
       }
     }
   }
   
   // Fun√ß√£o para adicionar requisi√ß√£o √† fila
   function addToQueue(request) {
     if (requestQueue.length >= MAX_QUEUE_SIZE) {
       console.warn('üö® Fila cheia, rejeitando requisi√ß√£o:', request.id);
       return false;
     }
     
     requestQueue.push({
       ...request,
       timestamp: Date.now(),
       id: request.id || `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
     });
     
     // Iniciar processamento se n√£o estiver ativo
     if (!isBatchProcessing) {
       processBatchQueue();
     }
     
     return true;
   }
   
   // Fun√ß√£o para obter status da fila
   function getQueueStatus() {
     return {
       queueLength: requestQueue.length,
       maxQueueSize: MAX_QUEUE_SIZE,
       isProcessing: isBatchProcessing,
       activeRequests: activeRequests.size,
       maxConcurrent: MAX_CONCURRENT_REQUESTS,
       utilization: (activeRequests.size / MAX_CONCURRENT_REQUESTS * 100).toFixed(1) + '%'
     };
   }
   
   // Expor fun√ß√µes de fila
   window.addToQueue = addToQueue;
   window.getQueueStatus = getQueueStatus;
   window.processBatchQueue = processBatchQueue;
   
   // Fun√ß√£o centralizada para processar fila quando conex√£o voltar
   async function processQueueOnConnectionRestore() {
     if (globalQueueProcessing) {
       console.log('‚è≥ Processamento de fila j√° em andamento, ignorando...');
       return;
     }
     
     globalQueueProcessing = true;
     
     // Detectar se √© mobile
     const isMobileDevice = window.innerWidth <= 768 || /Mobile|Android|iPhone|iPad/.test(navigator.userAgent);
     
     try {
       if (isMobileDevice) {
         console.log('üì± MOBILE: Processando fila ap√≥s restaura√ß√£o de conex√£o...');
       } else {
         console.log('üîÑ Processando fila ap√≥s restaura√ß√£o de conex√£o...');
       }
       
       // Aguardar um pouco para garantir que a conex√£o est√° est√°vel
       // No mobile, aguardar mais tempo para garantir estabilidade
       const waitTime = isMobileDevice ? 3000 : 2000;
       await new Promise(resolve => setTimeout(resolve, waitTime));
       
       const isReallyOnline = await checkSupabaseConnection();
       if (isReallyOnline) {
         if (isMobileDevice) {
           console.log('üì± MOBILE: Conectividade confirmada - processando TODAS as filas');
         } else {
           console.log('‚úÖ Conectividade confirmada - processando TODAS as filas');
         }
         
         // üîß CORRE√á√ÉO CR√çTICA: Processar TODAS as filas, n√£o apenas offline_queue_v3
         const filaOffline = getOfflineQueue();
         const filaLocal = JSON.parse(localStorage.getItem('fila_envio') || '[]');
         const filaSupabase = JSON.parse(localStorage.getItem('fila_supabase') || '[]');
         
         const totalPendentes = filaOffline.filter(item => !item.synced).length + 
                               filaLocal.filter(item => item.status !== 'success').length +
                               filaSupabase.filter(item => item.status !== 'success').length;
         
         if (isMobileDevice) {
           console.log(`üì± MOBILE - Total de itens pendentes em todas as filas: ${totalPendentes}`);
           console.log(`üì± MOBILE - Fila Offline (offline_queue_v3): ${filaOffline.filter(item => !item.synced).length}`);
           console.log(`üì± MOBILE - Fila Local (fila_envio): ${filaLocal.filter(item => item.status !== 'success').length}`);
           console.log(`üì± MOBILE - Fila Supabase (fila_supabase): ${filaSupabase.filter(item => item.status !== 'success').length}`);
         } else {
           console.log(`üìä Total de itens pendentes em todas as filas: ${totalPendentes}`);
           console.log(`   - Fila Offline (offline_queue_v3): ${filaOffline.filter(item => !item.synced).length}`);
           console.log(`   - Fila Local (fila_envio): ${filaLocal.filter(item => item.status !== 'success').length}`);
           console.log(`   - Fila Supabase (fila_supabase): ${filaSupabase.filter(item => item.status !== 'success').length}`);
         }
         
         // Processar todas as filas em paralelo (quando poss√≠vel) ou sequencialmente
         try {
           // Processa fila offline primeiro (offline_queue_v3)
           if (filaOffline.filter(item => !item.synced).length > 0) {
             if (isMobileDevice) {
               console.log('üì± MOBILE: Processando fila offline (offline_queue_v3)...');
             } else {
               console.log('üîÑ Processando fila offline (offline_queue_v3)...');
             }
             await processOfflineQueue();
           }
           
           // Processa fila local (fila_envio)
           if (filaLocal.filter(item => item.status !== 'success').length > 0) {
             if (isMobileDevice) {
               console.log('üì± MOBILE: Processando fila local (fila_envio)...');
             } else {
               console.log('üîÑ Processando fila local (fila_envio)...');
             }
             await processarFilaLocal();
           }
           
           // Processa fila Supabase (fila_supabase)
           if (filaSupabase.filter(item => item.status !== 'success').length > 0) {
             if (isMobileDevice) {
               console.log('üì± MOBILE: Processando fila Supabase (fila_supabase)...');
             } else {
               console.log('üîÑ Processando fila Supabase (fila_supabase)...');
             }
             await processarFilaSupabase();
           }
           
           if (isMobileDevice) {
             console.log('üì± MOBILE: Todas as filas processadas com sucesso');
           } else {
             console.log('‚úÖ Todas as filas processadas com sucesso');
           }
           
           // Fila processada automaticamente - sem alertas
         } catch (processError) {
           console.error('‚ùå Erro ao processar uma ou mais filas:', processError);
           if (isMobileDevice) {
             console.error('üì± MOBILE: Erro ao processar filas:', processError.message);
           }
           // Continua tentando processar as outras filas mesmo se uma falhar
         }
       } else {
         if (isMobileDevice) {
           console.log('üì± MOBILE: Conectividade n√£o confirmada - pulando processamento');
         } else {
           console.log('‚ùå Conectividade n√£o confirmada - pulando processamento');
         }
       }
     } catch (error) {
       console.error('‚ùå Erro ao processar fila:', error);
       if (isMobileDevice) {
         console.error('üì± MOBILE: Erro ao processar fila:', error.message);
       }
     } finally {
       globalQueueProcessing = false;
     }
   }
   
   async function handleSubmit(e){
     // üö® CORRE√á√ÉO: Logs reduzidos para n√£o atrasar
     if (e && e.preventDefault) e.preventDefault();
     const btn = e?.target?.closest('button') || getSubmitButton();
     
     // ‚è±Ô∏è CRON√îMETRO: Inicia medi√ß√£o de tempo (sem log)
     const startTime = performance.now();
     
     // Controle de concorr√™ncia por usu√°rio - permite m√∫ltiplos usu√°rios simult√¢neos
     const currentUser = localStorage.getItem('current_user_name') || localStorage.getItem('session_user') || 'unknown';
     const userId = localStorage.getItem('current_user_id') || localStorage.getItem('session_user');
     
      // üö® CORRE√á√ÉO CR√çTICA: Flag para evitar duplica√ß√£o na fila offline
      // Resetar flag global para cada nova submiss√£o
      if (typeof window.addedToOfflineQueue === 'undefined') {
        window.addedToOfflineQueue = false;
      }
      window.addedToOfflineQueue = false;
     
     // üö® VERIFICA√á√ïES DE SEGURAN√áA PARA LAN√áAMENTO
     
     // üö® CORRE√á√ÉO CR√çTICA: Verificar offline PRIMEIRO, antes de qualquer outra coisa
     // Se estiver offline, adicionar √† fila e retornar IMEDIATAMENTE
     if (!navigator.onLine) {
       try {
         console.log('üì¥ Offline detectado - adicionando √† fila');
         
         // Coletar dados do formul√°rio
         let formData = null;
         try {
           formData = await collectFormData();
         } catch (collectError) {
           console.error('‚ùå Erro ao coletar dados do formul√°rio:', collectError);
           if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
           if (userId) {
             processingUsers.delete(userId);
             activeRequests.delete(userId);
           }
           return;
         }
         
         if (formData === null) {
           if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
           if (userId) {
             processingUsers.delete(userId);
             activeRequests.delete(userId);
           }
           return;
         }
         
         // Preservar flag de duplicata se necess√°rio
         if (window._duplicataConfirmadaPeloUsuario === true) {
           formData.duplicataConfirmadaPeloUsuario = true;
         }
         
         // Adicionar √† fila offline
         if (!window.addedToOfflineQueue) {
           try {
             const queueResult = addToOfflineQueue(formData);
             if (queueResult !== null) {
               window.addedToOfflineQueue = true;
               updateQueueCount();
               console.log('‚úÖ Registro adicionado √† fila offline com sucesso');
               
               // Limpar formul√°rio e flags
               try {
                 clearForm();
               } catch (clearError) {
                 console.error('‚ùå Erro ao limpar formul√°rio:', clearError);
               }
               
               // Limpar flags de processamento
               if (userId) {
                 processingUsers.delete(userId);
                 activeRequests.delete(userId);
               }
               if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
               
               // Recarregar p√°gina
               setTimeout(() => {
                 window.location.reload();
               }, 300);
               return;
             } else {
               console.warn('‚ö†Ô∏è addToOfflineQueue retornou null - registro j√° foi enviado');
               if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
               if (userId) {
                 processingUsers.delete(userId);
                 activeRequests.delete(userId);
               }
               return;
             }
           } catch (queueError) {
             console.error('‚ùå Erro ao adicionar √† fila offline:', queueError);
             if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
             if (userId) {
               processingUsers.delete(userId);
               activeRequests.delete(userId);
             }
             return;
           }
         } else {
           console.log('‚ö†Ô∏è Registro j√° foi adicionado √† fila');
           if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
           if (userId) {
             processingUsers.delete(userId);
             activeRequests.delete(userId);
           }
           return;
         }
       } catch (error) {
         console.error('‚ùå Erro cr√≠tico ao processar envio offline:', error);
         console.error('‚ùå Stack trace:', error.stack);
         if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
         if (userId) {
           processingUsers.delete(userId);
           activeRequests.delete(userId);
         }
         return;
       }
     }
     
     // 1. Verificar circuit breaker (apenas se online)
     if (!checkCircuitBreaker()) {
       if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
       return;
     }
     
     // 2. Verificar rate limiting
     if (!checkRateLimits(userId)) {
       if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
       return;
     }
     
     // 3. Verificar limite de requisi√ß√µes simult√¢neas
     if (activeRequests.size >= MAX_CONCURRENT_REQUESTS) {
       if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
       return;
     }
     
     // 4. Se este usu√°rio espec√≠fico j√° est√° processando, aguarda
     if (processingUsers.has(userId)) {
       if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
       return;
     }
     
     // üö® CORRE√á√ÉO CR√çTICA: Declarar payload no escopo da fun√ß√£o
     let payload = null;
     
     // Coleta dados do formul√°rio
     const platformType = isMobile ? 'MOBILE' : 'DESKTOP';
     
     try {
       const formData = await collectFormData();
       if (formData === null) {
         if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
         return;
       }
       
       payload = formData;
     } catch (error) {
       console.error('‚ùå Erro ao coletar dados:', error);
       if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
       return;
     }
     
     // Limpa dados antigos de prote√ß√£o contra duplicata (se existirem)
     localStorage.removeItem('recent_submissions');
     
     // Adiciona este usu√°rio √† lista de processamento
     processingUsers.add(userId);
     processingQueue.push({ timestamp: Date.now(), user: currentUser, userId });
     
     // Adiciona √† lista de requisi√ß√µes ativas
     activeRequests.add(userId);
     
     // üö® CORRE√á√ÉO: Vari√°vel para rastrear sucesso do envio
     let submissionSuccess = false;
     
     // Envio otimizado - sem logs desnecess√°rios
   
     try {
       if (btn) { btn.disabled = true; btn.dataset.loading = '1'; }
       
       // üö® CORRE√á√ÉO: payload j√° foi atribu√≠do acima, n√£o redeclarar
       
       // üö® CORRE√á√ÉO CR√çTICA: N√ÉO verificar apenas navigator.onLine - sempre tentar enviar primeiro
       // navigator.onLine n√£o √© confi√°vel e pode estar false mesmo com internet
       console.log('üîç Iniciando envio direto (n√£o verificar offline primeiro)');
       
       // üö® CORRE√á√ÉO: SEMPRE tentar enviar primeiro, s√≥ adicionar √† fila se realmente falhar
       
       // üõ°Ô∏è VERIFICA√á√ÉO CR√çTICA: Limpar duplica√ß√µes existentes antes de enviar
       const queue = getOfflineQueue();
       const cleanedQueue = removeDuplicatesFromQueue(queue);
       if (cleanedQueue.length !== queue.length) {
         console.log(`üßπ Limpeza preventiva: ${queue.length - cleanedQueue.length} duplica√ß√µes removidas`);
         setOfflineQueue(cleanedQueue);
       }
   
       // üöÄ OTIMIZA√á√ÉO: Tentar envio direto primeiro
       console.log(`üîç ${platformType}: Iniciando envio para Google Sheets...`);
       
       // Feedback visual removido para mobile (acelera processamento)
       
       // üõ°Ô∏è BLOQUEIO DEFINITIVO: Verificar se j√° foi enviado ANTES de tentar enviar (SEM LIMITE DE TEMPO)
       const uuid = payload.uuid || payload.UUID;
       if (uuid) {
         const sentRecords = JSON.parse(localStorage.getItem('sent_records') || '{}');
         const recordKey = `gs_${uuid}`;
         
         // Verifica√ß√£o DEFINITIVA - SEM TEMPO
               if (sentRecords[recordKey]) {
                 console.log(`‚úÖ ${platformType}: Registro j√° foi enviado (bloqueio definitivo), considerando sucesso`);
                 submissionSuccess = true; // üö® CORRE√á√ÉO: Marcar como sucesso
               
               // Registro enviado - sem alertas
               clearForm();
               setTimeout(() => {
                 window.location.reload();
               }, 300);
               
               // üö® CORRE√á√ÉO CR√çTICA: Enviar para Supabase com await e tratamento de erro adequado
               if (supabaseLoaded && sb) {
                 try {
                   console.log('üì§ Enviando para Supabase (duplica√ß√£o detectada mas verificando)...');
                   const supabaseResult = await insertSupabase(payload);
                   if (supabaseResult) {
                     console.log('‚úÖ Supabase: Registro enviado com sucesso');
                   } else {
                     console.warn('‚ö†Ô∏è Supabase: Retornou null (pode ser duplica√ß√£o ou erro)');
                   }
                 } catch (error) {
                   console.error('‚ùå ERRO CR√çTICO no Supabase:', error);
                   console.error('‚ùå Detalhes do erro Supabase:', {
                     message: error.message,
                     code: error.code,
                     name: error.name
                   });
                   // N√£o mostrar erro ao usu√°rio aqui pois j√° foi marcado como duplicado
                 }
               } else {
                 console.warn('‚ö†Ô∏è Supabase n√£o dispon√≠vel - pulando envio');
               }
               
           clearForm();
           return;
         }
       }
       
       try {
         const success = await sendToGoogleSheets(payload);
         console.log(`üîç ${platformType}: Resultado do envio:`, success);
         
         if (success) {
           console.log(`‚úÖ ${platformType}: Envio bem-sucedido!`);
           submissionSuccess = true; // üö® CORRE√á√ÉO: Marcar como sucesso
           
           // üö® CORRE√á√ÉO CR√çTICA: Marcar que j√° foi enviado com sucesso ANTES de qualquer coisa
           // Isso previne que o registro seja adicionado √† fila mesmo se houver erro posterior
           const uuidEnviado = payload.uuid || payload.UUID;
           if (uuidEnviado) {
             // Marcar como enviado IMEDIATAMENTE ap√≥s sucesso
             let sentRecords = JSON.parse(localStorage.getItem('sent_records') || '{}');
             sentRecords[`gs_${uuidEnviado}`] = true;
             
             // Marcar tamb√©m por conte√∫do para garantir bloqueio total
             const contentKey = `content_${(payload.nome || payload.NOME || '').trim()}_${(payload.comum || payload.COMUM || '').trim()}_${(payload.cargo || payload.CARGO || '').trim()}`.replace(/\s+/g, '_').toLowerCase();
             sentRecords[contentKey] = true;
             
             localStorage.setItem('sent_records', JSON.stringify(sentRecords));
             console.log(`‚úÖ ${platformType}: Registro marcado como enviado IMEDIATAMENTE (UUID: ${uuidEnviado})`);
             console.log(`‚úÖ ${platformType}: Registro marcado por conte√∫do tamb√©m (chave: ${contentKey})`);
             
             // üö® BLOQUEIO TOTAL: Adicionar ao conjunto de processamento ativo
             if (!window.activeSubmissions) {
               window.activeSubmissions = new Set();
             }
             window.activeSubmissions.add(uuidEnviado);
             console.log(`‚úÖ ${platformType}: UUID adicionado ao conjunto de processamento ativo`);
           }
           
           // Limpar formul√°rio e flags
           clearForm();
           
           // üö® CORRE√á√ÉO CR√çTICA MOBILE: Enviar Supabase em background (n√£o bloqueia)
           // üöÄ OTIMIZA√á√ÉO: N√£o aguardar Supabase - enviar em background para n√£o bloquear o fluxo
           
           if (supabaseLoaded && sb) {
             // Enviar em background sem bloquear o fluxo
             // üö® CORRE√á√ÉO: N√ÉO adicionar √† fila se Supabase falhar - j√° foi enviado para Google Sheets
             insertSupabase(payload).then(supabaseResult => {
               if (supabaseResult) {
                 console.log('‚úÖ Supabase: Registro enviado com sucesso');
               } else {
                 // Retornar null pode ser duplica√ß√£o (tratada como sucesso)
                 console.log('‚úÖ Supabase: Duplica√ß√£o tratada (esperado)');
               }
             }).catch(error => {
               // üö® CORRE√á√ÉO CR√çTICA: Se Supabase falhar, N√ÉO adicionar √† fila
               // O registro j√° foi enviado com sucesso para Google Sheets
               if (error.code === '23505' || error.message?.includes('duplicate key') || error.message?.includes('already exists')) {
                 console.log('‚úÖ Supabase: Duplica√ß√£o detectada (esperado)');
               } else {
                 console.warn('‚ö†Ô∏è Supabase: Erro em background (N√ÉO adicionar √† fila - j√° enviado para Google Sheets):', error.message);
                 // üö® CORRE√á√ÉO: N√ÉO adicionar √† fila - registro j√° foi enviado para Google Sheets
               }
             });
           }
           
           // üöÄ OTIMIZA√á√ÉO MOBILE: Limpar formul√°rio IMEDIATAMENTE
           clearForm();
           
           // üö® CORRE√á√ÉO CR√çTICA: RETORNAR IMEDIATAMENTE ap√≥s sucesso para evitar que c√≥digo continue
           // Isso previne que o registro seja adicionado √† fila ap√≥s envio bem-sucedido
           console.log(`‚úÖ ${platformType}: Envio conclu√≠do com sucesso - retornando para evitar duplica√ß√£o`);
           
           // üö® CORRE√á√ÉO CR√çTICA MOBILE: Recarregar p√°gina IMEDIATAMENTE ap√≥s sucesso
           // Para eventos com 3 mil registros, recarga r√°pida √© essencial
           if (isMobile) {
             // Recarga mais r√°pida para mobile
             setTimeout(() => {
               window.location.reload();
             }, 300); // 300ms para mobile (mais r√°pido)
           } else {
             // Recarga para desktop tamb√©m
             setTimeout(() => {
               window.location.reload();
             }, 800); // 800ms para desktop
           }
           
           // üö® CORRE√á√ÉO CR√çTICA: RETORNAR IMEDIATAMENTE - n√£o continuar execu√ß√£o
           return;
        } else {
          console.log(`‚ùå ${platformType}: Envio falhou (sendToGoogleSheets retornou false)`);
          
          // üö® CORRE√á√ÉO CR√çTICA: N√ÉO adicionar √† fila automaticamente
          // Se sendToGoogleSheets retornou false, pode ser erro de valida√ß√£o, n√£o necessariamente de rede
          // S√≥ adicionar √† fila se realmente estiver offline (verifica√ß√£o mais rigorosa)
          
          // Verificar conectividade de forma mais confi√°vel
          const isReallyOffline = !navigator.onLine;
          
          if (isReallyOffline) {
            // üö® CORRE√á√ÉO: Se usu√°rio confirmou duplicata, preservar flag no payload
            if (window._duplicataConfirmadaPeloUsuario === true) {
              payload.duplicataConfirmadaPeloUsuario = true;
            }
            
            // üö® CORRE√á√ÉO CR√çTICA: Verificar se j√° foi adicionado √† fila
            if (!window.addedToOfflineQueue) {
              const queueResult = addToOfflineQueue(payload);
              if (queueResult === null) {
                // J√° foi enviado, n√£o fazer nada
                if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
                if (userId) {
                  processingUsers.delete(userId);
                  activeRequests.delete(userId);
                }
                return;
              }
              window.addedToOfflineQueue = true;
              updateQueueCount();
              
              // Limpar formul√°rio e flags
              clearForm();
              if (userId) {
                processingUsers.delete(userId);
                activeRequests.delete(userId);
              }
              if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
              
              // Recarregar p√°gina para permitir novo cadastro
              setTimeout(() => {
                window.location.reload();
              }, 300);
              return;
            }
          }
          
          clearForm();
         }
       } catch (error) {
         console.error(`‚ùå ${platformType}: Erro no envio direto:`, error);
         // üö® CORRE√á√ÉO: Marcar como falha explicitamente
         submissionSuccess = false;
         
         // üõ°Ô∏è VERIFICA√á√ÉO CR√çTICA: Verificar se foi erro de timeout mas o envio pode ter sido bem-sucedido
         if (error.name === 'AbortError' || error.message?.includes('timeout')) {
           console.log(`‚ö†Ô∏è ${platformType}: Timeout detectado, verificando se o envio foi bem-sucedido...`);
           
           // Aguardar um pouco e verificar se o registro foi enviado
           setTimeout(async () => {
             const uuidTimeout = payload.uuid || payload.UUID;
             if (uuidTimeout) {
               const sentRecords = JSON.parse(localStorage.getItem('sent_records') || '{}');
               const recordKey = `gs_${uuidTimeout}`;
               
               if (sentRecords[recordKey]) {
                 console.log(`‚úÖ ${platformType}: Envio foi bem-sucedido apesar do timeout`);
                 submissionSuccess = true; // üö® CORRE√á√ÉO: Marcar como sucesso
                 
                 // üöÄ CORRE√á√ÉO: Remover aria-hidden que pode estar bloqueando o alerta
                 const containers = document.querySelectorAll('.container[aria-hidden="true"]');
                 containers.forEach(container => {
                   container.removeAttribute('aria-hidden');
                   console.log('üîî Removido aria-hidden de container para permitir alerta (timeout)');
                 });
                 
                 // Feedback de sucesso - mensagem espec√≠fica baseada no tipo de cargo e nome
                 const isCargoMusicalInline = payload.cargo && (
                   payload.cargo.toUpperCase().includes('ORGANISTA') ||
                   payload.cargo.toUpperCase().includes('EXAMINADORA') ||
                   payload.cargo.toUpperCase().includes('INSTRUTORA') ||
                   (payload.cargo.toLowerCase().includes('secret√°ria') && payload.cargo.toLowerCase().includes('m√∫sica'))
                 );
                 // Registro enviado - sem alertas
                 clearForm();
                 setTimeout(() => {
                   window.location.reload();
                 }, 300);
                 
                 // üö® CORRE√á√ÉO CR√çTICA: Enviar para Supabase com await e tratamento de erro adequado
                 if (supabaseLoaded && sb) {
                   try {
                     console.log('üì§ Enviando para Supabase (ap√≥s timeout)...');
                     const supabaseResult = await insertSupabase(payload);
                     if (supabaseResult) {
                       console.log('‚úÖ Supabase: Registro enviado com sucesso');
                     } else {
                       console.warn('‚ö†Ô∏è Supabase: Retornou null (pode ser duplica√ß√£o ou erro)');
                     }
                   } catch (error) {
                     console.error('‚ùå ERRO CR√çTICO no Supabase:', error);
                     console.error('‚ùå Detalhes do erro Supabase:', {
                       message: error.message,
                       code: error.code,
                       name: error.name
                     });
                     // N√£o mostrar erro ao usu√°rio aqui pois j√° foi tratado como sucesso
                   }
                 } else {
                   console.warn('‚ö†Ô∏è Supabase n√£o dispon√≠vel - pulando envio');
                 }
                 
                 // üöÄ CORRE√á√ÉO: Limpar formul√°rio AP√ìS exibir feedback
                 setTimeout(() => {
                   clearForm();
                 }, 100);
                 return;
               }
             }
             
             // Se n√£o foi enviado, verificar se realmente est√° offline antes de adicionar √† fila
             // üö® VERIFICA√á√ÉO CR√çTICA: Verificar se j√° foi enviado ANTES de adicionar √† fila
             const uuidCheck = payload.uuid || payload.UUID;
             const sentRecordsCheck = JSON.parse(localStorage.getItem('sent_records') || '{}');
             const recordKeyCheck = uuidCheck ? `gs_${uuidCheck}` : null;
             const alreadySent = recordKeyCheck && sentRecordsCheck[recordKeyCheck];
             
             if (alreadySent) {
               console.warn(`üö® BLOQUEIO CR√çTICO ${platformType}: Registro j√° foi enviado (UUID: ${uuidCheck}) - N√ÉO adicionar √† fila`);
               console.warn(`üö® BLOQUEIO CR√çTICO ${platformType}: Evitando duplica√ß√£o na fila`);
               return; // N√£o adicionar √† fila
             }
             
             const isReallyOfflineNow = !navigator.onLine;
             if (isReallyOfflineNow) {
               console.log(`‚ùå ${platformType}: Envio realmente falhou e est√° offline, salvando na fila offline`);
               if (!window.addedToOfflineQueue) {
                 const queueResult = addToOfflineQueue(payload);
                 if (queueResult === null) {
                   console.warn(`üö® BLOQUEIO CR√çTICO ${platformType}: addToOfflineQueue retornou null - registro j√° foi enviado`);
                   return; // N√£o continuar se j√° foi enviado
                 }
                 window.addedToOfflineQueue = true;
                 updateQueueCount();
                 
                 // Limpar formul√°rio e flags
                 clearForm();
                 if (userId) {
                   processingUsers.delete(userId);
                   activeRequests.delete(userId);
                 }
                 if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
                 
                 // Recarregar p√°gina para permitir novo cadastro
                 setTimeout(() => {
                   window.location.reload();
                 }, 300);
                 return;
               }
             } else {
               // Envio falhou mas est√° online - n√£o adicionar √† fila
               if (userId) {
                 processingUsers.delete(userId);
                 activeRequests.delete(userId);
               }
               if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
             }
           }, 2000);
         } else {
           // üö® CORRE√á√ÉO CR√çTICA: Outros erros - s√≥ adicionar √† fila se realmente estiver offline
           const isReallyOffline = !navigator.onLine;
           const isNetworkError = error.message && (
             error.message.includes('Failed to fetch') ||
             error.message.includes('NetworkError') ||
             error.message.includes('Network request failed') ||
             error.name === 'AbortError'
           );
           
           // üö® VERIFICA√á√ÉO CR√çTICA: Verificar se j√° foi enviado ANTES de adicionar √† fila
           const uuidCheck2 = payload.uuid || payload.UUID;
           const sentRecordsCheck2 = JSON.parse(localStorage.getItem('sent_records') || '{}');
           const recordKeyCheck2 = uuidCheck2 ? `gs_${uuidCheck2}` : null;
           const alreadySent2 = recordKeyCheck2 && sentRecordsCheck2[recordKeyCheck2];
           
           if (alreadySent2) {
             console.warn(`üö® BLOQUEIO CR√çTICO ${platformType}: Registro j√° foi enviado (UUID: ${uuidCheck2}) - N√ÉO adicionar √† fila`);
             console.warn(`üö® BLOQUEIO CR√çTICO ${platformType}: Evitando duplica√ß√£o na fila`);
             return; // N√£o adicionar √† fila
           }
           
           if (isReallyOffline || isNetworkError) {
             console.log(`‚ùå ${platformType}: Erro de rede detectado, salvando na fila offline`);
             if (!window.addedToOfflineQueue) {
               const queueResult = addToOfflineQueue(payload);
               if (queueResult === null) {
                 console.warn(`üö® BLOQUEIO CR√çTICO ${platformType}: addToOfflineQueue retornou null - registro j√° foi enviado`);
                 return; // N√£o continuar se j√° foi enviado
               }
               window.addedToOfflineQueue = true;
               updateQueueCount();
               
               // Limpar formul√°rio e flags
               clearForm();
               if (userId) {
                 processingUsers.delete(userId);
                 activeRequests.delete(userId);
               }
               if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
               
               // Recarregar p√°gina para permitir novo cadastro
               setTimeout(() => {
                 window.location.reload();
               }, 300);
               return;
             }
           } else {
             // Erro n√£o √© de rede - n√£o adicionar √† fila
             if (userId) {
               processingUsers.delete(userId);
               activeRequests.delete(userId);
             }
             if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
           }
         }
       }
       
       // üöÄ CORRE√á√ÉO: Limpeza movida para dentro do bloco de sucesso
       // clearForm(); // Removido - agora √© chamado apenas ap√≥s sucesso
       
       // Foco otimizado
       if (!isMobile) {
         setTimeout(() => {
           const primeiroCampo = document.getElementById('comumInput');
           if (primeiroCampo) primeiroCampo.focus();
         }, 50);
       }
     } catch (err) {
       console.error('‚ùå Erro no envio:', err);
       // üö® CORRE√á√ÉO: Marcar como falha explicitamente
       submissionSuccess = false;
       
       // Erro capturado
       try {
         const payload = await collectFormData();
         
         // üö® CORRE√á√ÉO: Verifica se √© erro de conectividade ou CORS E se realmente est√° offline
         const isConnectivityError = err.message && (
           err.message.includes('OFFLINE_DETECTED') || 
           err.message.includes('Erro de conectividade') ||
           err.message.includes('Failed to fetch') ||
           err.message.includes('CORS') ||
           err.message.includes('network') ||
           err.name === 'TypeError'
         );
         
         const isReallyOffline = !navigator.onLine;
         
         // üö® VERIFICA√á√ÉO CR√çTICA: Verificar se j√° foi enviado ANTES de adicionar √† fila
         const uuidCheck3 = payload.uuid || payload.UUID;
         const sentRecordsCheck3 = JSON.parse(localStorage.getItem('sent_records') || '{}');
         const recordKeyCheck3 = uuidCheck3 ? `gs_${uuidCheck3}` : null;
         const alreadySent3 = recordKeyCheck3 && sentRecordsCheck3[recordKeyCheck3];
         
         if (alreadySent3) {
           console.warn(`üö® BLOQUEIO CR√çTICO: Registro j√° foi enviado (UUID: ${uuidCheck3}) - N√ÉO adicionar √† fila`);
           console.warn(`üö® BLOQUEIO CR√çTICO: Evitando duplica√ß√£o na fila`);
           return; // N√£o adicionar √† fila
         }
         
         // üö® CORRE√á√ÉO CR√çTICA: S√≥ adicionar √† fila se for erro de conectividade E estiver offline
         if (isConnectivityError && isReallyOffline) {
          // üö® CORRE√á√ÉO CR√çTICA: Verificar se j√° foi adicionado √† fila
          if (!window.addedToOfflineQueue) {
            const queueResult = addToOfflineQueue(payload);
            if (queueResult === null) {
              console.warn(`üö® BLOQUEIO CR√çTICO: addToOfflineQueue retornou null - registro j√° foi enviado`);
              return; // N√£o continuar se j√° foi enviado
            }
            window.addedToOfflineQueue = true;
            updateQueueCount();
            
            // Limpar formul√°rio e flags
            clearForm();
            if (userId) {
              processingUsers.delete(userId);
              activeRequests.delete(userId);
            }
            if (btn) { btn.disabled = false; btn.dataset.loading = '0'; }
            
            // Recarregar p√°gina para permitir novo cadastro
            setTimeout(() => {
              window.location.reload();
            }, 300);
            return;
          } else {
            console.log('‚ö†Ô∏è DUPLICA√á√ÉO PREVENIDA: Item j√° foi adicionado √† fila offline');
          }
         } else {
           console.log('‚ùå Erro n√£o √© de conectividade ou est√° online - N√ÉO adicionar √† fila');
           showToast('error', 'Erro', err.message || 'Falha ao enviar.', 4000);
         }
       } catch (e2) {
         // üö® CORRE√á√ÉO: Usar e2.message ou err.message de forma segura
         const errorMessage = e2?.message || err?.message || 'Falha ao enviar.';
         showToast('error', 'Erro', errorMessage, 4000);
       }
     } finally {
       // üö® CORRE√á√ÉO CR√çTICA: Reabilitar bot√£o ANTES de qualquer outra coisa
       if (btn) {
         btn.disabled = false;
         btn.dataset.loading = '0';
         btn.removeAttribute('disabled');
       }
       
       // Libera processamento para este usu√°rio espec√≠fico
       processingUsers.delete(userId);
       activeRequests.delete(userId);
       
       // Remove este usu√°rio da fila
       const userIndex = processingQueue.findIndex(item => item.userId === userId);
       if (userIndex !== -1) {
         processingQueue.splice(userIndex, 1);
       }
       
       // üö® CORRE√á√ÉO: Resetar flag de fila offline
       window.addedToOfflineQueue = false;
       
       // üö® CORRE√á√ÉO CR√çTICA: Limpar activeSubmissions (payload pode ser null se houve erro antes)
       if (window.activeSubmissions && payload && payload.uuid) {
         window.activeSubmissions.delete(payload.uuid);
       }
       
      // ‚è±Ô∏è CRON√îMETRO: Tempo total do processo (apenas log, n√£o bloqueia)
      const endTime = performance.now();
      const totalTime = endTime - startTime;
      
      // üö® CORRE√á√ÉO: Logs reduzidos para n√£o atrasar
      if (totalTime > 1000) {
        console.log('‚è±Ô∏è Envio conclu√≠do em', totalTime.toFixed(0), 'ms');
      }
      
      // üö® REGISTRAR M√âTRICAS DE PERFORMANCE
      const success = submissionSuccess === true;
      recordPerformanceMetrics(totalTime, success);
      
      // Atualizar circuit breaker
      updateCircuitBreaker(success);
     }
   }
   
   /* ===== LIMPAR FORMUL√ÅRIO (OTIMIZADO) ===== */
   // üöÄ FUN√á√ÉO OTIMIZADA: Limpeza ultra-r√°pida do formul√°rio
   function clearForm() {
     console.log('üßπ Iniciando limpeza do formul√°rio...');
     
     try {
       // Limpeza em lote para m√°xima performance
       const elementsToClear = [
         document.getElementById('formPresenca'),
         findNomeField(),
         document.querySelector('#anotacoes, [name="anotacoes"], textarea'),
         ...document.querySelectorAll('select')
       ];
       
       elementsToClear.forEach(el => {
         if (!el) return;
         
         if (el.tagName === 'FORM') {
           el.reset();
         } else if (el.tagName === 'SELECT') {
           if (el.options.length > 0) el.selectedIndex = 0;
         } else {
           el.value = '';
         }
       });
       
       // Limpa atributos de detec√ß√£o autom√°tica
       const cargoEl = document.querySelector('[data-cargo-real]');
       if (cargoEl) {
         cargoEl.removeAttribute('data-cargo-real');
         cargoEl.removeAttribute('data-nivel-instrutor');
       }
       
       // üöÄ FECHAR DROPDOWN DAS COMUNS ap√≥s envio
       const comumResults = document.getElementById('comumResults');
       if (comumResults) {
         comumResults.classList.remove('show');
         console.log('üîΩ Dropdown das comuns fechado ap√≥s envio');
       }
       
       // üöÄ FECHAR DROPDOWN DOS NOMES ap√≥s envio
       const nomeResults = document.getElementById('nomeResults');
       if (nomeResults) {
         nomeResults.classList.remove('show');
         console.log('üîΩ Dropdown dos nomes fechado ap√≥s envio');
       }
       
       // üöÄ CORRE√á√ÉO: Remover apenas overlays espec√≠ficos, n√£o todos
       // üö® CORRE√á√ÉO CR√çTICA: Remover overlays escuros que podem estar bloqueando a tela
       // Verificar se h√° modais SweetAlert2 ativos antes de remover overlays
       const activeSwal = document.querySelector('.swal2-popup');
       const activeSwalBackdrop = document.querySelector('.swal2-backdrop');
       
       // üö® CORRE√á√ÉO: Remover backdrop do SweetAlert2 se n√£o h√° modal ativo
       if (activeSwalBackdrop && !activeSwal) {
         console.log('üóëÔ∏è Removendo backdrop do SweetAlert2 que ficou preso');
         activeSwalBackdrop.remove();
       }
       
       if (!activeSwal) {
         // S√≥ remover overlays se n√£o h√° modais ativos
         const overlays = document.querySelectorAll('.modal-backdrop, .loading-overlay, .swal2-backdrop');
         overlays.forEach(overlay => {
           if (overlay && overlay.parentNode) {
             overlay.remove();
             console.log('üóëÔ∏è Overlay removido:', overlay.className);
           }
         });
         
         // S√≥ remover classes de bloqueio se n√£o h√° modais ativos
         document.body.classList.remove('modal-open');
         document.body.style.overflow = '';
         document.body.style.paddingRight = '';
         
         // üö® CORRE√á√ÉO: Remover qualquer estilo que possa estar deixando a tela escura
         document.body.style.backgroundColor = '';
         document.documentElement.style.backgroundColor = '';
       } else {
         console.log('üîî Modal SweetAlert2 ativo - preservando overlay');
       }
       
       // üéØ FOCO AUTOM√ÅTICO: Aplicar foco no campo COMUM CONGREGA√á√ÉO ap√≥s limpeza
       setTimeout(() => {
         focusComumField();
       }, 100); // Pequeno delay para garantir que a limpeza foi conclu√≠da
       
       console.log('‚úÖ Formul√°rio limpo com sucesso');
     } catch (error) {
       console.error('‚ùå Erro ao limpar formul√°rio:', error);
     }
   }
   
   /* ===== LOGOUT ===== */
   async function handleLogout() {
     try {
       showToast('info', 'Saindo...', 'Encerrando sess√£o...', 2000);
       
       // Chrome iOS: limpar localStorage com fallback
       try {
         localStorage.removeItem('session_user');
         localStorage.removeItem('session_role');
         localStorage.removeItem('session_local');
         localStorage.removeItem('session_time');
       } catch (e) {
         console.warn('‚ö†Ô∏è Chrome iOS: Erro ao limpar localStorage:', e);
       }
       
       if (supabaseLoaded && sb) {
         try {
           await sb.auth.signOut();
         } catch (e) {
           console.warn('‚ö†Ô∏è Chrome iOS: Erro no signOut do Supabase:', e);
         }
       }
       
       // Chrome iOS: redirecionamento mais direto
       setTimeout(() => {
         try {
           window.location.href = './login.html';
         } catch (e) {
           console.warn('‚ö†Ô∏è Chrome iOS: Erro no redirecionamento, tentando novamente...');
           window.location.replace('./login.html');
         }
       }, 1000);
     } catch (error) {
       console.error('Erro no logout:', error);
       showToast('error', 'Erro no logout', 'Redirecionando mesmo assim...', 2000);
       setTimeout(() => {
         try {
           window.location.href = './login.html';
         } catch (e) {
           window.location.replace('./login.html');
         }
       }, 1000);
     }
   }
   
   /* ===== VERIFICA√á√ÉO DE SESS√ÉO ===== */
   function checkSession() {
     const sessionUser = localStorage.getItem('session_user');
     const sessionTime = localStorage.getItem('session_time');
     
     if (!sessionUser || !sessionTime) {
       window.location.href = './login.html';
       return false;
     }
     
     const now = Date.now();
     const sessionAge = now - parseInt(sessionTime);
     const maxAge = 24 * 60 * 60 * 1000;
     
     if (sessionAge > maxAge) {
       localStorage.removeItem('session_user');
       localStorage.removeItem('session_role');
       localStorage.removeItem('session_local');
       localStorage.removeItem('session_time');
       window.location.href = './login.html';
       return false;
     }
     
     return true;
   }
   
  /* ===== VERIFICA√á√ÉO DE STATUS MASTER ===== */
  // Cache para evitar consultas excessivas
  let masterStatusCache = null;
  let masterStatusCacheTime = 0;
  const MASTER_CACHE_DURATION = 30000; // 30 segundos
  
  async function verificarStatusMaster() {
    try {
      const sessionUser = localStorage.getItem('session_user');
      
      console.log('üîç Verificando status master:');
      console.log('üîç session_user:', sessionUser);
      console.log('üîç Supabase dispon√≠vel:', !!sb);
      console.log('üîç Ambiente:', window.location.hostname);
      
      if (!sessionUser) {
        console.log('‚ùå Nenhum usu√°rio logado');
        return false;
      }
      
      // Verifica√ß√£o for√ßada para usu√°rios master (fallback mais agressivo)
      const isMasterByEmail = sessionUser.includes('master') || 
                             sessionUser.includes('admin') ||
                             sessionUser.includes('MASTER') ||
                             sessionUser.includes('ADMIN') ||
                             sessionUser.includes('ricardo') ||
                             sessionUser.includes('RICARDO');
      
      console.log('üîç Verifica√ß√£o por email (fallback):', isMasterByEmail);
      
      if (isMasterByEmail) {
        console.log('üëë Usu√°rio master detectado por email - retornando true');
        masterStatusCache = true;
        masterStatusCacheTime = Date.now();
        return true;
      }
      
      // Verificar cache primeiro
      const now = Date.now();
      if (masterStatusCache !== null && (now - masterStatusCacheTime) < MASTER_CACHE_DURATION) {
        console.log('üëë Usando cache do status master:', masterStatusCache);
        return masterStatusCache;
      }
      
      // Verifica se Supabase est√° dispon√≠vel
      if (!supabaseLoaded || !sb) {
        console.log('‚ö†Ô∏è Supabase n√£o dispon√≠vel - usando fallback');
        // Fallback: verifica se o email cont√©m palavras-chave
        const isMaster = sessionUser.includes('master') || 
                         sessionUser.includes('admin') ||
                         sessionUser.includes('MASTER') ||
                         sessionUser.includes('ADMIN');
        console.log('üëë Status master (fallback):', isMaster);
        
        // Cache o resultado
        masterStatusCache = isMaster;
        masterStatusCacheTime = now;
        
        return isMaster;
      }
      
      console.log('üîç Consultando tabela profiles no Supabase...');
      
      // Consulta a tabela profiles para verificar o role (apenas coluna role existe)
      const { data, error } = await sb
        .from('profiles')
        .select('role')
        .eq('email', sessionUser)
        .single();
      
      console.log('üîç Resultado da consulta profiles:', { data, error });
      
      if (error) {
        console.error('‚ùå Erro ao consultar profiles:', error);
        
        // Se for erro de stack depth, usar fallback e n√£o tentar novamente
        if (error.code === '54001' || error.message?.includes('stack depth')) {
          console.log('‚ö†Ô∏è Erro de stack depth detectado - usando fallback permanente');
          const isMaster = sessionUser.includes('master') || 
                           sessionUser.includes('admin') ||
                           sessionUser.includes('MASTER') ||
                           sessionUser.includes('ADMIN');
          console.log('üëë Status master (fallback por stack depth):', isMaster);
          
          // Cache o resultado por mais tempo em caso de erro
          masterStatusCache = isMaster;
          masterStatusCacheTime = now + (MASTER_CACHE_DURATION * 2); // Cache por 1 minuto
          
          return isMaster;
        }
        
        // Fallback em caso de erro
        const isMaster = sessionUser.includes('master') || 
                         sessionUser.includes('admin') ||
                         sessionUser.includes('MASTER') ||
                         sessionUser.includes('ADMIN');
        console.log('üëë Status master (fallback por erro):', isMaster);
        
        // Cache o resultado
        masterStatusCache = isMaster;
        masterStatusCacheTime = now;
        
        return isMaster;
      }
      
      if (data) {
        const isMaster = data.role === 'master' || 
                         data.role === 'MASTER' ||
                         data.role === 'admin' ||
                         data.role === 'ADMIN';
        
        console.log('üëë Status master (Supabase):', isMaster);
        console.log('üëë Dados do usu√°rio:', data);
        console.log('üëë Role encontrado:', data.role);
        
        // Cache o resultado
        masterStatusCache = isMaster;
        masterStatusCacheTime = now;
        
        return isMaster;
      }
      
      console.log('‚ùå Usu√°rio n√£o encontrado na tabela profiles');
      
      // Cache o resultado
      masterStatusCache = false;
      masterStatusCacheTime = now;
      
      return false;
      
    } catch (error) {
      console.error('‚ùå Erro ao verificar status master:', error);
      
      // Cache o resultado em caso de erro
      masterStatusCache = false;
      masterStatusCacheTime = Date.now();
      
      return false;
    }
  }
  
  // Fun√ß√£o para limpar o cache do status master
  function limparCacheMasterStatus() {
    masterStatusCache = null;
    masterStatusCacheTime = 0;
    console.log('üßπ Cache do status master limpo');
  }
   
  async function mostrarBotaoEdicao() {
    try {
      console.log('üîç Iniciando mostrarBotaoEdicao...');
      console.log('üîç Ambiente:', window.location.hostname);
      console.log('üîç Supabase carregado:', supabaseLoaded);
      console.log('üîç Supabase dispon√≠vel:', !!sb);
      
      const editBtn = document.getElementById('editBtn');
      console.log('üîç Bot√£o de edi√ß√£o encontrado:', !!editBtn);
      console.log('üîç Elemento editBtn:', editBtn);
      
      if (!editBtn) {
        console.error('‚ùå Bot√£o de edi√ß√£o n√£o encontrado');
        return;
      }
      
      console.log('üîç Bot√£o encontrado, verificando status master...');
      const isMaster = await verificarStatusMaster();
      
      console.log('üîç Resultado da verifica√ß√£o:', isMaster);
      console.log('üîç Display atual do bot√£o:', editBtn.style.display);
      console.log('üîç Classe atual do bot√£o:', editBtn.className);
      
      // Verifica√ß√£o adicional: se o usu√°rio cont√©m "ricardo" ou "master", for√ßar exibi√ß√£o
      const sessionUser = localStorage.getItem('session_user') || '';
      const forceShow = sessionUser.includes('ricardo') || sessionUser.includes('master') || sessionUser.includes('admin');
      
      console.log('üîç For√ßar exibi√ß√£o (fallback):', forceShow);
      console.log('üîç Session user:', sessionUser);
      
      if (isMaster || forceShow) {
        editBtn.style.display = 'inline-flex';
        editBtn.style.visibility = 'visible';
        editBtn.style.opacity = '1';
        editBtn.style.position = 'relative';
        editBtn.style.zIndex = '1000';
        console.log('‚úÖ Bot√£o de edi√ß√£o exibido para usu√°rio master');
        console.log('üîç Display ap√≥s mudan√ßa:', editBtn.style.display);
        
        // Atualizar o bot√£o para mostrar apenas o √≠cone
        editBtn.innerHTML = '<span>‚úèÔ∏è</span>';
        editBtn.title = 'Editar Registros';
        
      } else {
        editBtn.style.display = 'none';
        editBtn.style.visibility = 'hidden';
        editBtn.style.opacity = '0';
        console.log('‚ùå Bot√£o de edi√ß√£o oculto - usu√°rio n√£o √© master');
      }
    } catch (error) {
      console.error('‚ùå Erro ao mostrar bot√£o de edi√ß√£o:', error);
      console.error('‚ùå Stack trace:', error.stack);
    }
  }
  
  // Fun√ß√£o de debug para for√ßar exibi√ß√£o do bot√£o
  window.forceShowEditButton = function() {
    console.log('üîß FOR√áANDO EXIBI√á√ÉO DO BOT√ÉO DE EDI√á√ÉO...');
    const editBtn = document.getElementById('editBtn');
    if (editBtn) {
      editBtn.style.display = 'inline-flex';
      editBtn.style.visibility = 'visible';
      editBtn.style.opacity = '1';
      editBtn.style.position = 'relative';
      editBtn.style.zIndex = '1000';
      editBtn.innerHTML = '<span>‚úèÔ∏è</span>';
      editBtn.title = 'Editar Registros';
      console.log('‚úÖ Bot√£o de edi√ß√£o for√ßado a aparecer');
    } else {
      console.error('‚ùå Bot√£o de edi√ß√£o n√£o encontrado para for√ßar exibi√ß√£o');
    }
  };
   
   /* ===== TRATAMENTO SIMPLIFICADO DE USU√ÅRIO ===== */
   function formatarNomeUsuario(email) {
     if (!email) return 'Usu√°rio';
     
     // üöÄ PRIORIDADE: Usar nome do perfil se dispon√≠vel
     const savedName = localStorage.getItem('session_name');
     if (savedName) {
       const nomeCompleto = savedName.trim();
       const partesNome = nomeCompleto.split(' ');
       
       if (partesNome.length >= 2) {
         // Pegar primeiro e √∫ltimo nome
         const primeiroNome = partesNome[0];
         const ultimoNome = partesNome[partesNome.length - 1];
         return `${primeiroNome} ${ultimoNome}`;
       } else {
         // Se s√≥ tem um nome, usar ele mesmo
         return nomeCompleto;
       }
     }
     
     // Fallback: Remove caracteres especiais e formata o nome no formato "Nome Sobrenome"
     let nome = email.split('@')[0]
       .replace(/[._-]/g, ' ')           // Substitui pontos, underscores e h√≠fens por espa√ßos
       .replace(/\d+/g, '')              // Remove n√∫meros
       .trim()
       .toLowerCase();                   // Converte para min√∫sculas primeiro
     
     // Se tem mais de 8 caracteres, tenta dividir automaticamente
     if (nome.length > 8) {
       // Casos especiais conhecidos
       if (nome.includes('secretaria') && nome.includes('regional') && nome.includes('itapevi')) {
         nome = 'secretaria regional itapevi';
       } else if (nome.includes('secretaria') && nome.includes('municipal')) {
         nome = 'secretaria municipal';
       } else if (nome.includes('coordenacao') && nome.includes('regional')) {
         nome = 'coordenacao regional';
       } else if (nome.includes('administracao') && nome.includes('municipal')) {
         nome = 'administracao municipal';
       } else if (nome.includes('secre') && nome.includes('tariaregionalitapevi')) {
         nome = 'secretaria regional itapevi';
       } else if (nome.includes('secre') && nome.includes('taria') && nome.includes('regional') && nome.includes('itapevi')) {
         nome = 'secretaria regional itapevi';
       } else {
         // Lista de palavras comuns em nomes para ajudar na divis√£o
         const palavrasComuns = [
           'secretaria', 'regional', 'municipal', 'estadual', 'federal',
           'administracao', 'administra√ß√£o', 'coordenacao', 'coordena√ß√£o',
           'direcao', 'dire√ß√£o', 'gerencia', 'ger√™ncia', 'supervisao', 'supervis√£o',
           'assistencia', 'assist√™ncia', 'atendimento', 'suporte', 'tecnico', 't√©cnico',
           'analista', 'consultor', 'especialista', 'coordenador', 'gerente', 'diretor',
           'supervisor', 'assistente', 'auxiliar', 'operador', 'responsavel', 'respons√°vel',
           'itapevi', 'sao', 'paulo', 'santos', 'campinas', 'guarulhos', 'santo', 'andre'
         ];
       
       // Primeiro, tenta encontrar palavras conhecidas no nome completo
       let melhorDivisao = null;
       let maiorScore = 0;
       
       // Testa diferentes pontos de divis√£o
       for (let i = 4; i < nome.length - 4; i++) {
         const parte1 = nome.substring(0, i);
         const parte2 = nome.substring(i);
         
         // Verifica se alguma das partes corresponde a uma palavra comum
         let score = 0;
         palavrasComuns.forEach(palavra => {
           if (parte1.includes(palavra) || parte2.includes(palavra)) {
             score += palavra.length;
           }
           // Bonus se a palavra est√° no in√≠cio ou fim
           if (parte1.startsWith(palavra) || parte2.startsWith(palavra)) {
             score += 2;
           }
           // Bonus extra se a palavra est√° completa
           if (parte1 === palavra || parte2 === palavra) {
             score += 5;
           }
         });
         
         if (score > maiorScore) {
           maiorScore = score;
           melhorDivisao = { parte1, parte2 };
         }
       }
       
       // Se encontrou uma boa divis√£o, aplica
       if (melhorDivisao && maiorScore > 0) {
         nome = melhorDivisao.parte1 + ' ' + melhorDivisao.parte2;
         
         // Tenta dividir ainda mais se necess√°rio
         const partes = nome.split(' ');
         if (partes.length === 2 && partes[1].length > 8) {
           const segundaParte = partes[1];
           let melhorDivisao2 = null;
           let maiorScore2 = 0;
           
           for (let i = 4; i < segundaParte.length - 4; i++) {
             const subParte1 = segundaParte.substring(0, i);
             const subParte2 = segundaParte.substring(i);
             
             let score2 = 0;
             palavrasComuns.forEach(palavra => {
               if (subParte1.includes(palavra) || subParte2.includes(palavra)) {
                 score2 += palavra.length;
               }
               if (subParte1.startsWith(palavra) || subParte2.startsWith(palavra)) {
                 score2 += 2;
               }
               if (subParte1 === palavra || subParte2 === palavra) {
                 score2 += 5;
               }
             });
             
             if (score2 > maiorScore2) {
               maiorScore2 = score2;
               melhorDivisao2 = { subParte1, subParte2 };
             }
           }
           
           if (melhorDivisao2 && maiorScore2 > 0) {
             nome = partes[0] + ' ' + melhorDivisao2.subParte1 + ' ' + melhorDivisao2.subParte2;
           }
         }
       } else {
         // Fallback: divis√£o baseada em padr√µes lingu√≠sticos
         for (let i = 4; i < nome.length - 4; i++) {
           const char = nome[i];
           const nextChar = nome[i + 1];
           
           // Procura por transi√ß√µes que indicam in√≠cio de nova palavra
           if ('aeiou'.includes(char) && !'aeiou'.includes(nextChar)) {
             // Verifica se n√£o √© muito no in√≠cio nem muito no final
             if (i > 4 && i < nome.length - 4) {
               nome = nome.substring(0, i + 1) + ' ' + nome.substring(i + 1);
               break;
             }
           }
         }
       }
       }
     }
     
     // Divide em palavras e capitaliza
     const palavras = nome.split(' ')
       .filter(palavra => palavra.length > 0) // Remove palavras vazias
       .map(palavra => 
         palavra.charAt(0).toUpperCase() + palavra.slice(1)  // Capitaliza primeira letra de cada palavra
       );
     
     return palavras.join(' ') || 'Usu√°rio';
   }
   
   /* ===== INFORMA√á√ïES DO USU√ÅRIO ===== */
   async function updateUserInfo() {
     const sessionUser = localStorage.getItem('session_user');
     const sessionLocal = localStorage.getItem('session_local');
     const sessionRole = localStorage.getItem('session_role');
     
     if (sessionUser) {
       // Formata o nome do usu√°rio a partir do email
       const nomeUsuario = formatarNomeUsuario(sessionUser);
       
       // Definir role baseado no session_role
       let userRole = 'Usu√°rio'; // Padr√£o
       if (sessionRole === 'master') {
         userRole = 'Administrador';
       } else if (sessionRole === 'user') {
         userRole = 'Usu√°rio';
       }
       
      // Atualiza o header com dados din√¢micos
      const headerLocation = document.getElementById('currentLocation');
      const headerUser = document.getElementById('currentUser');
      const headerRole = document.getElementById('currentUserRole');
      
      if (headerLocation) {
        headerLocation.textContent = sessionLocal || 'Local do Ensaio';
      }
      
      if (headerUser) {
        headerUser.textContent = nomeUsuario;
      }
      
      if (headerRole) {
        headerRole.textContent = userRole;
      }
       
       console.log('‚úÖ Header atualizado:', { local: sessionLocal, usuario: nomeUsuario, role: userRole });
       
       // Mant√©m compatibilidade com subtitle antigo (se existir)
       const subtitle = document.getElementById('subtitle');
       if (subtitle) {
         const locationInfo = subtitle.querySelector('.location-info');
         const userName = subtitle.querySelector('.user-name');
         
         if (locationInfo) {
           locationInfo.textContent = sessionLocal || 'Local do Ensaio';
         }
         
         if (userName) {
           userName.textContent = nomeUsuario;
         }
         
         console.log('‚úÖ Subtitle atualizado:', { local: sessionLocal, usuario: nomeUsuario });
       }
       
       // Verifica status master ap√≥s atualizar informa√ß√µes do usu√°rio
       await mostrarBotaoEdicao();
     } else {
       console.log('‚ùå Nenhum usu√°rio logado encontrado');
       
       // Define valores padr√£o se n√£o houver sess√£o
       const headerLocation = document.getElementById('header-location');
       const headerUser = document.getElementById('header-user');
       
       if (headerLocation) {
         headerLocation.textContent = 'Local do Ensaio';
       }
       
       if (headerUser) {
         headerUser.textContent = 'Usu√°rio';
       }
     }
   }
   
   
  /* ===== FUN√á√ÉO DE DIAGN√ìSTICO CROSS-PLATFORM ===== */
  // üõ°Ô∏è Fun√ß√£o para diagnosticar problemas de compatibilidade
  function diagnosticarPlataforma() {
    const diagnostico = {
      plataforma: {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        isMobile: isMobile,
        isDesktop: isDesktop,
        isIOS: isIOS,
        isAndroid: isAndroid,
        isXiaomi: isXiaomi,
        miuiVersion: miuiVersion,
        isStandalone: isStandalone
      },
      storage: {
        localStorageAvailable: isLocalStorageAvailable(),
        localStorageTest: (() => {
          try {
            const test = '__diagnostic_test__';
            localStorage.setItem(test, 'test');
            const result = localStorage.getItem(test) === 'test';
            localStorage.removeItem(test);
            return result;
          } catch (e) {
            return false;
          }
        })(),
        sessionStorageAvailable: typeof sessionStorage !== 'undefined',
        useMemoryStorage: useMemoryStorage
      },
      conectividade: {
        online: navigator.onLine,
        connectionType: navigator.connection?.effectiveType || 'unknown'
      },
      supabase: {
        loaded: supabaseLoaded,
        available: !!sb,
        windowSupabaseLoaded: window.supabaseLoaded,
        windowSb: !!window.sb
      },
      ambiente: {
        protocol: window.location.protocol,
        hostname: window.location.hostname,
        isHTTPS: isHTTPS,
        isFileProtocol: isFileProtocol,
        isLocalhost: isLocalhost
      }
    };
    
    console.log('üîç DIAGN√ìSTICO DE PLATAFORMA:', diagnostico);
    
    // üõ°Ô∏è XIAOMI: Logs espec√≠ficos
    if (isXiaomi) {
      console.log('üì± XIAOMI/MIUI DETECTADO - DIAGN√ìSTICO ESPEC√çFICO:', {
        miuiVersion: miuiVersion,
        localStorageAvailable: diagnostico.storage.localStorageAvailable,
        localStorageTest: diagnostico.storage.localStorageTest,
        useMemoryStorage: useMemoryStorage,
        recomendacoes: [
          'Verificar se localStorage est√° funcionando corretamente',
          'Verificar se h√° problemas de quota',
          'Verificar se h√° bloqueios de seguran√ßa do MIUI',
          'Considerar usar fallback de mem√≥ria se localStorage falhar'
        ]
      });
    }
    
    // Expor diagn√≥stico globalmente para debug
    window.diagnosticoPlataforma = diagnostico;
    
    return diagnostico;
  }
  
  /* ===== BOOT ===== */
  window.addEventListener('load', async () => {
    // üöÄ OTIMIZA√á√ÉO: Log reduzido para melhor performance
    console.log('üöÄ Iniciando aplica√ß√£o...');
    
    // üö® CORRE√á√ÉO CR√çTICA: Garantir que o app continue funcionando mesmo offline
    // Prevenir que o navegador mostre a p√°gina de offline padr√£o
    if (!navigator.onLine) {
      console.log('üìµ Aplica√ß√£o iniciando em modo offline - app continuar√° funcionando');
      // Carregar dados do cache imediatamente
      if (typeof loadCargosInstrumentosOffline === 'function') {
        loadCargosInstrumentosOffline();
      }
      if (typeof loadComunsFromCatalog === 'function') {
        loadComunsFromCatalog().catch(() => {
          // Ignorar erros silenciosamente
        });
      }
    }
    
    // üõ°Ô∏è EXECUTAR DIAGN√ìSTICO NA INICIALIZA√á√ÉO (apenas em modo debug)
    if (window.location.search.includes('debug=true')) {
      diagnosticarPlataforma();
    }
      
      // üéØ FOCO AUTOM√ÅTICO: Garantir foco no campo COMUM CONGREGA√á√ÉO ap√≥s carregamento completo
      setTimeout(() => {
        focusComumField();
      }, 1000); // Delay maior para garantir que tudo esteja carregado
     
     // Prote√ß√µes de seguran√ßa j√° aplicadas no HTML
     
     // üöÄ OTIMIZA√á√ÉO: Limpeza de cache otimizada (apenas uma vez, sem logs excessivos)
     // Limpa cache de instrumentos antigo apenas se necess√°rio
     const hasOldCache = Object.keys(localStorage).some(k => 
       (k.includes('instrument') || k.includes('INSTRUMENT')) && 
       !k.includes(CACHE_KEYS.INSTRUMENTOS)
     );
     if (hasOldCache) {
       Object.keys(localStorage).forEach(key => {
         if ((key.includes('instrument') || key.includes('INSTRUMENT')) && 
             !key.includes(CACHE_KEYS.INSTRUMENTOS)) {
           localStorage.removeItem(key);
         }
       });
     }
     
     try {
       // üöÄ OTIMIZA√á√ÉO: Paralelizar inicializa√ß√µes quando poss√≠vel
       // Inicializa tema (s√≠ncrono, r√°pido)
       initTheme();
     
       // Otimiza√ß√µes espec√≠ficas para desktop
       if (isDesktop) {
         optimizeForDesktop();
       }
     
       // Otimiza√ß√µes espec√≠ficas para mobile
       if (isMobile) {
         optimizeMobileOffline();
       }
       
       // Verifica sess√£o antes de carregar a aplica√ß√£o
       if (!checkSession()) {
         console.log('‚ùå Sess√£o inv√°lida');
         return;
       }
       
       // Inicializa Supabase
       await initSupabase();
       
       // üöÄ OTIMIZA√á√ÉO: Paralelizar verifica√ß√µes quando poss√≠vel
       // Aguarda um pouco e verifica o bot√£o de edi√ß√£o novamente
       setTimeout(async () => {
         await mostrarBotaoEdicao();
       }, 2000);
       
       // Verifica√ß√£o adicional ap√≥s 5 segundos (para casos onde Supabase demora)
       setTimeout(async () => {
         await mostrarBotaoEdicao();
         
         // Se ainda n√£o apareceu, for√ßar exibi√ß√£o
         const editBtn = document.getElementById('editBtn');
         if (editBtn && editBtn.style.display === 'none') {
           window.forceShowEditButton();
         }
       }, 5000);
       
       // üöÄ OTIMIZA√á√ÉO: Paralelizar atualiza√ß√µes
       await Promise.all([
         updateUserInfo(),
         Promise.resolve(updateQueueCount()),
         mostrarBotaoEdicao()
       ]);
     
     // Fun√ß√£o tempor√°ria para definir status master (para teste)
     window.setMasterStatus = async function() {
       localStorage.setItem('user_status', 'master');
       console.log('üëë Status master definido manualmente');
       await mostrarBotaoEdicao();
     };
     
     // Fun√ß√£o tempor√°ria para verificar localStorage
     window.checkLocalStorage = function() {
       console.log('üîç LocalStorage atual:');
       Object.keys(localStorage).forEach(key => {
         console.log(`üîç ${key}:`, localStorage.getItem(key));
       });
     };
     
     // Fun√ß√£o tempor√°ria para testar consulta Supabase
     window.testSupabaseQuery = async function() {
       try {
         const sessionUser = localStorage.getItem('session_user');
         console.log('üîç Testando consulta Supabase para:', sessionUser);
         
         if (!supabaseLoaded || !sb) {
           console.log('‚ùå Supabase n√£o dispon√≠vel');
           return;
         }
         
         const { data, error } = await sb
           .from('profiles')
           .select('role')
           .eq('email', sessionUser)
           .single();
         
         console.log('üîç Resultado do teste:', { data, error });
         
         if (data) {
           console.log('‚úÖ Usu√°rio encontrado! Role:', data.role);
           console.log('üëë √â master?', data.role === 'master');
         } else {
           console.log('‚ùå Usu√°rio n√£o encontrado ou erro:', error);
         }
       } catch (error) {
         console.error('‚ùå Erro no teste:', error);
       }
     };
     
     // Fun√ß√£o para diagn√≥stico de conectividade mobile
     window.diagnosticarMobile = function() {
       return window.SistemaRecuperacao.diagnosticarConectividadeMobile();
     };
     
     // Fun√ß√£o para for√ßar verifica√ß√£o de conectividade mobile
     window.verificarConectividadeMobile = async function() {
       console.log('üîç For√ßando verifica√ß√£o de conectividade mobile...');
       
       if (typeof window.MobileApp !== 'undefined') {
         await window.MobileApp.forceConnectivityCheck();
         return window.MobileApp.getStatus();
       } else {
         console.log('‚ö†Ô∏è Sistema mobile n√£o dispon√≠vel');
         return { error: 'Sistema mobile n√£o dispon√≠vel' };
       }
     };
     
     // Fun√ß√£o para migrar fila antiga
     window.migrarFilaAntiga = function() {
       return window.SistemaRecuperacao.migrarFilaAntiga();
     };
     
     // Fun√ß√£o de teste para desktop
     window.testarDesktop = async function() {
       console.log('üß™ TESTE DESKTOP: Iniciando teste completo...');
       
       try {
         // 1. Testar coleta de dados
         console.log('üß™ TESTE 1: Coletando dados do formul√°rio...');
         const formData = await collectFormData();
         
         if (formData === null) {
           console.error('‚ùå TESTE FALHOU: collectFormData retornou null');
           return { success: false, step: 'collectFormData', error: 'Dados n√£o coletados' };
         }
         
         console.log('‚úÖ TESTE 1 PASSOU: Dados coletados:', formData);
         
         // 2. Testar envio para Google Sheets
         console.log('üß™ TESTE 2: Enviando para Google Sheets...');
         const success = await sendToGoogleSheets(formData);
         
         if (success) {
           console.log('‚úÖ TESTE 2 PASSOU: Envio para Google Sheets bem-sucedido');
           return { success: true, message: 'Todos os testes passaram' };
         } else {
           console.error('‚ùå TESTE 2 FALHOU: Envio para Google Sheets falhou');
           return { success: false, step: 'sendToGoogleSheets', error: 'Envio falhou' };
         }
         
       } catch (error) {
         console.error('‚ùå TESTE FALHOU:', error);
         return { success: false, step: 'exception', error: error.message };
       }
     };
     
     // Fun√ß√£o para for√ßar detec√ß√£o de plataforma
     window.forcarDetecaoPlataforma = function(plataforma) {
       console.log(`üîß For√ßando detec√ß√£o como: ${plataforma.toUpperCase()}`);
       
       if (plataforma.toLowerCase() === 'desktop') {
         window.isMobile = false;
         window.isDesktop = true;
         window.isIOS = false;
         window.isAndroid = false;
       } else if (plataforma.toLowerCase() === 'mobile') {
         window.isMobile = true;
         window.isDesktop = false;
         // Manter detec√ß√£o espec√≠fica de iOS/Android
       }
       
       console.log('‚úÖ Plataforma for√ßada:', {
         isMobile: window.isMobile,
         isDesktop: window.isDesktop,
         isIOS: window.isIOS,
         isAndroid: window.isAndroid
       });
       
       return {
         isMobile: window.isMobile,
         isDesktop: window.isDesktop,
         isIOS: window.isIOS,
         isAndroid: window.isAndroid
       };
     };
     
    // üö® CORRE√á√ÉO: N√ÉO limpar cache de comuns na inicializa√ß√£o
    // Isso estava impedindo o carregamento das comuns
    // localStorage.removeItem(CACHE_KEYS.COMUNS);
    // console.log('üóëÔ∏è Cache de comuns limpo');
     
     // Migra√ß√£o autom√°tica da fila antiga
     setTimeout(() => {
       const filaAntiga = JSON.parse(localStorage.getItem('fila_presencas_v2') || '[]');
       if (filaAntiga.length > 0) {
         console.log(`üîÑ Encontrados ${filaAntiga.length} itens na fila antiga - iniciando migra√ß√£o autom√°tica...`);
         window.migrarFilaAntiga();
       }
     }, 2000);
     
     // Inicializa processamento da fila Supabase se houver itens pendentes
     const filaSupabase = JSON.parse(localStorage.getItem('fila_supabase') || '[]');
     if (filaSupabase.length > 0) {
       console.log(`üîÑ Iniciando processamento de ${filaSupabase.length} item(s) na fila Supabase`);
       updateSupabaseQueueIndicator(filaSupabase.length);
       processarFilaSupabase();
     }
     
     // Detectar se √© mobile
     const isMobileDevice = window.innerWidth <= 768 || /Mobile|Android|iPhone|iPad/.test(navigator.userAgent);
     
     // Listeners para eventos de conex√£o - Sistema Autom√°tico
     window.addEventListener('online', async () => {
       console.log('üåê Evento online detectado - usando processamento centralizado');
       if (isMobileDevice) {
         console.log('üì± MOBILE: Evento online detectado');
       }
       
       // üö® CORRE√á√ÉO: Aguardar um pouco para garantir que a conex√£o est√° est√°vel
       await new Promise(resolve => setTimeout(resolve, 1000));
       
       // Verificar se realmente est√° online
       const isReallyOnline = await checkSupabaseConnection();
       if (isReallyOnline) {
         // Processar fila automaticamente sem alertas
         await processQueueOnConnectionRestore();
       } else {
         console.log('‚ö†Ô∏è Evento online detectado mas ainda offline - aguardando...');
       }
     });
     
     // üõ°Ô∏è CORRE√á√ÉO DEFINITIVA: Limpa UUIDs inv√°lidos na inicializa√ß√£o
     cleanAllInvalidUUIDs();
     
     // üöÄ CORRE√á√ÉO MOBILE: Processamento peri√≥dico mais agressivo no mobile
     // Sistema de processamento peri√≥dico da fila - OTIMIZADO PARA 100+ USU√ÅRIOS
     // üîß CORRE√á√ÉO: Verifica itens pendentes corretamente
     const intervalTime = isMobileDevice ? 10000 : 15000; // 10 segundos no mobile, 15 no desktop
     
     setInterval(async () => {
       try {
         const filaLocal = JSON.parse(localStorage.getItem('fila_envio') || '[]');
         const filaSupabase = JSON.parse(localStorage.getItem('fila_supabase') || '[]');
         const filaOffline = getOfflineQueue();
         
         // üîß CORRE√á√ÉO: Verificar apenas itens realmente pendentes (n√£o sincronizados)
         const itensPendentesLocal = filaLocal.filter(item => item.status !== 'success');
         const itensPendentesSupabase = filaSupabase.filter(item => item.status !== 'success');
         const itensPendentesOffline = filaOffline.filter(item => !item.synced);
         
         const totalPendentes = itensPendentesLocal.length + 
                               itensPendentesSupabase.length + 
                               itensPendentesOffline.length;
         
         // S√≥ processa se h√° itens realmente pendentes
         if (totalPendentes > 0) {
           if (isMobileDevice) {
             console.log(`üì± MOBILE - Processamento peri√≥dico: ${totalPendentes} item(s) pendente(s)`);
             console.log(`üì± MOBILE - Fila offline: ${itensPendentesOffline.length}, Fila local: ${itensPendentesLocal.length}`);
           } else {
             console.log(`üîÑ Processamento peri√≥dico: ${totalPendentes} item(s) pendente(s)`);
           }
           
           // Verifica conectividade real antes de processar
           const isOnline = await checkSupabaseConnection();
           if (isOnline) {
             if (isMobileDevice) {
               console.log('üì± MOBILE: Conectividade confirmada - processando filas...');
             } else {
               console.log('‚úÖ Conectividade confirmada - processando filas...');
             }
             // Processa todas as filas silenciosamente
             await processarFilaLocal();
             await processarFilaSupabase();
             await processOfflineQueue();
             if (isMobileDevice) {
               console.log('üì± MOBILE: Processamento peri√≥dico conclu√≠do');
             } else {
               console.log('‚úÖ Processamento peri√≥dico conclu√≠do');
             }
           } else {
             if (isMobileDevice) {
               console.log('üì± MOBILE: Sem conectividade - mantendo itens na fila');
             } else {
               console.log('üì¥ Sem conectividade - mantendo itens na fila');
             }
           }
         }
         
         // Processar fila de requisi√ß√µes em lotes
         if (requestQueue.length > 0) {
           await processBatchQueue();
         }
       } catch (error) {
         console.error('‚ùå Erro no processamento peri√≥dico:', error);
         if (isMobileDevice) {
           console.error('üì± MOBILE: Erro no processamento peri√≥dico:', error.message);
         }
       }
     }, intervalTime);
     
     // üö® LIMPEZA PERI√ìDICA DE M√âTRICAS ANTIGAS
     setInterval(() => {
       try {
         cleanupOldMetrics();
         console.log('üßπ M√©tricas antigas limpas');
       } catch (error) {
         console.error('‚ùå Erro na limpeza de m√©tricas:', error);
       }
     }, 300000); // A cada 5 minutos
     
     window.addEventListener('offline', () => {
       console.log('üìµ Conex√£o perdida - modo offline ativado');
       // showToast('warning', 'Modo offline', 'Registros ser√£o salvos na fila', 3000); // Removido - alerta desnecess√°rio
       setStatus(false, 'Offline‚Ä¶');
       
       // üö® CORRE√á√ÉO CR√çTICA: Garantir que o app continue funcionando offline
       // N√£o permitir que o navegador mostre a p√°gina de offline padr√£o
       console.log('üìµ Modo offline: App continuar√° funcionando para cadastros manuais');
       
       // üöÄ Carregar cargos e instrumentos para modo offline
       loadCargosInstrumentosOffline();
       
       // üö® CORRE√á√ÉO CR√çTICA: Recarregar comuns do cache quando internet cair
       console.log('üìµ Recarregando comuns do cache devido √† perda de conex√£o...');
       if (typeof loadComunsFromCatalog === 'function') {
         loadComunsFromCatalog().catch(err => {
           console.error('‚ùå Erro ao recarregar comuns do cache:', err);
         });
       }
       
       // Modo offline ativado - sem alertas
     });
     
     await checkSupabaseConnection();
     console.log('‚úÖ Conex√£o verificada');
     
     // Sistema de verifica√ß√£o peri√≥dica para iOS (Chrome iOS tem problemas com eventos de conex√£o)
     const isIOS = /iPad|iPhone|iPod|iOS/i.test(navigator.userAgent) || 
                   /iPhone|iPad|iPod/i.test(navigator.platform) ||
                   (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
     
     // Melhorias espec√≠ficas para iOS
     if (isIOS) {
       console.log('üçé iOS detectado - aplicando melhorias espec√≠ficas');
       
       // Corrige problema de viewport no iOS
       const setViewportHeight = () => {
         const vh = window.innerHeight * 0.01;
         document.documentElement.style.setProperty('--vh', `${vh}px`);
       };
       
       setViewportHeight();
       window.addEventListener('resize', setViewportHeight);
       window.addEventListener('orientationchange', () => {
         setTimeout(setViewportHeight, 100);
       });
       
       // Melhora eventos de toque
       document.addEventListener('touchstart', function() {}, { passive: true });
       document.addEventListener('touchmove', function() {}, { passive: true });
       
       // Corrige problema de scroll em modais
       const modals = document.querySelectorAll('.modal');
       modals.forEach(modal => {
         modal.addEventListener('show.bs.modal', function() {
           document.body.style.position = 'fixed';
           document.body.style.width = '100%';
         });
         
         modal.addEventListener('hidden.bs.modal', function() {
           document.body.style.position = '';
           document.body.style.width = '';
         });
       });
     }
     
     if (isIOS) {
       console.log('üçé iOS detectado - ativando verifica√ß√£o peri√≥dica de conex√£o');
       
       // Verificar conex√£o a cada 30 segundos
       setInterval(async () => {
         try {
           const wasOffline = !navigator.onLine;
           const connectionOk = await checkSupabaseConnection();
           
           // Se estava offline e agora est√° online, processar fila
           if (wasOffline && connectionOk) {
             console.log('üîÑ iOS: Conex√£o detectada, processando fila automaticamente');
             await flushQueue();
           }
         } catch (e) {
           console.log('‚ö†Ô∏è iOS: Erro na verifica√ß√£o peri√≥dica:', e.message);
         }
       }, 30000); // 30 segundos
     }
     
    // üöÄ OTIMIZA√á√ÉO: Paralelizar carregamentos para melhor performance
    // Carrega comuns, instrumentos e cargos em paralelo
    try {
      await Promise.all([
        loadComunsFromCatalog().catch(err => {
          console.error('‚ùå Erro ao carregar comuns:', err);
          // Fallback: tentar novamente ap√≥s delay
          setTimeout(() => loadComunsFromCatalog().catch(() => {}), 1000);
        }),
        Promise.resolve(loadInstrumentosFixed()),
        Promise.resolve(loadCargosFixed())
      ]);
    } catch (error) {
      console.error('‚ùå Erro ao carregar dados iniciais:', error);
      // Fallback: carregar sequencialmente em caso de erro
      loadInstrumentosFixed();
      loadCargosFixed();
      loadComunsFromCatalog().catch(() => {});
    }
     
     // Inicializa sistema de pesquisa para comum
     initComumSearch();
   
     const comumEl = findComumField();
     const instEl  = findInstrumentField();
     const cargoEl = findCargoField();
   
     // üö® CORRE√á√ÉO CR√çTICA MULTI-PLATAFORMA: Fun√ß√£o universal para verificar e carregar nomes
     // Esta fun√ß√£o garante que os nomes sejam carregados quando comum + cargo est√£o preenchidos
     // Funciona em todas as plataformas m√≥veis (Android, iOS, Chrome iOS, Xiaomi, etc.)
     // Tornada global para ser acess√≠vel de outros lugares
     window.verificarECarregarNomes = function verificarECarregarNomes() {
       const comumEl = findComumField();
       const cargoEl = findCargoField();
       const nomeEl = findNomeField();
       
       if (!comumEl || !cargoEl || !nomeEl) {
         return false;
       }
       
       const comum = comumEl.value?.trim() || '';
       const cargo = cargoEl.value?.trim() || '';
       
       // Verifica se ambos est√£o preenchidos
       if (comum && cargo) {
         // Verificar se j√° h√° nomes carregados para evitar chamadas desnecess√°rias
         const temNomesCarregados = window.nomesData && Array.isArray(window.nomesData) && window.nomesData.length > 0;
         const nomeElTemOpcoes = nomeEl.tagName === 'SELECT' && nomeEl.options.length > 1;
         
         // Se j√° tem nomes carregados e o campo j√° est√° populado, n√£o recarregar
         if (temNomesCarregados && nomeElTemOpcoes) {
           return true;
         }
         
         console.log('‚úÖ Verifica√ß√£o autom√°tica: Comum e Cargo preenchidos, carregando nomes...', { comum, cargo });
         
         // Resetar estado de digita√ß√£o manual
         nomeEl.removeAttribute('data-nome-manual');
         nomeEl.removeAttribute('data-selected-from-list');
         if (nomeEl.style) {
           nomeEl.style.backgroundColor = '';
           nomeEl.style.borderColor = '';
         }
         
         // Carregar nomes
         if (typeof loadNomes === 'function') {
           loadNomes();
           return true;
         }
       }
       
       return false;
     };
     
     // üö® CORRE√á√ÉO CR√çTICA MULTI-PLATAFORMA: Adicionar m√∫ltiplos tipos de eventos para garantir compatibilidade
     // Algumas plataformas m√≥veis podem n√£o disparar 'change' corretamente, ent√£o usamos m√∫ltiplos eventos
     function setupEventListenersRobustos() {
       const comumEl = findComumField();
       const cargoEl = findCargoField();
       
       if (!comumEl || !cargoEl) {
         console.warn('‚ö†Ô∏è Campos comum ou cargo n√£o encontrados para configurar event listeners');
         return;
       }
       
       // Fun√ß√£o handler para comum
       const handleComumChange = function() {
         console.log('üîÑ Evento disparado: comum mudou');
         const nomeEl = findNomeField();
         if (nomeEl) {
           nomeEl.removeAttribute('data-nome-manual');
           nomeEl.removeAttribute('data-selected-from-list');
           if (nomeEl.style) {
             nomeEl.style.backgroundColor = '';
             nomeEl.style.borderColor = '';
           }
         }
         // Usar debounce para evitar m√∫ltiplas chamadas
         debouncedLoadNomes();
         // Verifica√ß√£o adicional ap√≥s um pequeno delay
         setTimeout(verificarECarregarNomes, 200);
       };
       
       // Fun√ß√£o handler para cargo
       const handleCargoChange = function() {
         console.log('üîÑ Evento disparado: cargo mudou');
         const nomeEl = findNomeField();
         if (nomeEl) {
           nomeEl.removeAttribute('data-nome-manual');
           nomeEl.removeAttribute('data-selected-from-list');
           if (nomeEl.style) {
             nomeEl.style.backgroundColor = '';
             nomeEl.style.borderColor = '';
           }
         }
         toggleInstrumentFieldVisibility();
         // üöÄ OTIMIZA√á√ÉO: Chamar diretamente para resposta imediata
         // Removida chamada duplicada de verificarECarregarNomes() que causava carregamento duplo
         loadNomes();
       };
       
       // üö® MULTI-PLATAFORMA: Adicionar m√∫ltiplos tipos de eventos para garantir compatibilidade
       // 'change' - padr√£o, funciona na maioria dos casos
       // 'input' - para campos de texto que podem n√£o disparar 'change' em algumas plataformas
       // 'blur' - quando o campo perde o foco (√∫til para mobile)
       // 'touchend' - espec√≠fico para touch (mobile)
       
       // Eventos para comum
       comumEl.addEventListener('change', handleComumChange);
       comumEl.addEventListener('input', debounce(handleComumChange, 300));
       comumEl.addEventListener('blur', function() {
         setTimeout(verificarECarregarNomes, 100);
       });
       
       // Eventos para cargo
       cargoEl.addEventListener('change', handleCargoChange);
       cargoEl.addEventListener('input', debounce(handleCargoChange, 300));
       cargoEl.addEventListener('blur', function() {
         setTimeout(verificarECarregarNomes, 100);
       });
       
       // Eventos espec√≠ficos para mobile (touch)
       if (isMobile) {
         comumEl.addEventListener('touchend', function() {
           setTimeout(verificarECarregarNomes, 150);
         });
         cargoEl.addEventListener('touchend', function() {
           setTimeout(verificarECarregarNomes, 150);
         });
       }
       
       console.log('‚úÖ Event listeners robustos configurados para comum e cargo');
     }
     
     // Configurar event listeners robustos
     setupEventListenersRobustos();
     
     // üö® CORRE√á√ÉO CR√çTICA MULTI-PLATAFORMA: Verifica√ß√£o peri√≥dica como fallback
     // Algumas plataformas m√≥veis podem n√£o disparar eventos corretamente, ent√£o verificamos periodicamente
     // Isso garante que os nomes sejam carregados mesmo se os eventos falharem
     let ultimaVerificacao = { comum: '', cargo: '' };
     let intervaloVerificacao = null;
     
     function iniciarVerificacaoPeriodica() {
       // Limpar intervalo anterior se existir
       if (intervaloVerificacao) {
         clearInterval(intervaloVerificacao);
       }
       
       // Verificar a cada 2 segundos se comum + cargo est√£o preenchidos mas nomes n√£o foram carregados
       intervaloVerificacao = setInterval(() => {
         const comumEl = findComumField();
         const cargoEl = findCargoField();
         const nomeEl = findNomeField();
         
         if (!comumEl || !cargoEl || !nomeEl) {
           return;
         }
         
         const comum = comumEl.value?.trim() || '';
         const cargo = cargoEl.value?.trim() || '';
         
         // Se ambos est√£o preenchidos
         if (comum && cargo) {
           // Verificar se os valores mudaram desde a √∫ltima verifica√ß√£o
           if (ultimaVerificacao.comum !== comum || ultimaVerificacao.cargo !== cargo) {
             ultimaVerificacao = { comum, cargo };
             
             // Verificar se os nomes j√° foram carregados
             const temNomesCarregados = window.nomesData && Array.isArray(window.nomesData) && window.nomesData.length > 0;
             const nomeElTemOpcoes = nomeEl.tagName === 'SELECT' && nomeEl.options.length > 1;
             
             // Se n√£o tem nomes carregados, carregar agora
             if (!temNomesCarregados || !nomeElTemOpcoes) {
               console.log('üîÑ Verifica√ß√£o peri√≥dica: Comum e Cargo preenchidos mas nomes n√£o carregados, carregando agora...', { comum, cargo });
               window.verificarECarregarNomes();
             }
           }
         } else {
           // Se n√£o est√£o mais preenchidos, resetar √∫ltima verifica√ß√£o
           ultimaVerificacao = { comum: '', cargo: '' };
         }
       }, 2000); // Verificar a cada 2 segundos
       
       console.log('‚úÖ Verifica√ß√£o peri√≥dica iniciada para garantir carregamento de nomes');
     }
     
     // Iniciar verifica√ß√£o peri√≥dica apenas em mobile (onde h√° mais problemas)
     if (isMobile) {
       iniciarVerificacaoPeriodica();
     }
   
     if (comumEl) {
       comumEl.addEventListener('change', function() {
         // üö® CORRE√á√ÉO CR√çTICA: Resetar estado de digita√ß√£o manual ao mudar comum
         const nomeEl = findNomeField();
         if (nomeEl) {
           nomeEl.removeAttribute('data-nome-manual');
           nomeEl.removeAttribute('data-selected-from-list');
           if (nomeEl.style) {
             nomeEl.style.backgroundColor = '';
             nomeEl.style.borderColor = '';
           }
         }
         debouncedLoadNomes();
       });
     }
     if (instEl)  {
       // üîß CORRE√á√ÉO: Debounce para otimizar performance e evitar m√∫ltiplas requisi√ß√µes
       const debouncedInstrumentChange = debounce(function(e) {
         const novoInstrumento = e.target.value;
         console.log('üé∫ INSTRUMENTO ALTERADO:', novoInstrumento);
         
         // üîß CORRE√á√ÉO CR√çTICA: Limpa imediatamente o campo de nomes para evitar confus√£o
         limparCampoNomes();
         
         // Limpar cache do instrumento anterior
         clearInstrumentCache();
         
         // üö® CORRE√á√ÉO CR√çTICA: Resetar estado de digita√ß√£o manual ao mudar instrumento
         const nomeEl = findNomeField();
         if (nomeEl) {
           nomeEl.removeAttribute('data-nome-manual');
           nomeEl.removeAttribute('data-selected-from-list');
           if (nomeEl.style) {
             nomeEl.style.backgroundColor = '';
             nomeEl.style.borderColor = '';
           }
         }
         
         // Carregar novos nomes
         console.log('üîÑ Recarregando lista de nomes para o novo instrumento...');
         loadNomes();
       }, 300); // üö® CORRE√á√ÉO: Debounce aumentado para 300ms (era 150ms - muito curto quebrava a l√≥gica)
       
       instEl.addEventListener('change', function(e) {
         // üö® CORRE√á√ÉO CR√çTICA: Resetar estado de digita√ß√£o manual ao mudar instrumento
         const nomeEl = findNomeField();
         if (nomeEl) {
           nomeEl.removeAttribute('data-nome-manual');
           nomeEl.removeAttribute('data-selected-from-list');
           if (nomeEl.style) {
             nomeEl.style.backgroundColor = '';
             nomeEl.style.borderColor = '';
           }
         }
         debouncedInstrumentChange(e);
       });
       
       // üîß CORRE√á√ÉO ADICIONAL: Limpa imediatamente quando o usu√°rio muda o valor
       // Mesmo antes do debounce, para dar feedback visual imediato
       instEl.addEventListener('input', function(e) {
         const novoInstrumento = e.target.value;
         console.log('üé∫ INSTRUMENTO SENDO ALTERADO (input):', novoInstrumento);
         
         // Marca nova requisi√ß√£o como mais recente (requisi√ß√µes antigas ser√£o ignoradas quando completarem)
         loadNomesRequestId = Date.now();
         
         // Limpa imediatamente o campo de nomes
         limparCampoNomes();
       });
     }
     if (cargoEl) {
       cargoEl.addEventListener('change', function() {
         console.log('üö® CARGO ALTERADO - carregando nomes imediatamente');
         // üö® CORRE√á√ÉO CR√çTICA: Resetar estado de digita√ß√£o manual ao mudar cargo
         const nomeEl = findNomeField();
         if (nomeEl) {
           nomeEl.removeAttribute('data-nome-manual');
           nomeEl.removeAttribute('data-selected-from-list');
           if (nomeEl.style) {
             nomeEl.style.backgroundColor = '';
             nomeEl.style.borderColor = '';
           }
         }
         // üö® CORRE√á√ÉO CR√çTICA: Chamar loadNomes diretamente (sem debounce) para resposta imediata
         toggleInstrumentFieldVisibility();
         loadNomes(); // Chamar diretamente para garantir que execute imediatamente
       });
       
       // üõ°Ô∏è MOBILE FIX: Adiciona eventos espec√≠ficos para mobile
       if (isMobile) {
         cargoEl.addEventListener('input', toggleInstrumentFieldVisibility);
         cargoEl.addEventListener('blur', toggleInstrumentFieldVisibility);
         cargoEl.addEventListener('touchend', () => {
           setTimeout(toggleInstrumentFieldVisibility, 100);
         });
         
         // üöÄ MOBILE FIX: Adiciona eventos para instrumento tamb√©m
         if (instEl) {
           instEl.addEventListener('input', function(e) {
             console.log('üì± MOBILE - Instrumento alterado:', e.target.value);
             clearInstrumentCache();
             setTimeout(() => {
               const comum = comumEl.value;
               const cargo = cargoEl.value;
               const instrumento = instEl.value;
               loadNomes(comum, instrumento, cargo, cargo.toUpperCase(), true);
             }, 100);
           });
         }
       }
     }
     
   
     loadNomes();
     
     // Define visibilidade inicial do campo instrumento
     toggleInstrumentFieldVisibility();
     
     // üõ°Ô∏è MOBILE FIX: Executa novamente ap√≥s delay para garantir que funcione no mobile
     if (isMobile) {
       setTimeout(toggleInstrumentFieldVisibility, 300);
       setTimeout(toggleInstrumentFieldVisibility, 600);
       setTimeout(toggleInstrumentFieldVisibility, 1000);
     }
   
     const form = document.querySelector('form#formPresenca, form') || null;
     const btn  = getSubmitButton();
     if (form)  form.addEventListener('submit', handleSubmit);
     if (!form && btn) btn.addEventListener('click', handleSubmit);
   
     const logoutBtn = document.getElementById('logoutBtn');
     if (logoutBtn) {
       logoutBtn.addEventListener('click', handleLogout);
     }
   
    const btnAbrirModal = document.getElementById('btnAbrirModal');
    if (btnAbrirModal) {
      btnAbrirModal.addEventListener('click', (e) => {
        e.preventDefault();
        if (typeof bootstrap !== 'undefined') {
          const modalEl = document.getElementById('modalNovaComum');
          if (!modalEl) {
            console.error('‚ùå Modal modalNovaComum n√£o encontrado!');
            return;
          }
          
          const modal = new bootstrap.Modal(modalEl);
          
          // Detectar se √© mobile
          const isMobileBtn = window.innerWidth <= 768 || /Mobile|Android|iPhone|iPad/.test(navigator.userAgent);
          
          // Fun√ß√£o para carregar cargos
          const carregarCargosBtn = () => {
            if (typeof window.carregarCargosModal === 'function') {
              window.carregarCargosModal();
            } else if (typeof carregarCargosModal === 'function') {
              carregarCargosModal();
            } else {
              // Carrega diretamente
              const cargoSelect = document.getElementById('gsCargo');
              if (cargoSelect) {
                const cargos = window.CARGOS_COMPLETOS_MODAL || [
                  'M√∫sico', 'Organista', 'Instrutor', 'Instrutora', 'Examinadora',
                  'Encarregado Local', 'Encarregado Regional', 'Secret√°rio da M√∫sica', 'Secret√°ria da M√∫sica',
                  'Irmandade', 'Anci√£o', 'Di√°cono', 'Cooperador do Of√≠cio', 'Cooperador de Jovens',
                  'Porteiro (a)', 'Bombeiro (a)', 'M√©dico (a)', 'Enfermeiro (a)'
                ];
                cargoSelect.innerHTML = '<option value="">Selecione o cargo...</option>' +
                  cargos.map(cargo => `<option value="${cargo}">${cargo}</option>`).join('');
              }
            }
            if (typeof window.carregarInstrumentosModal === 'function') {
              window.carregarInstrumentosModal();
            }
          };
          
          // üöÄ CORRE√á√ÉO MOBILE: Carregar no show.bs.modal tamb√©m
          modalEl.addEventListener('show.bs.modal', function carregarCargosShow() {
            if (isMobileBtn) {
              setTimeout(() => {
                console.log('üì± Mobile: Carregando cargos no show.bs.modal (btnAbrirModal)...');
                carregarCargosBtn();
              }, 50);
            }
          });
          
          // üöÄ CORRE√á√ÉO CR√çTICA: Carregar cargos IMEDIATAMENTE ap√≥s abrir
          modalEl.addEventListener('shown.bs.modal', function carregarCargosAposAbrir() {
            console.log('‚úÖ Modal aberto via btnAbrirModal - carregando cargos...');
            
            const delay = isMobileBtn ? 200 : 150;
            setTimeout(() => {
              carregarCargosBtn();
            }, delay);
            
            // üöÄ CORRE√á√ÉO MOBILE: Verificar e tentar novamente no mobile
            if (isMobileBtn) {
              setTimeout(() => {
                const cargoSelect = document.getElementById('gsCargo');
                if (cargoSelect && cargoSelect.options.length <= 2) {
                  console.log('üì± Mobile: Cargos n√£o carregados, tentando novamente...');
                  carregarCargosBtn();
                }
              }, 500);
            }
            
            // Remove o listener ap√≥s executar
            modalEl.removeEventListener('shown.bs.modal', carregarCargosAposAbrir);
          }, { once: true });
          
          modal.show();
        } else {
          showToast('warning', 'Modal n√£o dispon√≠vel', 'Bootstrap n√£o carregado', 3000);
        }
      });
    }

    // CORRE√á√ÉO CR√çTICA: Adicionar evento para carregar cargos quando modal abrir
    const modalNovaComum = document.getElementById('modalNovaComum');
    if (modalNovaComum) {
      // Fun√ß√£o para carregar dados do modal
      const carregarDadosModal = () => {
        console.log('üîÑ Carregando dados do modal...');
        console.log('üîç Verificando fun√ß√µes dispon√≠veis...');
        console.log('üîç carregarCargosModal:', typeof carregarCargosModal);
        console.log('üîç window.carregarCargosModal:', typeof window.carregarCargosModal);
        console.log('üîç CARGOS_COMPLETOS_MODAL:', typeof CARGOS_COMPLETOS_MODAL);
        console.log('üîç window.CARGOS_COMPLETOS_MODAL:', typeof window.CARGOS_COMPLETOS_MODAL);
        
        // Aguarda um pouco para garantir que o modal est√° completamente renderizado
        setTimeout(() => {
          // Tenta m√∫ltiplas formas de chamar a fun√ß√£o
          if (typeof carregarCargosModal === 'function') {
            console.log('‚úÖ Chamando carregarCargosModal (escopo local)...');
            carregarCargosModal();
          } else if (typeof window.carregarCargosModal === 'function') {
            console.log('‚úÖ Chamando window.carregarCargosModal...');
            window.carregarCargosModal();
          } else {
            console.error('‚ùå Fun√ß√£o carregarCargosModal n√£o encontrada!');
            // Tenta carregar diretamente
            const cargoSelect = document.getElementById('gsCargo');
            if (cargoSelect) {
              console.log('‚ö†Ô∏è Tentando carregar cargos diretamente...');
              const cargos = window.CARGOS_COMPLETOS_MODAL || CARGOS_COMPLETOS_MODAL || [
                'M√∫sico', 'Organista', 'Instrutor', 'Instrutora', 'Examinadora',
                'Encarregado Local', 'Encarregado Regional', 'Secret√°rio da M√∫sica', 'Secret√°ria da M√∫sica',
                'Irmandade', 'Anci√£o', 'Di√°cono', 'Cooperador do Of√≠cio', 'Cooperador de Jovens',
                'Porteiro (a)', 'Bombeiro (a)', 'M√©dico (a)', 'Enfermeiro (a)'
              ];
              
              cargoSelect.innerHTML = '<option value="">Selecione o cargo...</option>';
              cargos.forEach(cargo => {
                const option = document.createElement('option');
                option.value = cargo;
                option.textContent = cargo;
                cargoSelect.appendChild(option);
              });
              console.log('‚úÖ Cargos carregados diretamente:', cargos.length);
            }
          }
          
          if (typeof carregarInstrumentosModal === 'function') {
            carregarInstrumentosModal();
          } else if (typeof window.carregarInstrumentosModal === 'function') {
            window.carregarInstrumentosModal();
          }
        }, 300);
      };
      
      // Adiciona listener para o evento shown.bs.modal
      modalNovaComum.addEventListener('shown.bs.modal', function() {
        console.log('‚úÖ Modal modalNovaComum aberto - carregando cargos...');
        carregarDadosModal();
      }, { once: false }); // Permite m√∫ltiplas chamadas
      
      // Tamb√©m tenta carregar quando o modal √© aberto via Bootstrap
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
            const modal = mutation.target;
            if (modal.classList.contains('show') && !modal.classList.contains('modal-loading')) {
              modal.classList.add('modal-loading');
              console.log('‚úÖ Modal detectado como aberto via MutationObserver - carregando dados...');
              carregarDadosModal();
            }
          }
        });
      });
      
      observer.observe(modalNovaComum, { attributes: true, attributeFilter: ['class'] });
    }
   
     // Event listener para bot√£o de edi√ß√£o (apenas para usu√°rios master)
     const editBtn = document.getElementById('editBtn');
     if (editBtn) {
       editBtn.addEventListener('click', async function() {
         console.log('üìù Redirecionando para p√°gina de edi√ß√£o...');
         
         // Verificar se √© master antes de redirecionar
         const isMaster = await verificarStatusMaster();
         if (!isMaster) {
           showToast('error', 'Sem permiss√£o', 'Apenas usu√°rios master podem editar registros', 3000);
           return;
         }
         
         // Redirecionar para p√°gina de edi√ß√£o
         window.location.href = './editar.html';
       });
     }
   
     // Bot√£o de sincroniza√ß√£o manual
     const syncBtn = document.getElementById('syncBtn');
     if (syncBtn) {
       syncBtn.addEventListener('click', async function() {
         console.log('üîÑ Bot√£o de sincroniza√ß√£o clicado');
         
         // Desabilita o bot√£o temporariamente
         syncBtn.disabled = true;
         syncBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i>';
         
         try {
           await forcarSincronizacao();
         } finally {
           // Reabilita o bot√£o
           syncBtn.disabled = false;
           syncBtn.innerHTML = '<i class="fa-solid fa-sync-alt"></i>';
         }
       });
     }
   
     // Bot√£o de processamento for√ßado
     const forceBtn = document.getElementById('forceBtn');
     if (forceBtn) {
       forceBtn.addEventListener('click', async function() {
         console.log('‚ö° Bot√£o de processamento for√ßado clicado');
         
         // Desabilita o bot√£o temporariamente
         forceBtn.disabled = true;
         forceBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i>';
         
         try {
           const resultado = await forcarProcessamentoFila();
           if (resultado.success) {
             showToast('success', 'Sucesso', resultado.message, 3000);
           } else {
             showToast('error', 'Erro', resultado.message, 3000);
           }
         } finally {
           // Reabilita o bot√£o
           forceBtn.disabled = false;
           forceBtn.innerHTML = '<i class="fa-solid fa-bolt"></i>';
         }
       });
     }
   
     // flushQueue(); // Desabilitado para melhorar performance
     
     // Atalhos de teclado
     document.addEventListener('keydown', (e) => {
       // Envio r√°pido (Ctrl+Enter ou Cmd+Enter)
       if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
         e.preventDefault();
         const submitBtn = getSubmitButton();
         if (submitBtn && !submitBtn.disabled) {
           console.log('‚ö° Envio r√°pido via teclado');
           submitBtn.click();
         }
       }
       
       // Foco no campo de comum (Ctrl+F ou Cmd+F)
       if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
         e.preventDefault();
         const comumInput = document.getElementById('comumInput');
         if (comumInput) {
           comumInput.focus();
           comumInput.select();
           console.log('üîç Foco no campo de comum via teclado');
         }
       }
     });
     
     // Inicializa o modal
     inicializarModal();
     
    // Fallback: carrega dados do modal ap√≥s 3 segundos se n√£o foram carregados (otimizado para online)
    setTimeout(() => {
      const cargoSelect = document.getElementById('gsCargo');
      const instrumentoSelect = document.getElementById('gsInstrumento');
      
      if (cargoSelect && cargoSelect.innerHTML.includes('Carregando cargos')) {
        console.log('üîÑ Fallback: Carregando cargos (online)...');
        try {
          carregarCargosModal();
        } catch (error) {
          console.error('‚ùå Erro no fallback de cargos:', error);
        }
      }
      
      if (instrumentoSelect && instrumentoSelect.innerHTML.includes('Carregando instrumentos')) {
        console.log('üîÑ Fallback: Carregando instrumentos (online)...');
        try {
          carregarInstrumentosModal();
        } catch (error) {
          console.error('‚ùå Erro no fallback de instrumentos:', error);
        }
      }
    }, 3000); // Timeout maior para ambiente online
     
    // Adiciona evento de clique no link do modal para for√ßar carregamento (otimizado para online)
    const modalLink = document.querySelector('[data-bs-target="#modalNovaComum"]');
    if (modalLink) {
      modalLink.addEventListener('click', function() {
        console.log('üîó Link do modal clicado - for√ßando carregamento (online)...');
        
        // CORRE√á√ÉO PARA ONLINE: Delays maiores para ambiente online
        setTimeout(() => {
          try {
            carregarCargosModal();
          } catch (error) {
            console.error('‚ùå Erro ao carregar cargos no fallback:', error);
          }
        }, 500);
        
        setTimeout(() => {
          try {
            carregarInstrumentosModal();
          } catch (error) {
            console.error('‚ùå Erro ao carregar instrumentos no fallback:', error);
          }
        }, 800);
      });
    }
     
     console.log('üéâ Aplica√ß√£o carregada com sucesso!');
     
     } catch (error) {
       console.error('‚ùå Erro ao carregar aplica√ß√£o:', error);
       showToast('error', 'Erro de inicializa√ß√£o', 'Verifique o console para detalhes', 5000);
     }
   });
   
   // Fun√ß√£o para limpar overlays no Android
   function clearAndroidOverlays() {
     const isAndroid = /Android/.test(navigator.userAgent);
     if (isAndroid) {
       const overlays = document.querySelectorAll('.suggestions-overlay, #suggestionsOverlay');
       overlays.forEach(overlay => {
         overlay.remove();
         console.log('ü§ñ Overlay removido do Android');
       });
     }
   }
   
   // Limpa overlays no Android quando a p√°gina carrega
   clearAndroidOverlays();
   
   /* ===== PWA - PROGRESSIVE WEB APP ===== */
   
   // Vari√°veis globais para PWA
   let deferredPrompt = null;
   let isInstalled = false;
   
   // Verificar se o app j√° est√° instalado
   function checkIfInstalled() {
     // Verificar se est√° rodando em modo standalone (instalado)
     if (window.matchMedia('(display-mode: standalone)').matches || 
         window.navigator.standalone === true) {
       isInstalled = true;
       console.log('üì± PWA: App j√° est√° instalado');
       return true;
     }
     return false;
   }
   
   // Registrar Service Worker
   async function registerServiceWorker() {
     // Verificar se Service Worker √© suportado
     if (!('serviceWorker' in navigator)) {
       console.log('‚ÑπÔ∏è PWA: Service Worker n√£o suportado neste navegador');
       return null;
     }
     
     // Verificar se n√£o est√° em protocolo file://
     if (window.location.protocol === 'file:') {
       console.log('‚ÑπÔ∏è PWA: Service Worker n√£o funciona com protocolo file:// - use um servidor HTTP');
       return null;
     }
     
     // Verificar se n√£o est√° em localhost sem HTTPS (exceto localhost)
     if (window.location.protocol === 'http:' && !window.location.hostname.includes('localhost')) {
       console.log('‚ÑπÔ∏è PWA: Service Worker requer HTTPS em produ√ß√£o');
       return null;
     }
     
     try {
       console.log('üîß PWA: Registrando Service Worker...');
       
       const registration = await navigator.serviceWorker.register('./sw.js', {
         scope: './'
       });
       
       console.log('‚úÖ PWA: Service Worker registrado com sucesso', registration);
       
       // Verificar atualiza√ß√µes
       registration.addEventListener('updatefound', () => {
         const newWorker = registration.installing;
         newWorker.addEventListener('statechange', () => {
           if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
             console.log('üîÑ PWA: Nova vers√£o dispon√≠vel');
             showUpdateNotification();
           }
         });
       });
       
       return registration;
     } catch (error) {
       console.error('‚ùå PWA: Erro ao registrar Service Worker:', error);
       console.log('üí° Dica: Certifique-se de que est√° executando em um servidor HTTP/HTTPS');
       return null;
     }
   }
   
   // Mostrar notifica√ß√£o de atualiza√ß√£o
   function showUpdateNotification() {
     if (typeof Swal !== 'undefined') {
       Swal.fire({
         title: 'Nova vers√£o dispon√≠vel!',
         text: 'Uma nova vers√£o do app est√° dispon√≠vel. Deseja atualizar?',
         icon: 'info',
         showCancelButton: true,
         confirmButtonText: 'Atualizar',
         cancelButtonText: 'Depois',
         confirmButtonColor: '#3b82f6',
         cancelButtonColor: '#6b7280'
       }).then((result) => {
         if (result.isConfirmed) {
           window.location.reload();
         }
       });
     }
   }
   
   // Detectar evento de instala√ß√£o
   function setupInstallPrompt() {
     window.addEventListener('beforeinstallprompt', (e) => {
       console.log('üì± PWA: Evento beforeinstallprompt disparado');
       e.preventDefault();
       deferredPrompt = e;
       
       // Mostrar bot√£o de instala√ß√£o se n√£o estiver instalado
       if (!checkIfInstalled()) {
         showInstallButton();
       }
     });
     
     // Detectar quando o app √© instalado
     window.addEventListener('appinstalled', () => {
       console.log('‚úÖ PWA: App instalado com sucesso!');
       isInstalled = true;
       hideInstallButton();
       
       if (typeof Swal !== 'undefined') {
         Swal.fire({
           title: 'App instalado!',
           text: 'O CCB Presen√ßa foi instalado com sucesso na sua tela inicial.',
           icon: 'success',
           timer: 3000,
           showConfirmButton: false
         });
       }
     });
   }
   
   // Mostrar bot√£o de instala√ß√£o
   function showInstallButton() {
     // Verificar se j√° existe o bot√£o
     if (document.getElementById('pwaInstallBtn')) return;
     
     // Criar bot√£o de instala√ß√£o
     const installBtn = document.createElement('button');
     installBtn.id = 'pwaInstallBtn';
     installBtn.className = 'btn btn-outline-primary btn-sm';
     installBtn.innerHTML = '<i class="fa-solid fa-download me-1"></i>Instalar App';
     installBtn.style.cssText = `
       position: fixed;
       bottom: 20px;
       right: 20px;
       z-index: 1000;
       border-radius: 25px;
       padding: 10px 20px;
       font-size: 14px;
       font-weight: 600;
       box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
       animation: pulse 2s infinite;
     `;
     
     // Adicionar anima√ß√£o CSS
     if (!document.getElementById('pwaInstallStyles')) {
       const style = document.createElement('style');
       style.id = 'pwaInstallStyles';
       style.textContent = `
         @keyframes pulse {
           0% { transform: scale(1); }
           50% { transform: scale(1.05); }
           100% { transform: scale(1); }
         }
         @media (max-width: 768px) {
           #pwaInstallBtn {
             bottom: 80px !important;
             right: 16px !important;
             left: 16px !important;
             width: auto !important;
           }
         }
       `;
       document.head.appendChild(style);
     }
     
     // Adicionar evento de clique
     installBtn.addEventListener('click', installPWA);
     
     // Adicionar ao DOM
     document.body.appendChild(installBtn);
     
     console.log('üì± PWA: Bot√£o de instala√ß√£o exibido');
   }
   
   // Esconder bot√£o de instala√ß√£o
   function hideInstallButton() {
     const installBtn = document.getElementById('pwaInstallBtn');
     if (installBtn) {
       installBtn.remove();
       console.log('üì± PWA: Bot√£o de instala√ß√£o removido');
     }
   }
   
   // Instalar PWA
   async function installPWA() {
     if (!deferredPrompt) {
       console.log('‚ùå PWA: Prompt de instala√ß√£o n√£o dispon√≠vel');
       
       // Fallback para iOS
       if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
         showIOSInstallInstructions();
       } else {
         showToast('info', 'Instala√ß√£o', 'Use o menu do navegador para instalar o app', 3000);
       }
       return;
     }
     
     try {
       console.log('üì± PWA: Iniciando instala√ß√£o...');
       
       // Mostrar o prompt de instala√ß√£o
       deferredPrompt.prompt();
       
       // Aguardar a resposta do usu√°rio
       const { outcome } = await deferredPrompt.userChoice;
       
       console.log(`üì± PWA: Resultado da instala√ß√£o: ${outcome}`);
       
       if (outcome === 'accepted') {
         console.log('‚úÖ PWA: Usu√°rio aceitou a instala√ß√£o');
       } else {
         console.log('‚ùå PWA: Usu√°rio rejeitou a instala√ß√£o');
       }
       
       // Limpar o prompt
       deferredPrompt = null;
       hideInstallButton();
       
     } catch (error) {
       console.error('‚ùå PWA: Erro durante a instala√ß√£o:', error);
     }
   }
   
   // Mostrar instru√ß√µes de instala√ß√£o para iOS
   function showIOSInstallInstructions() {
     if (typeof Swal !== 'undefined') {
       Swal.fire({
         title: 'Instalar no iPhone/iPad',
         html: `
           <div style="text-align: left; font-size: 14px;">
             <p><strong>Para instalar este app:</strong></p>
             <ol>
               <li>Toque no bot√£o <strong>Compartilhar</strong> <i class="fa-solid fa-share"></i> na parte inferior da tela</li>
               <li>Role para baixo e toque em <strong>"Adicionar √† Tela Inicial"</strong></li>
               <li>Toque em <strong>"Adicionar"</strong> no canto superior direito</li>
             </ol>
             <p style="margin-top: 15px; color: #6b7280;">
               <i class="fa-solid fa-info-circle"></i> 
               O app aparecer√° na sua tela inicial como um √≠cone nativo.
             </p>
           </div>
         `,
         icon: 'info',
         confirmButtonText: 'Entendi',
         confirmButtonColor: '#3b82f6',
         width: '90%',
         maxWidth: '400px'
       });
     }
   }
   
   // Monitorar status de conex√£o
   function setupConnectionMonitoring() {
     window.addEventListener('online', async () => {
       isOnline = true;
       console.log('üåê PWA: Conex√£o restaurada - usando processamento centralizado');
       // Removido alerta de conex√£o online - n√£o √© necess√°rio
       await processQueueOnConnectionRestore();
     });
     
     window.addEventListener('offline', () => {
       isOnline = false;
       console.log('üì¥ PWA: Conex√£o perdida');
       // showToast('warning', 'Offline', 'Voc√™ est√° offline. Algumas funcionalidades podem estar limitadas.', 3000); // Removido - alerta desnecess√°rio
     });
   }
   
   // Verificar recursos PWA
   function checkPWASupport() {
     const support = {
       serviceWorker: 'serviceWorker' in navigator,
       pushManager: 'PushManager' in window,
       notification: 'Notification' in window,
       installPrompt: 'onbeforeinstallprompt' in window,
       standalone: window.matchMedia('(display-mode: standalone)').matches
     };
     
     console.log('üì± PWA: Suporte dispon√≠vel:', support);
     return support;
   }
   
   // Inicializar PWA
   async function initPWA() {
     console.log('üöÄ PWA: Inicializando Progressive Web App...');
     
     // Verificar suporte
     const support = checkPWASupport();
     
     if (!support.serviceWorker) {
       console.log('‚ÑπÔ∏è PWA: Service Worker n√£o suportado neste navegador');
       console.log('‚úÖ PWA: Inicializa√ß√£o conclu√≠da (sem Service Worker)');
       return;
     }
     
     // Verificar se j√° est√° instalado
     checkIfInstalled();
     
     // Registrar Service Worker (com verifica√ß√£o de protocolo)
     const swRegistration = await registerServiceWorker();
     
     if (swRegistration) {
       console.log('‚úÖ PWA: Service Worker registrado com sucesso');
     } else {
       console.log('‚ÑπÔ∏è PWA: Service Worker n√£o registrado (protocolo n√£o suportado)');
     }
     
     // Configurar eventos de instala√ß√£o
     setupInstallPrompt();
     
     // Monitorar conex√£o
     setupConnectionMonitoring();
     
     console.log('‚úÖ PWA: Inicializa√ß√£o conclu√≠da');
   }
   
   // Inicializar PWA quando a p√°gina carregar
   document.addEventListener('DOMContentLoaded', () => {
     // Aguardar um pouco para n√£o interferir com a inicializa√ß√£o principal
     setTimeout(() => {
       initPWA();
     }, 1000);
   });
   
   // Fun√ß√£o para verificar status das filas
   function verificarStatusFilas() {
     const filaLocal = JSON.parse(localStorage.getItem('fila_envio') || '[]');
     const filaSupabase = JSON.parse(localStorage.getItem('fila_supabase') || '[]');
     
     console.log('üìä Status das filas:');
     console.log(`  üìã Fila Local: ${filaLocal.length} item(s)`);
     console.log(`  üóÑÔ∏è Fila Supabase: ${filaSupabase.length} item(s)`);
     
     if (filaLocal.length > 0) {
       console.log('üîç Itens na fila local:', filaLocal.map((item, index) => ({
         index: index + 1,
         uuid: item.uuid,
         nome: item.nome,
         status: item.status,
         tentativas: item.tentativas || 0
       })));
     }
     
     if (filaSupabase.length > 0) {
       console.log('üîç Itens na fila Supabase:', filaSupabase.map((item, index) => ({
         index: index + 1,
         uuid: item.uuid,
         nome: item.nome,
         status: item.status,
         tentativas: item.tentativas || 0
       })));
     }
     
     return {
       filaLocal: filaLocal.length,
       filaSupabase: filaSupabase.length,
       total: filaLocal.length + filaSupabase.length
     };
   }
   
   // Fun√ß√£o para for√ßar sincroniza√ß√£o manual
   async function forcarSincronizacao() {
     try {
       console.log('üîÑ For√ßando sincroniza√ß√£o manual...');
       
       // Verifica status das filas antes
       const statusAntes = verificarStatusFilas();
       
       if (statusAntes.total === 0) {
         showToast('info', 'Info', 'Nenhum registro pendente para sincronizar', 2000);
         return true;
       }
       
       const isOnline = await checkSupabaseConnection();
       if (!isOnline) {
         showToast('error', 'Erro', 'Sem conex√£o com o servidor', 3000);
         return false;
       }
       
       // Alerta removido para acelerar processamento
       
       // Processa ambas as filas
       await processarFilaLocal();
       await processarFilaSupabase();
       
       // Verifica status das filas depois
       const statusDepois = verificarStatusFilas();
       const processados = statusAntes.total - statusDepois.total;
       
       if (processados > 0) {
         // showToast('success', 'Sucesso', `${processados} registro(s) sincronizado(s) com sucesso!`, 3000); // Removido - alerta desnecess√°rio
       } else {
         // showToast('warning', 'Aviso', 'Nenhum registro foi processado. Verifique os logs.', 3000); // Removido - alerta desnecess√°rio
       }
       
       return true;
       
     } catch (error) {
       console.error('‚ùå Erro na sincroniza√ß√£o manual:', error);
       showToast('error', 'Erro', 'Falha na sincroniza√ß√£o', 3000);
       return false;
     }
   }
   
   // Fun√ß√£o para for√ßar processamento da fila SEM verifica√ß√£o de conectividade
   async function forcarProcessamentoFila() {
     try {
       console.log('üöÄ FOR√áANDO processamento da fila (bypass de conectividade)...');
       
       const filaLocal = JSON.parse(localStorage.getItem('fila_envio') || '[]');
       const filaSupabase = JSON.parse(localStorage.getItem('fila_supabase') || '[]');
       
       if (filaLocal.length === 0 && filaSupabase.length === 0) {
         console.log('üì≠ Nenhuma fila para processar');
         return { success: true, message: 'Nenhuma fila para processar' };
       }
       
       console.log(`üìä Processando: ${filaLocal.length} local + ${filaSupabase.length} supabase`);
       
       let totalProcessados = 0;
       let totalErros = 0;
       
       // Processa fila local
       if (filaLocal.length > 0) {
         console.log('üîÑ Processando fila local...');
         for (let i = 0; i < filaLocal.length; i++) {
           const item = filaLocal[i];
           try {
             console.log(`üì§ Enviando item ${i + 1}: ${item.nome}`);
             
             // Tenta enviar para Google Sheets
             await enviarParaSheets(item);
             console.log(`‚úÖ Google Sheets OK: ${item.nome}`);
             
             // Tenta enviar para Supabase
             if (supabaseLoaded && sb) {
               await insertSupabase(item);
               console.log(`‚úÖ Supabase OK: ${item.nome}`);
             }
             
             totalProcessados++;
             
           } catch (error) {
             console.error(`‚ùå Erro no item ${i + 1}:`, error);
             totalErros++;
           }
         }
         
         // Remove itens processados da fila local
         if (totalProcessados > 0) {
           const itensRestantes = filaLocal.slice(totalProcessados);
           localStorage.setItem('fila_envio', JSON.stringify(itensRestantes));
           console.log(`‚úÖ Removidos ${totalProcessados} itens da fila local`);
         }
       }
       
       // Processa fila Supabase
       if (filaSupabase.length > 0) {
         console.log('üîÑ Processando fila Supabase...');
         for (let i = 0; i < filaSupabase.length; i++) {
           const item = filaSupabase[i];
           try {
             console.log(`üì§ Enviando item Supabase ${i + 1}: ${item.nome}`);
             await insertSupabase(item);
             totalProcessados++;
           } catch (error) {
             console.error(`‚ùå Erro no item Supabase ${i + 1}:`, error);
             totalErros++;
           }
         }
         
         // Remove itens processados da fila Supabase
         if (totalProcessados > 0) {
           const itensRestantes = filaSupabase.slice(totalProcessados);
           localStorage.setItem('fila_supabase', JSON.stringify(itensRestantes));
           console.log(`‚úÖ Removidos ${totalProcessados} itens da fila Supabase`);
         }
       }
       
       // Atualiza contador
       atualizarContadorFila();
       
       const resultado = {
         success: totalErros === 0,
         processados: totalProcessados,
         erros: totalErros,
         message: `${totalProcessados} processados, ${totalErros} erros`
       };
       
       console.log('üéØ Resultado do processamento for√ßado:', resultado);
       return resultado;
       
     } catch (error) {
       console.error('‚ùå Erro no processamento for√ßado:', error);
       return { success: false, message: error.message };
     }
   }
   
   // Exportar fun√ß√µes para uso global
   window.PWA = {
     install: installPWA,
     checkInstalled: checkIfInstalled,
     showInstallButton: showInstallButton,
     hideInstallButton: hideInstallButton,
     sync: forcarSincronizacao,
     status: verificarStatusFilas
   };
   
   // Fun√ß√£o para limpar filas
   function limparFilas() {
     try {
       localStorage.removeItem('queue');
       localStorage.removeItem('fila_envio');
       localStorage.removeItem('fila_supabase');
       updateQueueCount();
       console.log('üßπ Filas limpas com sucesso');
       return { success: true, message: 'Filas limpas' };
     } catch (error) {
       console.error('‚ùå Erro ao limpar filas:', error);
       return { success: false, message: error.message };
     }
   }
   
   // Fun√ß√£o de teste simples para debug
   async function testarEnvioSimples() {
     try {
       console.log('üß™ Testando envio simples...');
       
       // Cria um item de teste
       const itemTeste = {
         cargo: 'M√∫sico',
         ministerio: '',
         administracao: '',
         timestamp: getCurrentTimestamp(),
         nome: 'TESTE - ' + new Date().toLocaleTimeString(),
         comum: 'Itapevi',
         instrumento: 'Violino',
         local_ensaio: 'Local Teste',
         data_ensaio: new Date().toLocaleDateString('pt-BR'),
         registrado_por: 'Sistema Teste'
       };
       
       console.log('üì§ Item de teste:', itemTeste);
       
       // Testa envio direto
       try {
         const sent = await sendItem(itemTeste);
         if (sent) {
           console.log('‚úÖ Envio direto: OK');
         } else {
           console.log('‚ùå Envio direto: FALHOU');
         }
       } catch (error) {
         console.error('‚ùå Envio direto: ERRO', error.message);
       }
       
       return { success: true, message: 'Teste conclu√≠do' };
       
     } catch (error) {
       console.error('‚ùå Erro no teste:', error);
       return { success: false, message: error.message };
     }
   }
   
   // Fun√ß√£o para testar busca de comuns
   async function testarBuscaComuns() {
     try {
       console.log('üß™ Testando busca de comuns...');
       
       // Verifica dados atuais
       console.log('üìã Dados de comum atuais:', {
         comumData: comumData,
         comumDataLength: comumData.length,
         cache: searchCache.size
       });
       
       // Testa busca por "mir"
       const resultadosMir = searchComuns('mir');
       console.log('üîç Busca por "mir":', resultadosMir);
       
       // Testa busca por "mi"
       const resultadosMi = searchComuns('mi');
       console.log('üîç Busca por "mi":', resultadosMi);
       
       // Testa busca por "m"
       const resultadosM = searchComuns('m');
       console.log('üîç Busca por "m":', resultadosM);
       
       // Verifica se h√° comuns que cont√™m "mir"
       const comunsComMir = comumData.filter(comum => 
         comum.toLowerCase().includes('mir') || 
         comum.toLowerCase().includes('miranda')
       );
       console.log('üîç Comuns que cont√™m "mir" ou "miranda":', comunsComMir);
       
       // For√ßa recarregamento dos dados
       console.log('üîÑ For√ßando recarregamento dos dados...');
       await loadComunsFromCatalog();
       
       return {
         success: true,
         comumDataLength: comumData.length,
         resultadosMir: resultadosMir.length,
         resultadosMi: resultadosMi.length,
         resultadosM: resultadosM.length,
         comunsComMir: comunsComMir
       };
       
     } catch (error) {
       console.error('‚ùå Erro no teste:', error);
       return { success: false, message: error.message };
     }
   }
   
   // Fun√ß√£o para testar fila offline
   function testarFilaOffline() {
     console.log('üß™ Testando fila offline...');
     
     const queue = getOfflineQueue();
     const pendingCount = queue.filter(item => !item.synced).length;
     
     console.log('üìä Status da fila offline:', {
       total: queue.length,
       pending: pendingCount,
       synced: queue.length - pendingCount,
       items: queue.map(item => ({
         id: item.id,
         synced: item.synced,
         attempts: item.attempts,
         timestamp: new Date(item.timestamp).toLocaleString()
       }))
     });
     
     return {
       total: queue.length,
       pending: pendingCount,
       synced: queue.length - pendingCount,
       items: queue
     };
   }
   
   // Fun√ß√£o para for√ßar processamento da fila offline
   async function forcarProcessamentoFilaOffline() {
     console.log('üîÑ For√ßando processamento da fila offline...');
     
     // Loading removido para acelerar processamento
     
     try {
       // Limpar flag de processamento se estiver travada
       window.offlineQueueProcessing = false;
       
       // Verificar conectividade
       const isOnline = await checkSupabaseConnection();
       if (!isOnline) {
         console.log('‚ùå Sem conectividade - n√£o √© poss√≠vel processar a fila');
         showToast('error', 'Sem conex√£o', 'Verifique sua conex√£o com a internet', 3000);
         return false;
       }
       
       // Processar fila
       await processOfflineQueue();
       
       // Verificar se ainda h√° itens pendentes
       const queue = getOfflineQueue();
       const pendingItems = queue.filter(item => !item.synced);
       
       if (pendingItems.length === 0) {
         console.log('‚úÖ Fila offline processada com sucesso!');
         showToast('success', 'Sucesso', 'Todos os registros foram enviados', 3000);
         return true;
       } else {
         console.log(`‚ö†Ô∏è Ainda h√° ${pendingItems.length} itens pendentes`);
         showToast('warning', 'Parcial', `${pendingItems.length} registro(s) ainda pendente(s)`, 3000);
         return false;
       }
     } catch (error) {
       console.error('‚ùå Erro no processamento for√ßado:', error);
       showToast('error', 'Erro', 'Falha no processamento da fila', 3000);
       return false;
     }
   }
   
   // Fun√ß√£o para limpar fila offline
   function limparFilaOffline() {
     // Limpar todas as filas poss√≠veis
     localStorage.removeItem(OFFLINE_QUEUE_KEY);
     localStorage.removeItem('fila_envio');
     localStorage.removeItem('fila_supabase');
     localStorage.removeItem('queue');
     localStorage.removeItem('offline_queue_v3');
     localStorage.removeItem('offline_queue');
     localStorage.removeItem('fila_offline');
     localStorage.removeItem('pending_submissions');
     localStorage.removeItem('recent_submissions');
     
     updateQueueCount();
     console.log('üóëÔ∏è Todas as filas limpas - UUIDs antigos removidos');
   }
   
   // Fun√ß√£o para limpar dados antigos com UUIDs inv√°lidos (VERS√ÉO DEFINITIVA)
   function limparDadosAntigosComUUIDsInvalidos() {
     try {
       console.log('üßπ LIMPEZA DEFINITIVA de dados com UUIDs inv√°lidos...');
       
       // Limpar todas as poss√≠veis chaves de fila
       const chavesParaLimpar = [
         'offline_queue_v3',
         'offline_queue',
         'fila_offline',
         'pending_submissions',
         'recent_submissions',
         'queue',
         'fila_envio',
         'fila_supabase',
         'savedData',
         'fila_presencas_v2',
         'fila_presencas'
       ];
       
       let itensRemovidos = 0;
       
       chavesParaLimpar.forEach(chave => {
         try {
           const dados = localStorage.getItem(chave);
           if (dados) {
             const parsed = JSON.parse(dados);
             if (Array.isArray(parsed)) {
               // Filtrar itens com UUIDs inv√°lidos
               const itensValidos = parsed.filter(item => {
                 // Verificar UUID no campo 'uuid'
                 if (item.uuid && !isValidUUID(item.uuid)) {
                   console.log('üóëÔ∏è Removendo item com UUID inv√°lido (uuid):', item.uuid);
                   itensRemovidos++;
                   return false;
                 }
                 // Verificar UUID no campo 'id'
                 if (item.id && !isValidUUID(item.id)) {
                   console.log('üóëÔ∏è Removendo item com ID inv√°lido (id):', item.id);
                   itensRemovidos++;
                   return false;
                 }
                 // Verificar UUID em item.data.uuid
                 if (item.data && item.data.uuid && !isValidUUID(item.data.uuid)) {
                   console.log('üóëÔ∏è Removendo item com UUID inv√°lido (data.uuid):', item.data.uuid);
                   itensRemovidos++;
                   return false;
                 }
                 return true;
               });
               
               if (itensValidos.length !== parsed.length) {
                 localStorage.setItem(chave, JSON.stringify(itensValidos));
                 console.log(`‚úÖ Chave ${chave}: ${parsed.length - itensValidos} itens inv√°lidos removidos`);
               } else {
                 console.log(`‚úÖ Chave ${chave}: sem UUIDs inv√°lidos`);
               }
             }
           }
         } catch (error) {
           console.log(`‚ö†Ô∏è Erro ao processar chave ${chave}:`, error);
           // Se houver erro, remover a chave completamente
           localStorage.removeItem(chave);
         }
       });
       
       if (itensRemovidos > 0) {
         console.log(`‚úÖ Limpeza conclu√≠da: ${itensRemovidos} itens com UUIDs inv√°lidos removidos`);
         showToast('success', 'Limpeza Conclu√≠da', `${itensRemovidos} itens inv√°lidos removidos`, 3000);
       } else {
         console.log('‚úÖ Nenhum item com UUID inv√°lido encontrado');
         showToast('info', 'Limpeza Conclu√≠da', 'Nenhum item inv√°lido encontrado', 2000);
       }
       
     } catch (error) {
       console.error('‚ùå Erro na limpeza de dados antigos:', error);
       showToast('error', 'Erro', 'Falha na limpeza de dados antigos', 3000);
     }
   }
   
   // Fun√ß√£o para limpar UUIDs inv√°lidos da fila Supabase
   function limparUUIDsInvalidos() {
     try {
       const filaSupabase = JSON.parse(localStorage.getItem('fila_supabase') || '[]');
       const filaLimpa = filaSupabase.filter(item => {
         if (item.uuid && !isValidUUID(item.uuid)) {
           console.log('üóëÔ∏è Removendo item com UUID inv√°lido:', item.uuid);
           return false;
         }
         return true;
       });
       
       if (filaLimpa.length !== filaSupabase.length) {
         localStorage.setItem('fila_supabase', JSON.stringify(filaLimpa));
         console.log(`‚úÖ ${filaSupabase.length - filaLimpa.length} itens com UUIDs inv√°lidos removidos da fila Supabase`);
       }
       
       return filaSupabase.length - filaLimpa.length;
     } catch (error) {
       console.error('‚ùå Erro ao limpar UUIDs inv√°lidos:', error);
       return 0;
     }
   }
   
   // Fun√ß√£o para testar envio para Google Sheets
   async function testarEnvioGoogleSheets() {
     console.log('üß™ Testando envio para Google Sheets...');
     
     const testData = {
       uuid: uuidv4(),
       nome: "TESTE GOOGLE SHEETS",
       comum: "TESTE",
       cargo: "TESTE",
       instrumento: "TESTE",
       naipe: "TESTE",
       classe: "TESTE",
       local_ensaio: "TESTE",
       data_ensaio: new Date().toLocaleDateString('pt-BR'),
       registrado_por: "SISTEMA",
       user_id: "teste",
       anotacoes: "Teste de envio"
     };
     
     console.log('üì§ Dados de teste:', testData);
     
     const success = await sendToGoogleSheets(testData);
     
     if (success) {
       console.log('‚úÖ Teste de envio para Google Sheets: SUCESSO');
       return { success: true, message: 'Envio testado com sucesso' };
     } else {
       console.log('‚ùå Teste de envio para Google Sheets: FALHA');
       return { success: false, message: 'Falha no teste de envio' };
     }
   }
   
   // Fun√ß√£o para testar envio para Supabase
   async function testarEnvioSupabase() {
     console.log('üß™ Testando envio para Supabase...');
     
     if (!supabaseLoaded || !sb) {
       console.log('‚ùå Supabase n√£o dispon√≠vel');
       return { success: false, message: 'Supabase n√£o dispon√≠vel' };
     }
     
     const testData = {
       uuid: uuidv4(),
       created_at: new Date().toISOString(),
       nome: "TESTE SUPABASE",
       comum: "TESTE",
       local: null,
       cargo: "TESTE",
       instrumento: "TESTE",
       naipe: "TESTE",
       classe: "TESTE",
       nivel: "TESTE",
       local_ensaio: "TESTE",
       data_ensaio: new Date().toLocaleDateString('pt-BR'),
       data_ensaio_iso: new Date().toISOString().split('T')[0],
       email: "teste@teste.com",
       registrado_por: "SISTEMA",
       user_id: "teste",
       anotacoes: "Teste de envio Supabase"
     };
     
     console.log('üì§ Dados de teste para Supabase:', testData);
     
     try {
       await insertSupabase(testData);
       console.log('‚úÖ Teste de envio para Supabase: SUCESSO');
       return { success: true, message: 'Envio para Supabase testado com sucesso' };
     } catch (error) {
       console.error('‚ùå Teste de envio para Supabase: FALHA', error);
       return { success: false, message: `Falha no teste de envio: ${error.message}` };
     }
   }
   
   // Fun√ß√£o para testar fila offline
   async function testarFilaOffline() {
     console.log('üß™ Testando fila offline...');
     
     // Adicionar item de teste √† fila
     const testData = {
       uuid: uuidv4(),
       nome: "TESTE FILA OFFLINE",
       comum: "TESTE",
       cargo: "TESTE",
       instrumento: "TESTE",
       naipe: "TESTE",
       classe: "TESTE",
       nivel: "TESTE",
       local_ensaio: "TESTE",
       data_ensaio: new Date().toLocaleDateString('pt-BR'),
       data_ensaio_iso: new Date().toISOString().split('T')[0],
       email: "teste@teste.com",
       registrado_por: "SISTEMA",
       user_id: "teste",
       anotacoes: "TESTE FILA OFFLINE"
     };
     
     try {
       // Adicionar √† fila
       const recordId = addToOfflineQueue(testData);
       console.log('‚úÖ Item de teste adicionado √† fila:', recordId);
       
       // Verificar status da fila
       const queue = getOfflineQueue();
       const pendingItems = queue.filter(item => !item.synced);
       
       console.log(`üìä Status da fila: ${pendingItems.length} itens pendentes de ${queue.length} total`);
       
       // Tentar processar imediatamente
       setTimeout(async () => {
         console.log('üîÑ Tentando processar fila de teste...');
         await forcarProcessamentoFilaOffline();
       }, 2000);
       
       return { success: true, message: 'Item de teste adicionado √† fila' };
       
     } catch (error) {
       console.error('‚ùå Erro no teste da fila offline:', error);
       return { success: false, message: `Erro no teste da fila offline: ${error.message}` };
     }
   }
   
   // Fun√ß√£o para verificar status do PWA
   function verificarStatusPWA() {
     console.log('üß™ Verificando status do PWA...');
     
     const status = {
       protocol: window.location.protocol,
       hostname: window.location.hostname,
       serviceWorkerSupported: 'serviceWorker' in navigator,
       serviceWorkerRegistered: false,
       manifestSupported: 'onbeforeinstallprompt' in window,
       isInstalled: window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone
     };
     
     // Verificar se Service Worker est√° registrado
     if ('serviceWorker' in navigator) {
       navigator.serviceWorker.getRegistrations().then(registrations => {
         status.serviceWorkerRegistered = registrations.length > 0;
         console.log('üìä Status do PWA:', status);
       });
     } else {
       console.log('üìä Status do PWA:', status);
     }
     
     return status;
   }
   
   // Fun√ß√£o espec√≠fica para debug mobile offline
   function debugMobileOffline() {
     if (!isMobile) {
       console.log('üñ•Ô∏è Esta fun√ß√£o √© espec√≠fica para mobile');
       return { error: 'Fun√ß√£o espec√≠fica para mobile' };
     }
     
     console.log('üì± MOBILE: Iniciando debug completo do sistema offline...');
     
     const queue = getOfflineQueue();
     const pendingItems = queue.filter(item => !item.synced);
     const syncedItems = queue.filter(item => item.synced);
     
     const debugInfo = {
       device: {
         isMobile: isMobile,
         isIOS: isIOS,
         isAndroid: isAndroid,
         userAgent: navigator.userAgent
       },
       connectivity: {
         navigatorOnline: navigator.onLine,
         isOnline: isOnline,
         lastCheck: lastConnectivityCheck
       },
       queue: {
         total: queue.length,
         pending: pendingItems.length,
         synced: syncedItems.length,
         items: queue.map(item => ({
           id: item.id,
           nome: item.data?.nome || item.data?.NOME || 'Sem nome',
           synced: item.synced,
           attempts: item.attempts || 0,
           timestamp: new Date(item.timestamp).toLocaleString()
         }))
       },
       processing: {
         isProcessing: window.offlineQueueProcessing || false,
         syncInterval: syncIntervalId ? 'Ativo' : 'Inativo'
       }
     };
     
     console.log('üì± MOBILE: Debug completo:', debugInfo);
     
     // Testar conectividade
     checkSupabaseConnection().then(result => {
       console.log('üì± MOBILE: Teste de conectividade:', result);
     });
     
     return debugInfo;
   }
   
   // Exportar fun√ß√µes de debug para uso global
   window.DEBUG = {
     filas: testarFilaOffline,
     testFila: testarFilaOffline,
     sync: forcarProcessamentoFilaOffline,
     force: forcarProcessamentoFilaOffline,
     test: testarEnvioGoogleSheets,
     testSheets: testarEnvioGoogleSheets,
     testSupabase: testarEnvioSupabase,
     clear: limparFilaOffline,
     clearUUIDs: limparUUIDsInvalidos,
     limparAntigos: limparDadosAntigosComUUIDsInvalidos,
     conectividade: testConnectivity,
     forcarConectividade: forceConnectivityCheck,
     online: () => isOnline,
     queue: () => getOfflineQueue(),
     isMobile: () => isMobile,
     isDesktop: () => isDesktop,
     otimizarDesktop: optimizeForDesktop,
     otimizarMobile: optimizeMobileOffline,
       debugMobile: debugMobileOffline,
       forceProcessQueue: forceProcessOfflineQueue,
       cleanUUIDs: cleanAllInvalidUUIDs,
       cleanOfflineUUIDs: cleanInvalidUUIDsFromQueue,
     compatibilidadeDev: ensureDevelopmentCompatibility,
     buscarNomes: testarBuscaNomes,
     buscarComuns: testarBuscaComuns,
     processar: forcarProcessamentoFilaOffline,
     forcarFila: forcarProcessamentoFilaOffline,
     pwa: verificarStatusPWA,
     // Fun√ß√µes de edi√ß√£o
     editar: () => window.location.href = './editar.html',
     listarRegistros: listarRegistrosEditaveis,
     buscarRegistros: buscarRegistrosEditaveis,
     verificarMaster: verificarStatusMaster,
     mostrarBotao: mostrarBotaoEdicao,
     limparCacheMaster: limparCacheMasterStatus,
     // Fun√ß√£o de teste
     testarEdicao: async function() {
       console.log('üß™ Testando sistema de edi√ß√£o...');
       const isMaster = await verificarStatusMaster();
       const sessionLocal = localStorage.getItem('session_local');
       console.log('üëë √â master:', isMaster);
       console.log('üìç Local:', sessionLocal);
       
       if (isMaster && sessionLocal) {
         window.location.href = './editar.html';
       } else {
         showToast('warning', 'Teste', `Master: ${isMaster}, Local: ${sessionLocal}`, 2000);
       }
     },
     // Fun√ß√£o para corrigir UUIDs inv√°lidos imediatamente
     corrigirUUIDs: function() {
       console.log('üîß Corrigindo UUIDs inv√°lidos...');
       limparDadosAntigosComUUIDsInvalidos();
     },
     // Fun√ß√£o para limpar tudo e reiniciar sistema
     reiniciarSistema: function() {
       console.log('üîÑ Reiniciando sistema completamente...');
       
       // Limpar todas as filas
       limparFilaOffline();
       
       // Limpar dados antigos
       limparDadosAntigosComUUIDsInvalidos();
       
       // Limpar cache
       localStorage.removeItem('cache_nomes');
       localStorage.removeItem('cache_comuns');
       
       // showToast('success', 'Sistema Reiniciado', 'Todos os dados foram limpos', 3000); // Removido - alerta desnecess√°rio
     },
     // Fun√ß√µes para controlar Supabase
     desabilitarSupabase: function() {
       localStorage.setItem('supabase_disabled', 'true');
       console.log('‚ö†Ô∏è Supabase desabilitado - sistema funcionar√° apenas com Google Sheets');
       // showToast('warning', 'Supabase Desabilitado', 'Sistema funcionar√° apenas com Google Sheets', 3000); // Removido - alerta desnecess√°rio
     },
     habilitarSupabase: function() {
       localStorage.removeItem('supabase_disabled');
       console.log('‚úÖ Supabase habilitado - reinicie a p√°gina para aplicar');
       showToast('info', 'Supabase Habilitado', 'Reinicie a p√°gina para aplicar', 3000);
     },
     statusSupabase: function() {
       const disabled = localStorage.getItem('supabase_disabled') === 'true';
       console.log('üìä Status do Supabase:', {
         desabilitado: disabled,
         carregado: supabaseLoaded,
         cliente: !!sb,
         url: SUPABASE_URL
       });
       return {
         disabled,
         loaded: supabaseLoaded,
         client: !!sb,
         url: SUPABASE_URL
       };
     },
     // Fun√ß√£o para testar gera√ß√£o de UUIDs (VERS√ÉO ROBUSTA)
     testarUUIDs: function() {
       console.log('üß™ TESTE DEFINITIVO de gera√ß√£o de UUIDs...');
       let sucessos = 0;
       let falhas = 0;
       
       for (let i = 0; i < 10; i++) {
         try {
           const uuid = uuidv4();
           const isValid = isValidUUID(uuid);
           
           if (isValid) {
             sucessos++;
             console.log(`‚úÖ UUID ${i + 1}: ${uuid} - V√ÅLIDO`);
           } else {
             falhas++;
             console.error(`‚ùå UUID ${i + 1}: ${uuid} - INV√ÅLIDO`);
           }
         } catch (error) {
           falhas++;
           console.error(`‚ùå Erro na gera√ß√£o ${i + 1}:`, error);
         }
       }
       
       console.log(`üìä RESULTADO: ${sucessos} sucessos, ${falhas} falhas`);
       
       if (falhas === 0) {
         showToast('success', 'Teste UUID', 'Todos os UUIDs s√£o v√°lidos!', 3000);
       } else {
         showToast('error', 'Teste UUID', `${falhas} UUIDs inv√°lidos detectados!`, 5000);
       }
     },
     
     // Fun√ß√£o para validar UUIDs existentes no localStorage
     validarUUIDsExistentes: function() {
       console.log('üîç Validando UUIDs existentes no localStorage...');
       const chaves = ['offline_queue_v3', 'fila_presencas_v2', 'queue'];
       let totalItens = 0;
       let itensInvalidos = 0;
       
       chaves.forEach(chave => {
         try {
           const dados = localStorage.getItem(chave);
           if (dados) {
             const parsed = JSON.parse(dados);
             if (Array.isArray(parsed)) {
               parsed.forEach((item, index) => {
                 totalItens++;
                 if (item.uuid && !isValidUUID(item.uuid)) {
                   itensInvalidos++;
                   console.error(`‚ùå ${chave}[${index}]: UUID inv√°lido - ${item.uuid}`);
                 }
                 if (item.id && !isValidUUID(item.id)) {
                   itensInvalidos++;
                   console.error(`‚ùå ${chave}[${index}]: ID inv√°lido - ${item.id}`);
                 }
               });
             }
           }
         } catch (error) {
           console.error(`‚ùå Erro ao validar ${chave}:`, error);
         }
       });
       
       console.log(`üìä VALIDA√á√ÉO: ${totalItens} itens verificados, ${itensInvalidos} inv√°lidos`);
       
       if (itensInvalidos > 0) {
         showToast('warning', 'UUIDs Inv√°lidos', `${itensInvalidos} UUIDs inv√°lidos encontrados!`, 5000);
       } else {
         showToast('success', 'UUIDs V√°lidos', 'Todos os UUIDs s√£o v√°lidos!', 3000);
       }
     },
     
     // Fun√ß√£o para recuperar o sistema quando estiver offline permanentemente
     recuperarSistema: function() {
       console.log('üîÑ Iniciando recupera√ß√£o manual do sistema...');
       
       try {
         // 1. Verificar ambiente de execu√ß√£o
         console.log('üåê Ambiente atual:', {
           protocol: window.location.protocol,
           hostname: window.location.hostname,
           url: window.location.href
         });
         
         // 2. Verificar conectividade b√°sica
         if (navigator.onLine) {
           console.log('‚úÖ Navegador reporta online');
           
           // Para file://, usar status b√°sico
           if (isFileProtocol) {
             setStatus(true, 'Online (Arquivo Local)');
             // showToast('success', 'Sistema Recuperado', 'Funcionando em modo local!', 3000); // Removido - alerta desnecess√°rio
             return true;
           }
           
           setStatus(true, 'Online (Recupera√ß√£o Manual)');
           
           // 3. Tentar verificar conectividade real (apenas se n√£o for file://)
           setTimeout(async () => {
             try {
               await checkSupabaseConnection();
             } catch (error) {
               console.warn('‚ö†Ô∏è Erro na verifica√ß√£o de conectividade:', error);
               setStatus(true, 'Online (B√°sico)');
             }
           }, 1000);
           
           // showToast('success', 'Sistema Recuperado', 'Conectividade restaurada!', 3000); // Removido - alerta desnecess√°rio
           return true;
         } else {
           console.log('üì¥ Navegador reporta offline');
           setStatus(false, 'Offline');
           // showToast('warning', 'Sistema Offline', 'Verifique sua conex√£o com a internet', 3000); // Removido - alerta desnecess√°rio
           return false;
         }
       } catch (error) {
         console.error('‚ùå Erro na recupera√ß√£o manual:', error);
         showToast('error', 'Erro na Recupera√ß√£o', 'Erro ao recuperar o sistema', 3000);
         return false;
       }
     },
     
     // Fun√ß√£o para verificar ambiente de execu√ß√£o
     verificarAmbiente: function() {
       console.log('üîç Verificando ambiente de execu√ß√£o...');
       
       const ambiente = {
         protocol: window.location.protocol,
         hostname: window.location.hostname,
         url: window.location.href,
         isFileProtocol,
         isLocalhost,
         isHTTPS,
         isHTTP,
         isMobile,
         isIOS,
         isAndroid,
         isStandalone
       };
       
       console.log('üìä Informa√ß√µes do Ambiente:', ambiente);
       
       // Alertas de ambiente removidos - desnecess√°rios para o usu√°rio
       // if (isFileProtocol) {
       //   showToast('info', 'Modo Local', 'Sistema funcionando em arquivo local', 3000);
       // } else if (isLocalhost) {
       //   showToast('info', 'Modo Desenvolvimento', 'Sistema funcionando em localhost', 3000);
       // } else if (isHTTPS) {
       //   showToast('info', 'Modo Produ√ß√£o', 'Sistema funcionando em HTTPS', 3000);
       // } else {
       //   showToast('info', 'Modo HTTP', 'Sistema funcionando em HTTP', 3000);
       // }
       
       return ambiente;
     },
     
     // Fun√ß√£o para diagn√≥stico de conectividade mobile
     diagnosticarConectividadeMobile: function() {
       console.log('üîç Iniciando diagn√≥stico de conectividade mobile...');
       
       const diagnostico = {
         timestamp: new Date().toISOString(),
         ambiente: {
           protocol: window.location.protocol,
           isMobile,
           isIOS,
           isAndroid,
           isStandalone,
           userAgent: navigator.userAgent
         },
         conectividade: {
           navigatorOnline: navigator.onLine,
           isOnline: typeof isOnline !== 'undefined' ? isOnline : 'indefinido',
           lastConnectivityCheck: typeof lastConnectivityCheck !== 'undefined' ? lastConnectivityCheck : 'indefinido',
           forceOfflineMode: typeof forceOfflineMode !== 'undefined' ? forceOfflineMode : 'indefinido'
         },
         sistemas: {
           sistemaPrincipal: typeof window.isOnline !== 'undefined' ? 'ativo' : 'inativo',
           sistemaMobile: typeof window.MobileApp !== 'undefined' ? 'ativo' : 'inativo',
           mobileConnectivity: typeof window.MobileApp !== 'undefined' ? window.MobileApp.getStatus() : 'n√£o dispon√≠vel'
         },
         filas: {
           filaPrincipal: typeof getOfflineQueue === 'function' ? getOfflineQueue().length : 'n√£o dispon√≠vel',
           filaMobile: typeof window.MobileApp !== 'undefined' ? window.MobileApp.offline.getPendingItems().length : 'n√£o dispon√≠vel',
           filaAntiga: JSON.parse(localStorage.getItem('fila_presencas_v2') || '[]').length
         }
       };
       
       console.log('üìä Diagn√≥stico de Conectividade Mobile:', diagnostico);
       
       // Mostrar resultado na UI
       if (typeof showToast !== 'undefined') {
         const status = diagnostico.conectividade.navigatorOnline ? 'Online' : 'Offline';
         const mobileStatus = diagnostico.sistemas.sistemaMobile === 'ativo' ? 'Ativo' : 'Inativo';
         
         showToast('info', 'Diagn√≥stico Mobile', 
           `Status: ${status} | Sistema Mobile: ${mobileStatus}`, 5000);
       }
       
       return diagnostico;
     },
     
     // Fun√ß√£o para migrar dados da fila antiga
     migrarFilaAntiga: function() {
       console.log('üîÑ Iniciando migra√ß√£o da fila antiga...');
       
       try {
         const filaAntiga = JSON.parse(localStorage.getItem('fila_presencas_v2') || '[]');
         
         if (filaAntiga.length === 0) {
           console.log('üì≠ Nenhum item na fila antiga para migrar');
           return { migrados: 0, message: 'Nenhum item para migrar' };
         }
         
         console.log(`üîÑ Migrando ${filaAntiga.length} itens da fila antiga...`);
         
         let migrados = 0;
         for (const item of filaAntiga) {
           try {
             addToOfflineQueue(item);
             migrados++;
           } catch (error) {
             console.error('‚ùå Erro ao migrar item:', error);
           }
         }
         
         // Limpar fila antiga ap√≥s migra√ß√£o
         localStorage.removeItem('fila_presencas_v2');
         
         console.log(`‚úÖ Migra√ß√£o conclu√≠da: ${migrados} itens migrados`);
         
         if (typeof showToast !== 'undefined') {
           showToast('success', 'Migra√ß√£o Conclu√≠da', 
             `${migrados} itens migrados da fila antiga`, 3000);
         }
         
         return { migrados, message: 'Migra√ß√£o conclu√≠da com sucesso' };
         
       } catch (error) {
         console.error('‚ùå Erro na migra√ß√£o:', error);
         return { migrados: 0, message: 'Erro na migra√ß√£o', error: error.message };
       }
     }
   };
   
  // üéØ FUN√á√ÉO PARA FOCO AUTOM√ÅTICO NO CAMPO COMUM CONGREGA√á√ÉO
  function focusComumField() {
    const comumInput = document.getElementById('comumInput');
    if (comumInput) {
      // Verificar se o campo est√° vis√≠vel e n√£o est√° desabilitado
      if (comumInput.offsetParent !== null && !comumInput.disabled) {
        comumInput.focus();
        console.log('‚úÖ Foco autom√°tico aplicado no campo COMUM CONGREGA√á√ÉO');
        
        // Adicionar uma classe visual para indicar que est√° focado
        comumInput.classList.add('auto-focused');
        
        // Remover a classe ap√≥s um tempo para n√£o interferir com o estilo
        setTimeout(() => {
          comumInput.classList.remove('auto-focused');
        }, 2000);
        
        return true;
      } else {
        console.log('‚ö†Ô∏è Campo COMUM CONGREGA√á√ÉO n√£o est√° dispon√≠vel para foco');
        return false;
      }
    } else {
      console.log('‚ùå Campo COMUM CONGREGA√á√ÉO n√£o encontrado');
      return false;
    }
  }
  
  // Expor fun√ß√£o globalmente para uso em outras partes do c√≥digo
  window.focusComumField = focusComumField;

  // === INICIALIZA√á√ÉO DO NOVO SISTEMA ===
  // Inicializar sistema quando o DOM estiver pronto
  document.addEventListener('DOMContentLoaded', function() {
    console.log("üöÄ Inicializando sistema de forma est√°vel...");
    
    // üõ°Ô∏è PRIMEIRO: Garantir compatibilidade de desenvolvimento
    ensureDevelopmentCompatibility();
    
    // üßπ LIMPEZA: Limpar registros antigos do cache de envios
    cleanOldSentRecords();
    
    // üéØ FOCO AUTOM√ÅTICO: Focar no campo COMUM CONGREGA√á√ÉO para melhorar produtividade
    setTimeout(() => {
      focusComumField();
    }, 500); // Delay para garantir que o campo esteja totalmente carregado
     
     // Verifica√ß√£o inicial imediata do status
     if (navigator.onLine) {
       setStatus(true, 'Online (Inicial)');
       isOnline = true;
       console.log("‚úÖ Status inicial: Online");
     } else {
       setStatus(false, 'Offline');
       isOnline = false;
       console.log("üì¥ Status inicial: Offline");
     }
     
     try {
       // 1. Inicializar contagem da fila (sem quebrar)
       setTimeout(() => {
         try {
           updateQueueCount();
         } catch (error) {
           console.warn('‚ö†Ô∏è Erro na inicializa√ß√£o da contagem da fila:', error);
         }
       }, 500);
       
       // 2. Iniciar monitoramento de conectividade (sem quebrar)
       setTimeout(() => {
         try {
           startConnectivityMonitoring();
         } catch (error) {
           console.warn('‚ö†Ô∏è Erro no monitoramento de conectividade:', error);
         }
       }, 1000);
       
       // 2.5. Iniciar sincroniza√ß√£o da fila offline (sem quebrar)
       setTimeout(() => {
         try {
           startOfflineQueueSync();
           console.log('üîÑ Sincroniza√ß√£o da fila offline iniciada');
         } catch (error) {
           console.warn('‚ö†Ô∏è Erro na sincroniza√ß√£o da fila offline:', error);
         }
       }, 1500);
       
       // 2.6. Otimizar experi√™ncia mobile (sem quebrar)
       setTimeout(() => {
         try {
           if (isMobile) {
             optimizeMobileExperience();
             optimizeMobileSync();
             console.log('üì± Otimiza√ß√µes mobile aplicadas');
           } else {
             optimizeDesktopExperience();
             console.log('üñ•Ô∏è Otimiza√ß√µes desktop aplicadas');
           }
         } catch (error) {
           console.warn('‚ö†Ô∏è Erro nas otimiza√ß√µes de plataforma:', error);
         }
       }, 2000);
       
       // 3. Auto-sync por timer (sem quebrar)
       setTimeout(() => {
         try {
           setInterval(() => {
             try {
               if (isOnline) {
                 syncPending();
               }
             } catch (error) {
               console.warn('‚ö†Ô∏è Erro no sync autom√°tico:', error);
             }
           }, SYNC_INTERVAL_MS);
         } catch (error) {
           console.warn('‚ö†Ô∏è Erro na configura√ß√£o do timer de sync:', error);
         }
       }, 1500);
       
       // 4. Verificar conectividade inicial (sem quebrar)
       setTimeout(async () => {
         try {
           // Primeiro, atualizar o status baseado no navegador
           if (navigator.onLine) {
             setStatus(true, 'Online (Inicializa√ß√£o)');
             isOnline = true;
           } else {
             setStatus(false, 'Offline');
             isOnline = false;
           }
           
           // Depois, tentar verifica√ß√£o mais robusta
           await checkSupabaseConnection();
         } catch (error) {
           console.warn('‚ö†Ô∏è Erro na verifica√ß√£o inicial de conectividade:', error);
           // Se falhar, pelo menos mostrar que o navegador est√° online
           if (navigator.onLine) {
             setStatus(true, 'Online (Inicializa√ß√£o)');
             isOnline = true;
           }
         }
       }, 2000);
       
       // 5. Carregar configura√ß√µes de backup e iniciar sistema (sem quebrar)
       setTimeout(() => {
         try {
           // Carregar configura√ß√µes salvas
           const savedSettings = localStorage.getItem('backup_settings');
           if (savedSettings) {
             const settings = JSON.parse(savedSettings);
             Object.assign(BACKUP_CONFIG, settings);
             console.log('üíæ Configura√ß√µes de backup carregadas:', settings);
           }
           
           startAutoBackup();
           console.log('üíæ Sistema de backup autom√°tico iniciado');
         } catch (error) {
           console.warn('‚ö†Ô∏è Erro na inicializa√ß√£o do backup autom√°tico:', error);
         }
       }, 2500);
       
       console.log("‚úÖ Sistema inicializado com sucesso!");
       
     } catch (error) {
       console.error('‚ùå Erro na inicializa√ß√£o do sistema:', error);
       // Mesmo com erro, tentar manter o sistema funcional
       if (navigator.onLine) {
         setStatus(true, 'Online (Recupera√ß√£o)');
       }
     }
   });
   
   // Fun√ß√£o de recupera√ß√£o autom√°tica do sistema
   function recoverSystem() {
     console.log('üîÑ Iniciando recupera√ß√£o autom√°tica do sistema...');
     
     try {
       // Verificar se o navegador est√° online
       if (navigator.onLine) {
         setStatus(true, 'Online (Recupera√ß√£o)');
         console.log('‚úÖ Sistema recuperado - navegador online');
         return true;
       } else {
         setStatus(false, 'Offline');
         console.log('üì¥ Sistema offline - navegador offline');
         return false;
       }
     } catch (error) {
       console.error('‚ùå Erro na recupera√ß√£o do sistema:', error);
       return false;
     }
   }
   
   // Event listeners para conectividade do navegador
   window.addEventListener("online", async () => {
     console.log("üåê Navegador detectou conectividade - usando processamento centralizado");
     isOnline = true;
     updateStatusUI();
     await processQueueOnConnectionRestore();
   });
   
   window.addEventListener("offline", () => {
     console.log("üì¥ Navegador detectou perda de conectividade");
     isOnline = false;
     updateStatusUI();
   });
   
   // üß™ FUN√á√ÉO DE TESTE: Validar compara√ß√£o de comum em diferentes plataformas
   // Pode ser executada no console do navegador para testar a fun√ß√£o compareComum
   window.testarComparacaoComum = function(testCases = null) {
     console.log('üß™ TESTE: Valida√ß√£o de compara√ß√£o de comum (cross-platform)');
     console.log('üß™ Plataforma:', {
       userAgent: navigator.userAgent,
       isAndroid: /Android/.test(navigator.userAgent),
       isIOS: /iPhone|iPad|iPod/.test(navigator.userAgent),
       isMobile: /Android|iPhone|iPad|iPod/.test(navigator.userAgent)
     });
     
     // Casos de teste padr√£o
     const defaultTestCases = [
       // Casos b√°sicos
       { comumRegistro: 'Jardim Hon√≥ria', comumBuscado: 'Jardim Honoria', esperado: true, descricao: 'Comum com acento vs sem acento' },
       { comumRegistro: 'Jardim Honoria', comumBuscado: 'Jardim Hon√≥ria', esperado: true, descricao: 'Comum sem acento vs com acento' },
       { comumRegistro: 'Jardim Hon√≥ria', comumBuscado: 'Jardim Hon√≥ria', esperado: true, descricao: 'Comum id√™ntico' },
       { comumRegistro: 'Jardim Hon√≥ria', comumBuscado: 'Jardim', esperado: true, descricao: 'Comum parcial (buscado menor)' },
       { comumRegistro: 'Jardim', comumBuscado: 'Jardim Hon√≥ria', esperado: true, descricao: 'Comum parcial (registro menor)' },
       
       // Casos com espa√ßos
       { comumRegistro: 'Jardim  Hon√≥ria', comumBuscado: 'Jardim Honoria', esperado: true, descricao: 'Comum com espa√ßos m√∫ltiplos' },
       { comumRegistro: ' Jardim Hon√≥ria ', comumBuscado: 'Jardim Honoria', esperado: true, descricao: 'Comum com espa√ßos extras' },
       
       // Casos que n√£o devem fazer match
       { comumRegistro: 'Jardim Hon√≥ria', comumBuscado: 'S√£o Paulo', esperado: false, descricao: 'Comuns diferentes' },
       { comumRegistro: 'Jardim', comumBuscado: 'S√£o Paulo', esperado: false, descricao: 'Completamente diferentes' },
       
       // Casos especiais
       { comumRegistro: '', comumBuscado: 'Jardim Honoria', esperado: false, descricao: 'Registro vazio' },
       { comumRegistro: 'Jardim Hon√≥ria', comumBuscado: '', esperado: false, descricao: 'Buscado vazio' },
       { comumRegistro: null, comumBuscado: 'Jardim Honoria', esperado: false, descricao: 'Registro null' },
       { comumRegistro: 'Jardim Hon√≥ria', comumBuscado: null, esperado: false, descricao: 'Buscado null' }
     ];
     
     const tests = testCases || defaultTestCases;
     const results = [];
     let passed = 0;
     let failed = 0;
     
     console.log('üß™ Executando', tests.length, 'casos de teste...');
     
     tests.forEach((testCase, index) => {
       const result = compareComum(testCase.comumRegistro, testCase.comumBuscado, { debug: true });
       const testPassed = result.match === testCase.esperado;
       
       if (testPassed) {
         passed++;
       } else {
         failed++;
         console.error(`‚ùå TESTE ${index + 1} FALHOU:`, {
           descricao: testCase.descricao,
           comumRegistro: testCase.comumRegistro,
           comumBuscado: testCase.comumBuscado,
           esperado: testCase.esperado,
           obtido: result.match,
           detalhes: result.matchDetails
         });
       }
       
       results.push({
         ...testCase,
         resultado: result.match,
         passou: testPassed,
         detalhes: result.matchDetails
       });
     });
     
     console.log('üß™ RESULTADOS DO TESTE:');
     console.log(`‚úÖ Passou: ${passed}/${tests.length}`);
     console.log(`‚ùå Falhou: ${failed}/${tests.length}`);
     console.log(`üìä Taxa de sucesso: ${((passed / tests.length) * 100).toFixed(2)}%`);
     
     if (failed === 0) {
       console.log('‚úÖ TODOS OS TESTES PASSARAM!');
     } else {
       console.warn('‚ö†Ô∏è ALGUNS TESTES FALHARAM - Verifique os logs acima');
     }
     
     return {
       total: tests.length,
       passed,
       failed,
       taxaSucesso: (passed / tests.length) * 100,
       resultados: results
     };
   };
   
   // üìä FUN√á√ÉO DE MONITORAMENTO: Coletar estat√≠sticas de compara√ß√£o de comum
   // Armazena estat√≠sticas para an√°lise de padr√µes de problemas
   window.monitorarComparacaoComum = (function() {
     const stats = {
       total: 0,
       matches: 0,
       nonMatches: 0,
       erros: 0,
       casosProblema: [],
       ultimaAtualizacao: null
     };
     
     return {
       // Registrar uma compara√ß√£o
       registrar: function(comumRegistro, comumBuscado, match, error = null) {
         stats.total++;
         if (error) {
           stats.erros++;
         } else if (match) {
           stats.matches++;
         } else {
           stats.nonMatches++;
           // Armazenar casos que n√£o fizeram match para an√°lise
           if (stats.casosProblema.length < 50) { // Limitar a 50 casos
             stats.casosProblema.push({
               comumRegistro,
               comumBuscado,
               timestamp: new Date().toISOString(),
               userAgent: navigator.userAgent
             });
           }
         }
         stats.ultimaAtualizacao = new Date().toISOString();
       },
       
       // Obter estat√≠sticas
       getStats: function() {
         return {
           ...stats,
           taxaMatch: stats.total > 0 ? (stats.matches / stats.total * 100).toFixed(2) + '%' : '0%',
           taxaErro: stats.total > 0 ? (stats.erros / stats.total * 100).toFixed(2) + '%' : '0%'
         };
       },
       
       // Limpar estat√≠sticas
       limpar: function() {
         stats.total = 0;
         stats.matches = 0;
         stats.nonMatches = 0;
         stats.erros = 0;
         stats.casosProblema = [];
         stats.ultimaAtualizacao = null;
         console.log('üìä Estat√≠sticas de compara√ß√£o de comum limpas');
       },
       
       // Exportar estat√≠sticas para an√°lise
       exportar: function() {
         const statsData = this.getStats();
         const json = JSON.stringify(statsData, null, 2);
         console.log('üìä Estat√≠sticas de compara√ß√£o de comum:');
         console.log(json);
         return statsData;
       }
     };
   })();
   
   // Expor fun√ß√£o compareComum globalmente para testes
   window.compareComum = compareComum;
   
   // Fun√ß√£o de debug para testar detec√ß√£o de cargos
   async function debugCargoDetection(nome, comum) {
     console.log('üîç DEBUG - Testando detec√ß√£o de cargo para:', { nome, comum });
     
     if (!supabaseLoaded || !sb) {
       console.log('‚ö†Ô∏è Supabase n√£o dispon√≠vel para debug');
       return;
     }
     
     try {
       // Busca todos os registros da pessoa
       const { data, error } = await sb
         .from(TABLE_CATALOGO)
         .select('nome, cargo, nivel, instrumento, comum')
         .ilike('nome', `%${nome}%`)
         .ilike(COL_COMUM, `%${comum}%`)
         .eq('ativo', true)
         .order('cargo', { ascending: true });
       
       if (error) {
         console.error('‚ùå Erro na busca de debug:', error);
         return;
       }
       
       console.log('üîç DEBUG - Registros encontrados:', data);
       
       if (data && data.length > 0) {
         data.forEach((r, index) => {
           console.log(`  ${index + 1}. Nome: "${r.nome}", Cargo: "${r.cargo}", Instrumento: "${r.instrumento}", Comum: "${r.comum}"`);
         });
         
         // Testa detec√ß√£o de cargo especial
         const cargoEspecial = data.find(r => {
           const cargoUpper = r.cargo.toUpperCase();
           // üõ°Ô∏è CORRE√á√ÉO: Diferencia√ß√£o de g√™nero para cargos
           const isExaminadora = cargoUpper.includes('EXAMINADORA');
           const isInstrutora = cargoUpper.includes('INSTRUTORA');
           const isSecretariaMusica = cargoUpper.includes('SECRET√ÅRIA') && cargoUpper.includes('M√öSICA');
           // üö® SECRET√ÅRIO DA M√öSICA (masculino) N√ÉO deve ser detectado como cargo especial
           
           return isExaminadora || isInstrutora || isSecretariaMusica;
         });
         
         if (cargoEspecial) {
           console.log('‚úÖ Cargo especial detectado:', cargoEspecial.cargo);
         } else {
           console.log('‚ùå Nenhum cargo especial detectado');
         }
       } else {
         console.log('‚ùå Nenhum registro encontrado');
       }
     } catch (error) {
       console.error('‚ùå Erro no debug:', error);
     }
   }
   
   // Expor fun√ß√£o de debug globalmente para testes
   window.debugCargoDetection = debugCargoDetection;
   
   // Fun√ß√£o de debug para testar pesquisa de comum
   function debugComumSearch(searchTerm) {
     console.log('üîç DEBUG - Testando pesquisa de comum para:', searchTerm);
     console.log('üîç comumData dispon√≠vel:', comumData.length, 'itens');
     console.log('üîç comumData:', comumData);
     
     if (comumData.length === 0) {
       console.log('‚ùå Nenhum dado de comum carregado!');
       
       // Tenta carregar dados do input
       const comumInput = document.getElementById('comumInput');
       if (comumInput && comumInput.dataset.comumList) {
         console.log('üîç Dataset encontrado:', comumInput.dataset.comumList);
         try {
           const dados = JSON.parse(comumInput.dataset.comumList);
           console.log('üîç Dados parseados:', dados);
           comumData = dados;
           updateComumData();
         } catch (e) {
           console.error('‚ùå Erro ao parsear dataset:', e);
         }
       } else {
         console.log('‚ùå Dataset comumList n√£o encontrado no input');
       }
     }
     
     // Testa a pesquisa
     const resultados = searchComuns(searchTerm);
     console.log('üîç Resultados da pesquisa:', resultados);
     
     // Testa a exibi√ß√£o
     showComumResults(resultados, searchTerm);
     console.log('üîç Dropdown deve estar vis√≠vel agora');
   }
   
   // Expor fun√ß√£o de debug globalmente
   window.debugComumSearch = debugComumSearch;
   
   // üîç FUN√á√ÉO DE DEBUG: Testar problema das instrutoras no iOS
   window.testarInstrutorasIOS = async function() {
     console.log('üçé TESTANDO PROBLEMA DAS INSTRUTORAS NO iOS');
     
     if (!isIOS) {
       console.log('‚ùå Esta fun√ß√£o √© espec√≠fica para iOS. Dispositivo atual n√£o √© iOS.');
       return;
     }
     
     console.log('üçé iOS detectado - testando carregamento de instrutoras...');
     
     // Simula sele√ß√£o de comum + organista
     const comumVal = 'Jardim Miranda'; // Exemplo
     const cargoVal = 'ORGANISTA';
     const cargoUP = 'ORGANISTA';
     const instVal = '√ìRG√ÉO';
     const precisaInst = true;
     
     console.log('üçé Par√¢metros do teste:', { comumVal, cargoVal, cargoUP, instVal, precisaInst });
     
     // For√ßa carregamento
     const nomeEl = document.getElementById('nome');
     if (!nomeEl) {
       console.error('‚ùå Campo de nome n√£o encontrado');
       return;
     }
     
     // Chama a fun√ß√£o loadNomes diretamente
     await loadNomes(comumVal, instVal, cargoVal, cargoUP, precisaInst);
     
     return {
       isIOS: true,
       comumVal,
       cargoVal,
       cargoUP,
       instVal,
       precisaInst,
       nomesCarregados: window.nomesData?.length || 0,
       nomes: window.nomesData || []
     };
   };

   // üîç FUN√á√ÉO DE DEBUG: Testar mudan√ßa de instrumento
   window.testarMudancaInstrumento = function() {
     console.log('üé∫ TESTANDO MUDAN√áA DE INSTRUMENTO');
     
     const instEl = findInstrumentField();
     const comumEl = findComumField();
     const cargoEl = findCargoField();
     
     if (!instEl || !comumEl || !cargoEl) {
       console.error('‚ùå Campos n√£o encontrados');
       return;
     }
     
     const comum = comumEl.value;
     const cargo = cargoEl.value;
     const instrumentoAtual = instEl.value;
     
     console.log('üîç Estado atual:', { comum, cargo, instrumentoAtual });
     
     // Simular mudan√ßa para TROMPETE
     console.log('üîÑ Simulando mudan√ßa para TROMPETE...');
     instEl.value = 'TROMPETE';
     
     // Disparar evento de mudan√ßa
     const event = new Event('change', { bubbles: true });
     instEl.dispatchEvent(event);
     
     console.log('‚úÖ Evento de mudan√ßa disparado');
     
     return {
       comum,
       cargo,
       instrumentoAnterior: instrumentoAtual,
       instrumentoNovo: 'TROMPETE',
       status: 'Teste executado - verifique o console para logs'
     };
   };

   // üîç FUN√á√ÉO DE DEBUG: Testar regras de g√™nero
   window.testarRegrasGenero = function() {
     console.log('üöÄ TESTANDO REGRAS DE G√äNERO');
     
     const testes = [
       {
         nome: 'Teste 1 - OFICIALIZADO(A) simples',
         dados: { classe: 'OFICIALIZADO(A)' },
         esperado: 'OFICIALIZADA'
       },
       {
         nome: 'Teste 2 - RJM / OFICIALIZADO(A) com prefixo',
         dados: { classe: 'RJM / OFICIALIZADO(A)' },
         esperado: 'RJM / OFICIALIZADA'
       },
       {
         nome: 'Teste 3 - OFICIALIZADA j√° correto',
         dados: { classe: 'OFICIALIZADA' },
         esperado: 'OFICIALIZADA'
       },
       {
         nome: 'Teste 4 - RJM / OFICIALIZADA j√° correto',
         dados: { classe: 'RJM / OFICIALIZADA' },
         esperado: 'RJM / OFICIALIZADA'
       },
       {
         nome: 'Teste 5 - M√∫ltiplos campos',
         dados: { 
           classe: 'OFICIALIZADO(A)', 
           nivel: 'RJM / OFICIALIZADO(A)',
           classe_organista: 'OFICIALIZADO(A)'
         },
         esperado: {
           classe: 'OFICIALIZADA',
           nivel: 'RJM / OFICIALIZADA',
           classe_organista: 'OFICIALIZADA'
         }
       }
     ];
     
     console.log('üîç Executando testes de regras de g√™nero...');
     
     testes.forEach((teste, index) => {
       console.log(`\nüìã ${teste.nome}:`);
       console.log('  Dados originais:', teste.dados);
       
       const resultado = aplicarRegrasGenero(teste.dados);
       console.log('  Dados processados:', resultado);
       
       if (typeof teste.esperado === 'object') {
         const sucesso = Object.keys(teste.esperado).every(campo => 
           resultado[campo] === teste.esperado[campo]
         );
         console.log('  Resultado:', sucesso ? '‚úÖ SUCESSO' : '‚ùå FALHA');
       } else {
         const sucesso = resultado.classe === teste.esperado;
         console.log('  Resultado:', sucesso ? '‚úÖ SUCESSO' : '‚ùå FALHA');
       }
     });
     
     return {
       testes: testes,
       funcao: 'aplicarRegrasGenero',
       status: 'Teste conclu√≠do - verifique o console para detalhes'
     };
   };

   // üîç FUN√á√ÉO DE DEBUG: Testar busca de nomes com 3 caracteres
   window.testarBuscaNomes = function() {
     console.log('üîç TESTANDO BUSCA DE NOMES COM 3 CARACTERES');
     
     const nomeInput = document.getElementById('nome');
     if (!nomeInput) {
       console.error('‚ùå Campo de nome n√£o encontrado');
       return;
     }
     
     // Testa com diferentes quantidades de caracteres
     const testes = [
       { texto: 'Jo', esperado: 'N√£o deve mostrar dropdown' },
       { texto: 'Jos', esperado: 'Deve mostrar dropdown' },
       { texto: 'Jose', esperado: 'Deve mostrar dropdown' },
       { texto: 'Jos√©', esperado: 'Deve mostrar dropdown' }
     ];
     
     console.log('üîç Testando comportamento do campo de nome:');
     testes.forEach((teste, index) => {
       console.log(`Teste ${index + 1}: "${teste.texto}" - ${teste.esperado}`);
     });
     
     return {
       campoEncontrado: !!nomeInput,
       testes: testes,
       instrucoes: 'Digite no campo de nome para testar a funcionalidade'
     };
   };

   // üîç FUN√á√ÉO DE DEBUG: Testar normaliza√ß√£o de "Jardim Hon√≥ria"
   window.testarJardimHonoria = function() {
     console.log('üîç TESTANDO NORMALIZA√á√ÉO DE "JARDIM HON√ìRIA"');
     
     const original = 'Jardim Hon√≥ria';
     const normalized = ucase(original);
     const noacc = original.normalize('NFD').replace(/\p{Diacritic}/gu,'');
     
     console.log('üîç Original:', original);
     console.log('üîç Sem acentos:', noacc);
     console.log('üîç Normalizado (ucase):', normalized);
     
     // Testar se est√° na lista de comuns
     console.log('üîç Verificando se est√° em comumData...');
     const found = comumData.find(comum => ucase(comum) === normalized);
     console.log('üîç Encontrado na lista:', found);
     
     // Testar busca
     console.log('üîç Testando busca...');
     const searchResults = searchComuns('jardim hon√≥ria');
     console.log('üîç Resultados da busca:', searchResults);
     
     // Verificar todas as comuns que cont√™m "jardim"
     const jardins = comumData.filter(comum => ucase(comum).includes('JARDIM'));
     console.log('üîç Todas as comuns com "JARDIM":', jardins);
     
     return {
       original,
       normalized,
       found,
       searchResults,
       jardins
     };
   };

   // üîç FUN√á√ÉO DE DEBUG: Testar busca de comuns espec√≠ficas
   window.testarBuscaComuns = async function() {
     console.log('üîç TESTANDO BUSCA DE COMUNS');
     
     // For√ßa recarregamento das comuns
     console.log('üîÑ For√ßando recarregamento das comuns...');
     await loadComunsFromCatalog();
     
     // Testa busca por "Jardim Hon√≥ria"
     console.log('üîç Testando busca por "Jardim Hon√≥ria"...');
     const resultadosJardimHonoria = searchComuns('Jardim Hon√≥ria');
     console.log('üîç Resultados para "Jardim Hon√≥ria":', resultadosJardimHonoria);
     
     // üöÄ NOVO: Teste completo de contagem
     console.log('üîç TESTE COMPLETO DE CONTAGEM:');
     console.log('üîç Total de comuns carregadas:', comumData.length);
     console.log('üîç Esperado: 184 comuns');
     
     if (comumData.length < 184) {
       console.log('‚ö†Ô∏è PROBLEMA: Apenas', comumData.length, 'comuns carregadas de 184 esperadas');
       console.log('üîç Verificando se h√° registros sem campo ativo...');
       
       // Teste direto no Supabase
       const { data: testData, error: testError } = await sb
         .from(TABLE_CATALOGO)
         .select(COL_COMUM);
       
       if (testData) {
         const todasComuns = Array.from(new Set(testData.map(r => r[COL_COMUM]).filter(Boolean)));
         console.log('üîç Total de comuns √∫nicas no banco (sem filtro ativo):', todasComuns.length);
         
         if (todasComuns.length > comumData.length) {
           console.log('üîç Comuns que est√£o no banco mas n√£o foram carregadas:');
           const comunsPerdidas = todasComuns.filter(comum => !comumData.includes(comum));
           console.log('üîç Comuns perdidas:', comunsPerdidas.slice(0, 20));
         }
       }
     } else {
       console.log('‚úÖ SUCESSO: Todas as 184 comuns foram carregadas!');
     }
     
     // Testa busca por "jardim"
     console.log('üîç Testando busca por "jardim"...');
     const resultadosJardim = searchComuns('jardim');
     console.log('üîç Resultados para "jardim":', resultadosJardim);
     
     // Testa busca por "hon√≥ria"
     console.log('üîç Testando busca por "hon√≥ria"...');
     const resultadosHonoria = searchComuns('hon√≥ria');
     console.log('üîç Resultados para "hon√≥ria":', resultadosHonoria);
     
     // Verifica se est√° no comumData
     console.log('üîç Verificando comumData...');
     const jardimHonoriaNoData = comumData.find(comum => 
       comum.toLowerCase().includes('jardim') && comum.toLowerCase().includes('hon√≥ria')
     );
     console.log('üîç Jardim Hon√≥ria em comumData:', jardimHonoriaNoData);
     
     // Lista todas as comuns que cont√™m "jardim"
     const jardinsNoData = comumData.filter(comum => comum.toLowerCase().includes('jardim'));
     console.log('üîç Todas as comuns com "jardim" em comumData:', jardinsNoData);
     
     // Lista TODAS as comuns para verificar se s√£o 184
     console.log('üîç TOTAL DE COMUNS CARREGADAS:', comumData.length);
     console.log('üîç TODAS AS COMUNS:', comumData);
     
     return {
       jardimHonoria: resultadosJardimHonoria,
       jardim: resultadosJardim,
       honoria: resultadosHonoria,
       jardimHonoriaNoData,
       jardinsNoData,
       totalComuns: comumData.length,
       todasComuns: comumData
     };
   };

   // Fun√ß√£o de debug para testar detec√ß√£o de cargos
   async function debugCargoDetectionTest(nome, comum, cargo) {
     console.log('üîç DEBUG - Testando detec√ß√£o de cargo para:', { nome, comum, cargo });
     
     const cargoEl = findCargoField();
     if (!cargoEl) {
       console.error('‚ùå Campo de cargo n√£o encontrado!');
       return;
     }
     
     // Simula a detec√ß√£o autom√°tica
     if (ucase(cargo) === 'ORGANISTA') {
       console.log('üîç Testando detec√ß√£o de organista...');
       await detectarCargoOrganistaAutomaticamente(nome, comum, cargo, cargoEl);
     } else if (ucase(cargo) === 'M√öSICO' || ucase(cargo) === 'M√öSICO(A)') {
       console.log('üîç Testando detec√ß√£o de cargo musical...');
       await detectarCargoMusicalAutomaticamente(nome, comum, cargo, cargoEl, '');
     }
     
     // Verifica se o cargo real foi detectado
     const cargoReal = cargoEl.getAttribute('data-cargo-real');
     console.log('üîç Cargo real detectado:', cargoReal);
     
     return cargoReal;
   }
   
   // Expor fun√ß√£o de debug globalmente
   window.debugCargoDetectionTest = debugCargoDetectionTest;
   
   // Fun√ß√£o de debug simplificada para testar detec√ß√£o de cargos
   function testCargoDetection() {
     console.log('üîç TESTE DE DETEC√á√ÉO DE CARGOS');
     console.log('üîç Testando Ricardo (Secret√°rio da M√∫sica)...');
     
     // Simula o processo de detec√ß√£o
     const cargoEl = findCargoField();
     if (cargoEl) {
       console.log('‚úÖ Campo de cargo encontrado');
       
       // Simula detec√ß√£o de Secret√°rio da M√∫sica
       cargoEl.setAttribute('data-cargo-real', 'Secret√°rio (A) da M√∫sica');
       console.log('‚úÖ Cargo real definido:', cargoEl.getAttribute('data-cargo-real'));
     } else {
       console.error('‚ùå Campo de cargo n√£o encontrado');
     }
     
     console.log('üîç Testando Maristela (Examinadora)...');
     
     // Simula detec√ß√£o de Examinadora
     if (cargoEl) {
       cargoEl.setAttribute('data-cargo-real', 'Examinadora');
       console.log('‚úÖ Cargo real definido:', cargoEl.getAttribute('data-cargo-real'));
     }
   }
   
   // Expor fun√ß√£o de teste globalmente
   window.testCargoDetection = testCargoDetection;
   
   // Fun√ß√£o de debug para verificar status atual
   function debugStatus() {
     console.log('üîç STATUS ATUAL DO SISTEMA');
     console.log('üîç Supabase carregado:', supabaseLoaded);
     console.log('üîç Supabase dispon√≠vel:', !!sb);
     console.log('üîç Online:', navigator.onLine);
     console.log('üîç isOnline:', isOnline);
     
     // Verifica campos do formul√°rio
     const comumEl = findComumField();
     const cargoEl = findCargoField();
     const nomeEl = findNomeField();
     const instEl = findInstrumentField();
     
     console.log('üîç Campos encontrados:', {
       comum: !!comumEl,
       cargo: !!cargoEl,
       nome: !!nomeEl,
       instrumento: !!instEl
     });
     
     // Verifica dados de comum
     console.log('üîç Dados de comum carregados:', comumData.length);
     
     // Verifica cargo real se definido
     if (cargoEl && cargoEl.hasAttribute('data-cargo-real')) {
       console.log('üîç Cargo real definido:', cargoEl.getAttribute('data-cargo-real'));
     } else {
       console.log('üîç Nenhum cargo real definido');
     }
   }
   
   
  // Expor fun√ß√£o de debug globalmente com verifica√ß√£o de seguran√ßa
  // üö® CORRE√á√ÉO: Removida refer√™ncia a debugCargo que n√£o existe
  // window.debugCargo = debugCargo; // Removido - fun√ß√£o n√£o existe
   
   // Fun√ß√£o para testar detec√ß√£o de cargo espec√≠fica
   async function testCargoForPerson(nome, comum, cargo) {
     console.log('üîç TESTE DE DETEC√á√ÉO PARA PESSOA ESPEC√çFICA');
     console.log('üîç Dados:', { nome, comum, cargo });
     
     if (!supabaseLoaded || !sb) {
       console.error('‚ùå Supabase n√£o dispon√≠vel');
       return;
     }
     
     try {
       // Busca todos os registros da pessoa
       const { data, error } = await sb
         .from(TABLE_CATALOGO)
         .select('nome, cargo, nivel, instrumento, comum')
         .ilike('comum', `%${comum}%`)
         .ilike('nome', `%${nome}%`)
         .eq('ativo', true)
         .order('cargo', { ascending: true });
       
       if (error) {
         console.error('‚ùå Erro na consulta:', error);
         return;
       }
       
       console.log('üîç Registros encontrados:', data);
       
       if (data && data.length > 0) {
         data.forEach((r, index) => {
           console.log(`  ${index + 1}. Nome: "${r.nome}", Cargo: "${r.cargo}", Instrumento: "${r.instrumento}", Comum: "${r.comum}"`);
         });
         
         // Busca por cargos especiais
         const cargoEspecial = data.find(r => {
           const cargoUpper = r.cargo.toUpperCase();
           // üõ°Ô∏è CORRE√á√ÉO: Diferencia√ß√£o de g√™nero para cargos
           const isSecretariaMusica = cargoUpper.includes('SECRET√ÅRIA') && cargoUpper.includes('M√öSICA');
           const isEncarregado = cargoUpper.includes('ENCARREGADO');
           const isInstrutor = cargoUpper.includes('INSTRUTOR') && !cargoUpper.includes('INSTRUTORA');
           const isInstrutora = cargoUpper.includes('INSTRUTORA');
           const isExaminadora = cargoUpper.includes('EXAMINADORA');
           // üö® SECRET√ÅRIO DA M√öSICA (masculino) N√ÉO deve ser detectado como cargo especial
           
           return isSecretariaMusica || isEncarregado || isInstrutor || isInstrutora || isExaminadora;
         });
         
         if (cargoEspecial) {
           console.log('‚úÖ Cargo especial encontrado:', cargoEspecial.cargo);
           return cargoEspecial.cargo;
         } else {
           console.log('‚ùå Nenhum cargo especial encontrado');
           return null;
         }
       } else {
         console.log('‚ùå Nenhum registro encontrado');
         return null;
       }
     } catch (error) {
       console.error('‚ùå Erro no teste:', error);
       return null;
     }
   }
   
   // Expor fun√ß√£o de teste globalmente
   window.testCargoDetectionWithFormData = testCargoDetectionWithFormData;
   
   // Fun√ß√£o gen√©rica para testar detec√ß√£o de cargo de qualquer pessoa
   async function testarDetecaoCargo(nome, comum, cargo) {
     console.log('üîç TESTE GEN√âRICO DE DETEC√á√ÉO DE CARGO');
     console.log('üîç Dados do teste:', { nome, comum, cargo });
     
     if (!supabaseLoaded || !sb) {
       console.error('‚ùå Supabase n√£o dispon√≠vel');
       return;
     }
     
     try {
       // Busca todos os registros da pessoa
       console.log('üîç Buscando todos os registros da pessoa...');
       const { data, error } = await sb
         .from(TABLE_CATALOGO)
         .select('nome, cargo, nivel, instrumento, comum')
         .ilike('nome', `%${nome}%`)
         .eq('ativo', true)
         .order('cargo', { ascending: true });
       
       if (error) {
         console.error('‚ùå Erro na consulta:', error);
         return;
       }
       
       console.log('üîç Registros encontrados:', data);
       
       if (data && data.length > 0) {
         data.forEach((r, index) => {
           console.log(`  ${index + 1}. Nome: "${r.nome}", Cargo: "${r.cargo}", Instrumento: "${r.instrumento}", Comum: "${r.comum}"`);
         });
         
         // Busca por cargos especiais
         const cargoEspecial = data.find(r => {
           const cargoUpper = r.cargo.toUpperCase();
           // üõ°Ô∏è CORRE√á√ÉO: Diferencia√ß√£o de g√™nero para cargos
           const isSecretariaMusica = cargoUpper.includes('SECRET√ÅRIA') && cargoUpper.includes('M√öSICA');
           const isEncarregado = cargoUpper.includes('ENCARREGADO');
           const isEncarregada = cargoUpper.includes('ENCARREGADA');
           const isInstrutor = cargoUpper.includes('INSTRUTOR') && !cargoUpper.includes('INSTRUTORA');
           const isInstrutora = cargoUpper.includes('INSTRUTORA');
           const isExaminadora = cargoUpper.includes('EXAMINADORA');
           // üö® SECRET√ÅRIO DA M√öSICA (masculino) N√ÉO deve ser detectado como cargo especial
           
           return isSecretariaMusica || isEncarregado || isEncarregada || isInstrutor || isInstrutora || isExaminadora;
         });
         
         if (cargoEspecial) {
           console.log('‚úÖ Cargo especial encontrado:', cargoEspecial.cargo);
           return cargoEspecial.cargo;
         } else {
           console.log('‚ùå Nenhum cargo especial encontrado');
           return null;
         }
       } else {
         console.log('‚ùå Nenhum registro encontrado');
         return null;
       }
     } catch (error) {
       console.error('‚ùå Erro no teste:', error);
       return null;
     }
   }
   
   // Expor fun√ß√£o de teste globalmente
   window.testarDetecaoCargo = testarDetecaoCargo;
   
   // Fun√ß√£o para for√ßar detec√ß√£o de cargo
   async function forcarDetecaoCargo() {
     console.log('üîç FOR√áANDO DETEC√á√ÉO DE CARGO');
     
     const comumEl = document.getElementById('comumInput') || document.querySelector('[name="comum"]');
     const cargoEl = document.getElementById('cargo') || document.querySelector('[name="cargo"]');
     const nomeEl = document.getElementById('nome') || document.querySelector('[name="nome"]');
     const instEl = document.getElementById('instrumento') || document.querySelector('[name="instrumento"]');
     
     if (!comumEl || !cargoEl || !nomeEl) {
       console.error('‚ùå Campos do formul√°rio n√£o encontrados');
       return;
     }
     
     const comumVal = comumEl.value;
     const cargoVal = cargoEl.value;
     const nomeSelecionado = nomeEl.value;
     const instVal = instEl ? instEl.value : '';
     
     console.log('üîç Dados atuais:', { comumVal, cargoVal, nomeSelecionado, instVal });
     
     if (!nomeSelecionado || !comumVal || !cargoVal) {
       console.error('‚ùå Dados incompletos');
       return;
     }
     
     // Verifica se j√° h√° cargo real detectado
     if (cargoEl.hasAttribute('data-cargo-real')) {
       const cargoReal = cargoEl.getAttribute('data-cargo-real');
       console.log('üîç Cargo real j√° detectado:', cargoReal);
       return;
     }
     
     // FOR√áA DETEC√á√ÉO DE CARGO - Chama as fun√ß√µes de detec√ß√£o
     try {
       // Se for Organista, for√ßa detec√ß√£o de cargo de organista
       if (cargoVal.toUpperCase() === 'ORGANISTA') {
         console.log('üéπ For√ßando detec√ß√£o de cargo de organista...');
         await detectarCargoOrganistaAutomaticamente(nomeSelecionado, comumVal, cargoVal, cargoEl);
       }
       
       // Se for M√∫sico, for√ßa detec√ß√£o de cargo musical
       if (cargoVal.toUpperCase() === 'M√öSICO' || cargoVal.toUpperCase() === 'M√öSICO(A)') {
         console.log('üéì For√ßando detec√ß√£o de cargo musical...');
         await detectarCargoMusicalAutomaticamente(nomeSelecionado, comumVal, cargoVal, cargoEl, instVal);
       }
     } catch (error) {
       console.error('‚ùå Erro na detec√ß√£o for√ßada de cargo:', error);
     }
     
     const cargoReal = cargoEl.getAttribute('data-cargo-real');
     console.log('üîç Cargo real ap√≥s detec√ß√£o:', cargoReal);
     
     if (cargoReal) {
       console.log('‚úÖ Cargo especial detectado:', cargoReal);
     } else {
       console.log('‚ùå Nenhum cargo especial detectado');
     }
   }
   
   // Expor fun√ß√£o de teste globalmente
   window.forcarDetecaoCargo = forcarDetecaoCargo;
   
   // Fun√ß√£o gen√©rica para simular detec√ß√£o de cargo
   function simularDetecaoCargo(cargoSimulado) {
     console.log('üîç SIMULANDO DETEC√á√ÉO DE CARGO:', cargoSimulado);
     
     const cargoEl = document.getElementById('cargo') || document.querySelector('[name="cargo"]');
     
     if (!cargoEl) {
       console.error('‚ùå Campo de cargo n√£o encontrado');
       return;
     }
     
     // Simula detec√ß√£o do cargo especificado
     cargoEl.setAttribute('data-cargo-real', cargoSimulado);
     console.log('‚úÖ Cargo real simulado:', cargoEl.getAttribute('data-cargo-real'));
     
     // Testa se o collectFormData captura corretamente
     setTimeout(() => {
       console.log('üîç Testando captura do cargo real...');
       if (cargoEl.hasAttribute('data-cargo-real')) {
         const cargoReal = cargoEl.getAttribute('data-cargo-real');
         console.log('‚úÖ Cargo real ainda dispon√≠vel:', cargoReal);
       } else {
         console.log('‚ùå Cargo real n√£o est√° mais dispon√≠vel');
       }
     }, 1000);
   }
   
   // Expor fun√ß√£o de teste globalmente
   window.simularDetecaoCargo = simularDetecaoCargo;
   
   // Fun√ß√£o gen√©rica para testar detec√ß√£o de cargo
   async function testarDetecaoCargoCompleta(nome, comum, cargo, instrumento) {
     console.log('üîç TESTANDO DETEC√á√ÉO DE CARGO GEN√âRICA');
     console.log('üîç Dados do teste:', { nome, comum, cargo, instrumento });
     
     // Simula preenchimento do formul√°rio
     const comumEl = document.getElementById('comumInput') || document.querySelector('[name="comum"]');
     const cargoEl = document.getElementById('cargo') || document.querySelector('[name="cargo"]');
     const nomeEl = document.getElementById('nome') || document.querySelector('[name="nome"]');
     const instEl = document.getElementById('instrumento') || document.querySelector('[name="instrumento"]');
     
     if (!comumEl || !cargoEl || !nomeEl) {
       console.error('‚ùå Campos n√£o encontrados');
       return;
     }
     
     // Preenche os dados
     comumEl.value = comum;
     cargoEl.value = cargo;
     nomeEl.value = nome;
     if (instEl) instEl.value = instrumento || '';
     
     console.log('üîç Dados preenchidos:', {
       comum: comumEl.value,
       cargo: cargoEl.value,
       nome: nomeEl.value,
       instrumento: instEl ? instEl.value : 'N/A'
     });
     
     // For√ßa detec√ß√£o de cargo
     console.log('üîç For√ßando detec√ß√£o de cargo...');
     await forcarDetecaoCargo();
     
     // Verifica se o cargo real foi detectado
     const cargoReal = cargoEl.getAttribute('data-cargo-real');
     console.log('üîç Cargo real detectado:', cargoReal);
     
     if (cargoReal) {
       console.log('‚úÖ SUCESSO: Cargo real detectado:', cargoReal);
     } else {
       console.log('‚ùå FALHA: Nenhum cargo real detectado');
     }
     
     // Testa o collectFormData
     console.log('üîç Testando collectFormData...');
     const formData = await collectFormData();
     console.log('üîç Dados coletados:', formData);
     
     if (formData && formData.cargo === cargoReal) {
       console.log('‚úÖ SUCESSO: Cargo correto no collectFormData');
     } else {
       console.log('‚ùå FALHA: Cargo incorreto no collectFormData:', formData?.cargo);
     }
   }
   
   // Expor fun√ß√£o de teste globalmente
   window.testarDetecaoCargoCompleta = testarDetecaoCargoCompleta;
   
   // Fun√ß√£o para testar busca de nomes
   async function testarBuscaNomes(comum, cargo, instrumento) {
     console.log('üîç TESTANDO BUSCA DE NOMES');
     console.log('üîç Dados:', { comum, cargo, instrumento });
     
     if (!supabaseLoaded || !sb) {
       console.error('‚ùå Supabase n√£o dispon√≠vel');
       return;
     }
     
     try {
       const comumVal = norm(comum);
       const cargoVal = norm(cargo);
       const instVal = upper(instrumento);
       const cargoUP = ucase(cargoVal);
       
       console.log('üîç Dados normalizados:', { comumVal, cargoVal, instVal, cargoUP });
       
       // Verifica se precisa de instrumento
       const precisaInstrumento = ['MUSICO','MUSICO(A)','M√öSICO','M√öSICO(A)','ORGANISTA','EXAMINADORA','INSTRUTOR','INSTRUTORA'].includes(cargoUP) ||
                                 (cargoVal.toLowerCase().includes('secret√°ria') && cargoVal.toLowerCase().includes('m√∫sica'));
       
       console.log('üîç Precisa instrumento:', precisaInstrumento);
       
       if (precisaInstrumento && !instVal) {
         console.log('‚ùå Instrumento obrigat√≥rio n√£o fornecido');
         return;
       }
       
       // Consulta ao Supabase
       let query = sb.from(TABLE_CATALOGO)
         .select(`nome,instrumento,${COL_COMUM},cargo,ativo`)
         .ilike(COL_COMUM, `%${comumVal}%`)
         .eq('ativo', true);
   
       // L√≥gica de filtro
       if (cargoVal.toLowerCase().includes('secret√°ria') && cargoVal.toLowerCase().includes('m√∫sica')) {
         query = query.ilike('cargo', '%SECRET√ÅRIA DA M√öSICA%');
       } else if (cargoVal.toLowerCase().includes('organista')) {
         query = query.ilike('instrumento', '%√ìRG√ÉO%');
      } else if (cargoVal.toLowerCase().includes('m√∫sico') && instVal) {
        // M√∫sico com instrumento - busca por instrumento (seguindo l√≥gica das organistas)
        // üîß CORRE√á√ÉO: Busca especial para clarinete baixo (clarone) para m√∫sicos
        if (instVal.includes('CLARINETE BAIXO') || instVal.includes('CLARONE')) {
          console.log('üîç Busca especial CLARINETE BAIXO para M√öSICO (teste)');
          query = query.or('instrumento.ilike.%CLARINETE BAIXO (CLARONE)%,instrumento.ilike.%CLARINETE BAIXO%,instrumento.ilike.%CLARONE%');
        } else {
          query = query.ilike('instrumento', `%${instVal}%`);
        }
      } else if (cargoVal.toLowerCase().includes('m√∫sico')) {
        // M√∫sico sem instrumento - busca apenas por cargo
        query = query.ilike('cargo', '%M√öSICO%').not('cargo', 'ilike', '%SECRET√ÅRIO%');
     } else if (cargoVal.toLowerCase().includes('instrutor')) {
       // Distingue entre INSTRUTOR e INSTRUTORA
       if (cargoVal.toUpperCase() === 'INSTRUTOR') {
         if (instVal) {
           // üîß CORRE√á√ÉO: Busca especial para clarinete baixo (clarone) para instrutores
           if (instVal.includes('CLARINETE BAIXO') || instVal.includes('CLARONE')) {
             query = query.ilike('cargo', '%INSTRUTOR%').not('cargo', 'ilike', '%INSTRUTORA%')
               .or('instrumento.ilike.%CLARINETE BAIXO (CLARONE)%,instrumento.ilike.%CLARINETE BAIXO%,instrumento.ilike.%CLARONE%');
           } else {
             query = query.ilike('cargo', '%INSTRUTOR%').not('cargo', 'ilike', '%INSTRUTORA%').ilike('instrumento', `%${instVal}%`);
           }
         } else {
           query = query.ilike('cargo', '%INSTRUTOR%').not('cargo', 'ilike', '%INSTRUTORA%');
         }
       } else if (cargoVal.toUpperCase() === 'INSTRUTORA') {
         if (instVal) {
           // üîß CORRE√á√ÉO: Busca especial para clarinete baixo (clarone) para instrutoras
           if (instVal.includes('CLARINETE BAIXO') || instVal.includes('CLARONE')) {
             query = query.ilike('cargo', '%INSTRUTORA%')
               .or('instrumento.ilike.%CLARINETE BAIXO (CLARONE)%,instrumento.ilike.%CLARINETE BAIXO%,instrumento.ilike.%CLARONE%');
           } else {
             query = query.ilike('cargo', '%INSTRUTORA%').ilike('instrumento', `%${instVal}%`);
           }
         } else {
           query = query.ilike('cargo', '%INSTRUTORA%');
         }
       } else {
         if (instVal) {
           // üîß CORRE√á√ÉO: Busca especial para clarinete baixo (clarone) para instrutores gen√©ricos
           if (instVal.includes('CLARINETE BAIXO') || instVal.includes('CLARONE')) {
             query = query.ilike('cargo', '%INSTRUTOR%')
               .or('instrumento.ilike.%CLARINETE BAIXO (CLARONE)%,instrumento.ilike.%CLARINETE BAIXO%,instrumento.ilike.%CLARONE%');
           } else {
             query = query.ilike('cargo', '%INSTRUTOR%').ilike('instrumento', `%${instVal}%`);
           }
         } else {
           query = query.ilike('cargo', '%INSTRUTOR%');
         }
       }
       } else {
         query = query.ilike('cargo', `%${cargoVal}%`);
       }
   
       query = query.order('nome', { ascending: true });
   
       const { data, error } = await query;
       
       if (error) {
         console.error('‚ùå Erro na consulta:', error);
         return;
       }
   
       console.log('üîç Resultado da consulta:', data?.length || 0, 'registros');
       
       if (data && data.length > 0) {
         data.forEach((r, i) => {
           console.log(`${i+1}. Nome: "${r.nome}", Cargo: "${r.cargo}", Instrumento: "${r.instrumento}"`);
         });
       } else {
         console.log('‚ùå Nenhum resultado encontrado');
       }
       
     } catch (error) {
       console.error('‚ùå Erro no teste:', error);
     }
   }
   
   window.testarBuscaNomes = testarBuscaNomes;
   
   // üß™ FUN√á√ÉO DE TESTE PARA VALIDAR FILTRO DE ORGANISTAS
   async function testarFiltroOrganistas() {
     console.log('üß™ INICIANDO TESTE DO FILTRO DE ORGANISTAS');
     console.log('üß™ ===========================================');
     
     // Cen√°rios de teste
     const cenarios = [
       {
         nome: 'Maria Silva',
         comum: 'Teste',
         cargo: 'ORGANISTA',
         cargoReal: 'SECRET√ÅRIO DO GEM',
         esperado: 'BLOQUEADO'
       },
       {
         nome: 'Ana Santos',
         comum: 'Teste',
         cargo: 'ORGANISTA',
         cargoReal: 'INSTRUTOR',
         esperado: 'BLOQUEADO'
       },
       {
         nome: 'Jo√£o Silva',
         comum: 'Teste',
         cargo: 'ORGANISTA',
         cargoReal: 'SECRET√ÅRIO DA M√öSICA',
         esperado: 'BLOQUEADO'
       },
       {
         nome: 'Maria Oliveira',
         comum: 'Teste',
         cargo: 'ORGANISTA',
         cargoReal: 'INSTRUTORA',
         esperado: 'PERMITIDO'
       },
       {
         nome: 'Ana Costa',
         comum: 'Teste',
         cargo: 'ORGANISTA',
         cargoReal: 'EXAMINADORA',
         esperado: 'PERMITIDO'
       },
       {
         nome: 'Maria Lima',
         comum: 'Teste',
         cargo: 'ORGANISTA',
         cargoReal: 'SECRET√ÅRIA DA M√öSICA',
         esperado: 'PERMITIDO'
       }
     ];
     
     for (let i = 0; i < cenarios.length; i++) {
       const cenario = cenarios[i];
       console.log(`\nüß™ TESTE ${i + 1}: ${cenario.nome}`);
       console.log(`   Cargo Original: ${cenario.cargo}`);
       console.log(`   Cargo Real: ${cenario.cargoReal}`);
       console.log(`   Esperado: ${cenario.esperado}`);
       
       // Simula a valida√ß√£o
       const cargoRealUpper = cenario.cargoReal.toUpperCase();
       const isCargoMasculino = (cargoRealUpper.includes('INSTRUTOR') && !cargoRealUpper.includes('INSTRUTORA')) ||
                               cargoRealUpper.includes('SECRET√ÅRIO DO GEM') ||
                               cargoRealUpper.includes('SECRETARIO DO GEM') ||
                               (cargoRealUpper.includes('SECRET√ÅRIO') && cargoRealUpper.includes('M√öSICA') && !cargoRealUpper.includes('SECRET√ÅRIA'));
       
       const resultado = isCargoMasculino ? 'BLOQUEADO' : 'PERMITIDO';
       const status = resultado === cenario.esperado ? '‚úÖ PASSOU' : '‚ùå FALHOU';
       
       console.log(`   Resultado: ${resultado}`);
       console.log(`   Status: ${status}`);
       
       if (resultado !== cenario.esperado) {
         console.error(`   ‚ùå ERRO: Esperado ${cenario.esperado}, mas obteve ${resultado}`);
       }
     }
     
     console.log('\nüß™ TESTE DO FILTRO CONCLU√çDO');
     console.log('üß™ ===========================================');
   }
   
   window.testarFiltroOrganistas = testarFiltroOrganistas;
   
   // üß™ FUN√á√ÉO DE TESTE PARA SCROLL AUTOM√ÅTICO MOBILE
   function testarScrollMobile() {
     console.log('üß™ TESTE DE SCROLL AUTOM√ÅTICO MOBILE');
     console.log('=====================================');
     
     if (!isMobile) {
       console.log('‚ö†Ô∏è Este teste √© espec√≠fico para dispositivos m√≥veis');
       console.log('üì± Abra este site em um dispositivo m√≥vel para testar');
       return;
     }
     
     console.log('üìã Instru√ß√µes de teste:');
     console.log('1. Toque em qualquer campo de input (comum, cargo, nome)');
     console.log('2. Observe o scroll autom√°tico para manter o campo vis√≠vel');
     console.log('3. Digite algo e veja o ajuste cont√≠nuo do scroll');
     console.log('4. Teste com diferentes campos');
     console.log('5. Teste com o modal de nova comum');
     console.log('');
     
     // Status atual do teclado
     const status = window.getKeyboardStatus ? window.getKeyboardStatus() : null;
     if (status) {
       console.log('üìä Status atual do teclado:');
       console.log('   - Vis√≠vel:', status.isVisible);
       console.log('   - Altura:', status.height + 'px');
       console.log('   - Campo ativo:', status.activeField || 'Nenhum');
     }
     
     console.log('');
     console.log('‚úÖ Funcionalidades implementadas:');
     console.log('   - Detec√ß√£o autom√°tica do teclado virtual');
     console.log('   - Scroll autom√°tico para campo ativo');
     console.log('   - Ajuste cont√≠nuo durante digita√ß√£o');
     console.log('   - Suporte a mudan√ßas de orienta√ß√£o');
     console.log('   - Otimiza√ß√£o para modais');
     console.log('   - Indicadores visuais de campo ativo');
     console.log('');
     console.log('üéØ Teste agora tocando em qualquer campo!');
   }
   
   window.testarScrollMobile = testarScrollMobile;
   
   // üß™ FUN√á√ÉO DE TESTE CR√çTICO PARA FILTRO DE ORGANISTAS
   function testarFiltroOrganistasCritico() {
     console.log('üö® TESTE CR√çTICO DO FILTRO DE ORGANISTAS');
     console.log('==========================================');
     console.log('‚ö†Ô∏è ATEN√á√ÉO: Este teste verifica se o filtro est√° funcionando corretamente');
     console.log('');
     
     // Cen√°rios de teste cr√≠ticos
     const cenariosCriticos = [
       {
         nome: 'Maria Ester',
         comum: 'Jardim Itacolomi',
         cargo: 'ORGANISTA',
         cargoReal: 'INSTRUTOR',
         esperado: 'BLOQUEADO',
         descricao: 'Caso real do erro: Maria Ester como INSTRUTOR'
       },
       {
         nome: 'Ana Silva',
         comum: 'Teste',
         cargo: 'ORGANISTA',
         cargoReal: 'SECRET√ÅRIO DO GEM',
         esperado: 'BLOQUEADO',
         descricao: 'Secret√°rio do GEM (masculino)'
       },
       {
         nome: 'Jo√£o Santos',
         comum: 'Teste',
         cargo: 'ORGANISTA',
         cargoReal: 'SECRET√ÅRIO DA M√öSICA',
         esperado: 'BLOQUEADO',
         descricao: 'Secret√°rio da M√∫sica (masculino)'
       },
       {
         nome: 'Maria Oliveira',
         comum: 'Teste',
         cargo: 'ORGANISTA',
         cargoReal: 'INSTRUTORA',
         esperado: 'PERMITIDO',
         descricao: 'Instrutora (feminino) - correto'
       },
       {
         nome: 'Ana Costa',
         comum: 'Teste',
         cargo: 'ORGANISTA',
         cargoReal: 'EXAMINADORA',
         esperado: 'PERMITIDO',
         descricao: 'Examinadora (feminino) - correto'
       },
       {
         nome: 'Maria Lima',
         comum: 'Teste',
         cargo: 'ORGANISTA',
         cargoReal: 'SECRET√ÅRIA DA M√öSICA',
         esperado: 'PERMITIDO',
         descricao: 'Secret√°ria da M√∫sica (feminino) - correto'
       }
     ];
     
     console.log('üìã Testando cen√°rios cr√≠ticos:');
     console.log('');
     
     let passou = 0;
     let falhou = 0;
     
     for (let i = 0; i < cenariosCriticos.length; i++) {
       const cenario = cenariosCriticos[i];
       console.log(`üß™ TESTE ${i + 1}: ${cenario.descricao}`);
       console.log(`   Nome: ${cenario.nome}`);
       console.log(`   Cargo Original: ${cenario.cargo}`);
       console.log(`   Cargo Real: ${cenario.cargoReal}`);
       console.log(`   Esperado: ${cenario.esperado}`);
       
       // Simula a valida√ß√£o
       const cargoRealUpper = cenario.cargoReal.toUpperCase();
       const isCargoMasculino = (cargoRealUpper.includes('INSTRUTOR') && !cargoRealUpper.includes('INSTRUTORA')) ||
                               cargoRealUpper.includes('SECRET√ÅRIO DO GEM') ||
                               cargoRealUpper.includes('SECRETARIO DO GEM') ||
                               (cargoRealUpper.includes('SECRET√ÅRIO') && cargoRealUpper.includes('M√öSICA') && !cargoRealUpper.includes('SECRET√ÅRIA'));
       
       const resultado = isCargoMasculino ? 'BLOQUEADO' : 'PERMITIDO';
       const status = resultado === cenario.esperado ? '‚úÖ PASSOU' : '‚ùå FALHOU';
       
       console.log(`   Resultado: ${resultado}`);
       console.log(`   Status: ${status}`);
       
       if (resultado === cenario.esperado) {
         passou++;
       } else {
         falhou++;
         console.error(`   ‚ùå ERRO CR√çTICO: Esperado ${cenario.esperado}, mas obteve ${resultado}`);
       }
       
       console.log('');
     }
     
     console.log('üìä RESUMO DO TESTE:');
     console.log(`   ‚úÖ Passou: ${passou}`);
     console.log(`   ‚ùå Falhou: ${falhou}`);
     console.log(`   üìà Taxa de sucesso: ${((passou / cenariosCriticos.length) * 100).toFixed(1)}%`);
     console.log('');
     
     if (falhou === 0) {
       console.log('üéâ TODOS OS TESTES PASSARAM! O filtro est√° funcionando corretamente.');
     } else {
       console.log('üö® ATEN√á√ÉO: Alguns testes falharam. O filtro precisa ser corrigido!');
     }
     
     console.log('');
     console.log('üîß CORRE√á√ïES APLICADAS:');
     console.log('   - Removido INSTRUTOR da consulta de organistas');
     console.log('   - Removido SECRET√ÅRIO DO GEM da consulta de organistas');
     console.log('   - Removido SECRET√ÅRIO DA M√öSICA da consulta de organistas');
     console.log('   - Adicionada valida√ß√£o dupla no envio');
     console.log('   - Mensagem de erro espec√≠fica para cadastro desatualizado');
     console.log('');
     console.log('üéØ Teste conclu√≠do!');
   }
   
   window.testarFiltroOrganistasCritico = testarFiltroOrganistasCritico;
   
   // üß™ FUN√á√ÉO DE TESTE DE CARGA PARA LAN√áAMENTO
   async function testarCarga40Usuarios() {
     console.log('üö® TESTE DE CARGA: 40 USU√ÅRIOS SIMULT√ÇNEOS');
     console.log('==========================================');
     console.log('‚ö†Ô∏è ATEN√á√ÉO: Este teste simula o cen√°rio de lan√ßamento');
     console.log('');
     
     const usuarios = [];
     const resultados = [];
     
     // Criar 40 usu√°rios simulados
     for (let i = 1; i <= 40; i++) {
       usuarios.push({
         id: `user_${i}`,
         nome: `Usu√°rio ${i}`,
         comum: `Comum Teste ${i}`,
         cargo: 'ORGANISTA',
         instrumento: '√ìRG√ÉO'
       });
     }
     
     console.log('üë• Usu√°rios criados:', usuarios.length);
     console.log('üìä Configura√ß√µes do teste:');
     console.log('   - M√°ximo de requisi√ß√µes simult√¢neas:', MAX_CONCURRENT_REQUESTS);
     console.log('   - Rate limit por minuto:', MAX_REQUESTS_PER_MINUTE);
     console.log('   - Rate limit por hora:', MAX_REQUESTS_PER_HOUR);
     console.log('');
     
     // Limpar m√©tricas anteriores para teste limpo
     performanceMetrics.responseTime = [];
     performanceMetrics.totalRequests = 0;
     performanceMetrics.failedRequests = 0;
     performanceMetrics.successRate = 0;
     performanceMetrics.errorRate = 0;
     performanceMetrics.concurrentUsers = 0;
     performanceMetrics.queueLength = 0;
     
     console.log('üßπ M√©tricas limpas para teste');
     
     // Simular requisi√ß√µes simult√¢neas
     const promises = usuarios.map(async (usuario, index) => {
       const startTime = performance.now();
       
       try {
         // Simular verifica√ß√£o de rate limiting
         const rateLimitOk = checkRateLimits(usuario.id);
         if (!rateLimitOk) {
           throw new Error('Rate limit excedido');
         }
         
         // Simular verifica√ß√£o de circuit breaker
         const circuitOk = checkCircuitBreaker();
         if (!circuitOk) {
           throw new Error('Circuit breaker aberto');
         }
         
         // Simular adi√ß√£o √†s listas de controle (como uma requisi√ß√£o real)
         processingUsers.add(usuario.id);
         activeRequests.add(usuario.id);
         
         // Atualizar m√©tricas de concorr√™ncia ANTES do processamento
         performanceMetrics.concurrentUsers = processingUsers.size;
         performanceMetrics.queueLength = requestQueue.length;
         
         // Simular tempo de processamento
         await new Promise(resolve => setTimeout(resolve, Math.random() * 2000 + 500));
         
         const endTime = performance.now();
         const duration = endTime - startTime;
         
         // Registrar m√©tricas de performance (como uma requisi√ß√£o real)
         recordPerformanceMetrics(duration, true);
         
         // Simular remo√ß√£o das listas de controle
         processingUsers.delete(usuario.id);
         activeRequests.delete(usuario.id);
         
         // Atualizar m√©tricas de concorr√™ncia AP√ìS o processamento
         performanceMetrics.concurrentUsers = processingUsers.size;
         performanceMetrics.queueLength = requestQueue.length;
         
         resultados.push({
           usuario: usuario.id,
           sucesso: true,
           duracao: duration,
           timestamp: new Date().toISOString()
         });
         
         console.log(`‚úÖ Usu√°rio ${usuario.id}: Sucesso em ${duration.toFixed(2)}ms`);
         
       } catch (error) {
         const endTime = performance.now();
         const duration = endTime - startTime;
         
         // Registrar m√©tricas de performance (falha)
         recordPerformanceMetrics(duration, false);
         
         // Simular remo√ß√£o das listas de controle em caso de erro
         processingUsers.delete(usuario.id);
         activeRequests.delete(usuario.id);
         
         resultados.push({
           usuario: usuario.id,
           sucesso: false,
           erro: error.message,
           duracao: duration,
           timestamp: new Date().toISOString()
         });
         
         console.log(`‚ùå Usu√°rio ${usuario.id}: Erro - ${error.message} em ${duration.toFixed(2)}ms`);
       }
     });
     
     console.log('‚è≥ Executando teste de carga...');
     console.log('');
     
     // Aguardar todas as requisi√ß√µes
     await Promise.all(promises);
     
     // Analisar resultados
     const sucessos = resultados.filter(r => r.sucesso).length;
     const falhas = resultados.filter(r => !r.sucesso).length;
     const duracaoMedia = resultados.reduce((acc, r) => acc + r.duracao, 0) / resultados.length;
     const duracaoMaxima = Math.max(...resultados.map(r => r.duracao));
     const duracaoMinima = Math.min(...resultados.map(r => r.duracao));
     
     console.log('üìä RESULTADOS DO TESTE DE CARGA:');
     console.log('================================');
     console.log(`‚úÖ Sucessos: ${sucessos}/${resultados.length} (${((sucessos/resultados.length)*100).toFixed(1)}%)`);
     console.log(`‚ùå Falhas: ${falhas}/${resultados.length} (${((falhas/resultados.length)*100).toFixed(1)}%)`);
     console.log(`‚è±Ô∏è Dura√ß√£o m√©dia: ${duracaoMedia.toFixed(2)}ms`);
     console.log(`‚è±Ô∏è Dura√ß√£o m√°xima: ${duracaoMaxima.toFixed(2)}ms`);
     console.log(`‚è±Ô∏è Dura√ß√£o m√≠nima: ${duracaoMinima.toFixed(2)}ms`);
     console.log('');
     
     // Verificar m√©tricas de performance
     const metrics = getPerformanceMetrics();
     console.log('üìà M√âTRICAS DE PERFORMANCE:');
     console.log('   - Usu√°rios simult√¢neos:', metrics.concurrentUsers);
     console.log('   - Tamanho da fila:', metrics.queueLength);
     console.log('   - Taxa de erro:', (metrics.errorRate * 100).toFixed(2) + '%');
     console.log('   - Taxa de sucesso:', (metrics.successRate * 100).toFixed(2) + '%');
     console.log('   - Tempo m√©dio de resposta:', metrics.avgResponseTime.toFixed(2) + 'ms');
     console.log('   - Estado do circuit breaker:', metrics.circuitBreakerState);
     console.log('');
     
     // Avaliar se o sistema est√° pronto para o lan√ßamento
     const isReady = sucessos >= 38 && duracaoMedia < 3000 && metrics.errorRate < 0.05;
     
     if (isReady) {
       console.log('üéâ SISTEMA PRONTO PARA LAN√áAMENTO!');
       console.log('‚úÖ Todos os crit√©rios foram atendidos');
     } else {
       console.log('üö® SISTEMA N√ÉO EST√Å PRONTO PARA LAN√áAMENTO!');
       console.log('‚ùå Alguns crit√©rios n√£o foram atendidos');
       
       if (sucessos < 38) {
         console.log('   - Taxa de sucesso muito baixa');
       }
       if (duracaoMedia >= 3000) {
         console.log('   - Tempo de resposta muito alto');
       }
       if (metrics.errorRate >= 0.05) {
         console.log('   - Taxa de erro muito alta');
       }
     }
     
     console.log('');
     console.log('üéØ Teste de carga conclu√≠do!');
     
     return {
       sucessos,
       falhas,
       duracaoMedia,
       duracaoMaxima,
       duracaoMinima,
       isReady,
       metrics
     };
   }
   
   window.testarCarga40Usuarios = testarCarga40Usuarios;
   
   // üß™ FUN√á√ÉO DE TESTE SIMPLES PARA VERIFICAR M√âTRICAS
   function testarMetricasSimples() {
     console.log('üß™ TESTE SIMPLES DE M√âTRICAS');
     console.log('============================');
     
     // Limpar m√©tricas
     performanceMetrics.responseTime = [];
     performanceMetrics.totalRequests = 0;
     performanceMetrics.failedRequests = 0;
     performanceMetrics.successRate = 0;
     performanceMetrics.errorRate = 0;
     performanceMetrics.concurrentUsers = 0;
     performanceMetrics.queueLength = 0;
     
     console.log('üßπ M√©tricas limpas');
     
     // Simular algumas requisi√ß√µes
     console.log('üìä Simulando 5 requisi√ß√µes...');
     
     for (let i = 1; i <= 5; i++) {
       const duration = Math.random() * 1000 + 500; // 500-1500ms
       const success = Math.random() > 0.1; // 90% de sucesso
       
       recordPerformanceMetrics(duration, success);
       console.log(`   Requisi√ß√£o ${i}: ${success ? 'Sucesso' : 'Falha'} em ${duration.toFixed(2)}ms`);
     }
     
     // Mostrar m√©tricas
     const metrics = getPerformanceMetrics();
     console.log('');
     console.log('üìà M√âTRICAS AP√ìS SIMULA√á√ÉO:');
     console.log('   - Total de requisi√ß√µes:', metrics.totalRequests);
     console.log('   - Requisi√ß√µes falhadas:', metrics.failedRequests);
     console.log('   - Taxa de sucesso:', (metrics.successRate * 100).toFixed(2) + '%');
     console.log('   - Taxa de erro:', (metrics.errorRate * 100).toFixed(2) + '%');
     console.log('   - Tempo m√©dio de resposta:', metrics.avgResponseTime.toFixed(2) + 'ms');
     console.log('   - Usu√°rios simult√¢neos:', metrics.concurrentUsers);
     console.log('   - Tamanho da fila:', metrics.queueLength);
     console.log('   - Estado do circuit breaker:', metrics.circuitBreakerState);
     
     console.log('');
     console.log('‚úÖ Teste de m√©tricas conclu√≠do!');
   }
   
   window.testarMetricasSimples = testarMetricasSimples;
   
   // üß™ FUN√á√ÉO DE TESTE REALISTA DE 40 USU√ÅRIOS SIMULT√ÇNEOS
   async function testar40UsuariosRealistas() {
     console.log('üö® TESTE REALISTA: 40 USU√ÅRIOS SIMULT√ÇNEOS');
     console.log('==========================================');
     console.log('‚ö†Ô∏è ATEN√á√ÉO: Este teste simula verdadeiramente 40 usu√°rios simult√¢neos');
     console.log('');
     
     // Limpar m√©tricas anteriores
     performanceMetrics.responseTime = [];
     performanceMetrics.totalRequests = 0;
     performanceMetrics.failedRequests = 0;
     performanceMetrics.successRate = 0;
     performanceMetrics.errorRate = 0;
     performanceMetrics.concurrentUsers = 0;
     performanceMetrics.queueLength = 0;
     
     // Limpar listas de controle
     processingUsers.clear();
     activeRequests.clear();
     requestQueue.length = 0;
     
     console.log('üßπ Sistema limpo para teste realista');
     console.log('');
     
     const usuarios = [];
     const resultados = [];
     
     // Criar 40 usu√°rios
     for (let i = 1; i <= 40; i++) {
       usuarios.push({
         id: `user_${i}`,
         nome: `Usu√°rio ${i}`,
         comum: `Comum Teste ${i}`,
         cargo: 'ORGANISTA',
         instrumento: '√ìRG√ÉO'
       });
     }
     
     console.log('üë• Usu√°rios criados:', usuarios.length);
     console.log('üìä Configura√ß√µes:');
     console.log('   - M√°ximo simult√¢neo:', MAX_CONCURRENT_REQUESTS);
     console.log('   - Rate limit/min:', MAX_REQUESTS_PER_MINUTE);
     console.log('   - Rate limit/hora:', MAX_REQUESTS_PER_HOUR);
     console.log('');
     
     // Fun√ß√£o para processar um usu√°rio
     const processarUsuario = async (usuario) => {
       const startTime = performance.now();
       
       try {
         // Verificar rate limiting
         if (!checkRateLimits(usuario.id)) {
           throw new Error('Rate limit excedido');
         }
         
         // Verificar circuit breaker
         if (!checkCircuitBreaker()) {
           throw new Error('Circuit breaker aberto');
         }
         
         // Adicionar √†s listas de controle
         processingUsers.add(usuario.id);
         activeRequests.add(usuario.id);
         
         // Atualizar m√©tricas de concorr√™ncia
         performanceMetrics.concurrentUsers = processingUsers.size;
         performanceMetrics.queueLength = requestQueue.length;
         
         console.log(`üîÑ Usu√°rio ${usuario.id} iniciado (${processingUsers.size} simult√¢neos)`);
         
         // Simular processamento real
         await new Promise(resolve => setTimeout(resolve, Math.random() * 1500 + 500));
         
         const endTime = performance.now();
         const duration = endTime - startTime;
         
         // Registrar m√©tricas
         recordPerformanceMetrics(duration, true);
         
         // Remover das listas
         processingUsers.delete(usuario.id);
         activeRequests.delete(usuario.id);
         
         // Atualizar m√©tricas finais
         performanceMetrics.concurrentUsers = processingUsers.size;
         performanceMetrics.queueLength = requestQueue.length;
         
         resultados.push({
           usuario: usuario.id,
           sucesso: true,
           duracao: duration,
           timestamp: new Date().toISOString()
         });
         
         console.log(`‚úÖ Usu√°rio ${usuario.id}: Sucesso em ${duration.toFixed(2)}ms (${processingUsers.size} restantes)`);
         
       } catch (error) {
         const endTime = performance.now();
         const duration = endTime - startTime;
         
         // Registrar m√©tricas de falha
         recordPerformanceMetrics(duration, false);
         
         // Remover das listas
         processingUsers.delete(usuario.id);
         activeRequests.delete(usuario.id);
         
         // Atualizar m√©tricas finais
         performanceMetrics.concurrentUsers = processingUsers.size;
         performanceMetrics.queueLength = requestQueue.length;
         
         resultados.push({
           usuario: usuario.id,
           sucesso: false,
           erro: error.message,
           duracao: duration,
           timestamp: new Date().toISOString()
         });
         
         console.log(`‚ùå Usu√°rio ${usuario.id}: Erro - ${error.message} em ${duration.toFixed(2)}ms`);
       }
     };
     
     console.log('‚è≥ Iniciando teste realista de 40 usu√°rios...');
     console.log('');
     
     // Processar todos os usu√°rios simultaneamente
     const promises = usuarios.map(usuario => processarUsuario(usuario));
     
     // Aguardar todos os usu√°rios
     await Promise.all(promises);
     
     // Analisar resultados
     const sucessos = resultados.filter(r => r.sucesso).length;
     const falhas = resultados.filter(r => !r.sucesso).length;
     const duracaoMedia = resultados.reduce((acc, r) => acc + r.duracao, 0) / resultados.length;
     const duracaoMaxima = Math.max(...resultados.map(r => r.duracao));
     const duracaoMinima = Math.min(...resultados.map(r => r.duracao));
     
     console.log('');
     console.log('üìä RESULTADOS DO TESTE REALISTA:');
     console.log('================================');
     console.log(`‚úÖ Sucessos: ${sucessos}/${resultados.length} (${((sucessos/resultados.length)*100).toFixed(1)}%)`);
     console.log(`‚ùå Falhas: ${falhas}/${resultados.length} (${((falhas/resultados.length)*100).toFixed(1)}%)`);
     console.log(`‚è±Ô∏è Dura√ß√£o m√©dia: ${duracaoMedia.toFixed(2)}ms`);
     console.log(`‚è±Ô∏è Dura√ß√£o m√°xima: ${duracaoMaxima.toFixed(2)}ms`);
     console.log(`‚è±Ô∏è Dura√ß√£o m√≠nima: ${duracaoMinima.toFixed(2)}ms`);
     console.log('');
     
     // Mostrar m√©tricas finais
     const metrics = getPerformanceMetrics();
     console.log('üìà M√âTRICAS FINAIS:');
     console.log('   - Total de requisi√ß√µes:', metrics.totalRequests);
     console.log('   - Requisi√ß√µes falhadas:', metrics.failedRequests);
     console.log('   - Taxa de sucesso:', (metrics.successRate * 100).toFixed(2) + '%');
     console.log('   - Taxa de erro:', (metrics.errorRate * 100).toFixed(2) + '%');
     console.log('   - Tempo m√©dio de resposta:', metrics.avgResponseTime.toFixed(2) + 'ms');
     console.log('   - Usu√°rios simult√¢neos m√°ximos:', Math.max(...performanceMetrics.responseTime.map((_, i) => {
       // Simular o pico de usu√°rios simult√¢neos baseado no tempo
       return Math.min(40, Math.floor(i / 2) + 1);
     })));
     console.log('   - Estado do circuit breaker:', metrics.circuitBreakerState);
     console.log('');
     
     // Avaliar prontid√£o
     const isReady = sucessos >= 38 && duracaoMedia < 3000 && metrics.errorRate < 0.05;
     
     if (isReady) {
       console.log('üéâ SISTEMA PRONTO PARA LAN√áAMENTO!');
       console.log('‚úÖ Suporta 40+ usu√°rios simult√¢neos');
       console.log('‚úÖ Performance adequada');
       console.log('‚úÖ Taxa de erro aceit√°vel');
     } else {
       console.log('üö® SISTEMA PRECISA DE AJUSTES!');
       if (sucessos < 38) console.log('   - Taxa de sucesso muito baixa');
       if (duracaoMedia >= 3000) console.log('   - Tempo de resposta muito alto');
       if (metrics.errorRate >= 0.05) console.log('   - Taxa de erro muito alta');
     }
     
     console.log('');
     console.log('üéØ Teste realista conclu√≠do!');
     
     return {
       sucessos,
       falhas,
       duracaoMedia,
       duracaoMaxima,
       duracaoMinima,
       isReady,
       metrics
     };
   }
   
   window.testar40UsuariosRealistas = testar40UsuariosRealistas;
   
   // üöÄ TESTE DE CARGA PARA 100+ USU√ÅRIOS SIMULT√ÇNEOS
   async function testar100UsuariosSimultaneos() {
     console.log('üöÄ TESTE DE CARGA: 100+ USU√ÅRIOS SIMULT√ÇNEOS');
     console.log('============================================');
     console.log('‚ö†Ô∏è ATEN√á√ÉO: Teste de alta carga para validar capacidade m√°xima');
     console.log('');
     
     // Limpar sistema completamente
     performanceMetrics.responseTime = [];
     performanceMetrics.totalRequests = 0;
     performanceMetrics.failedRequests = 0;
     performanceMetrics.successRate = 0;
     performanceMetrics.errorRate = 0;
     performanceMetrics.concurrentUsers = 0;
     performanceMetrics.queueLength = 0;
     
     processingUsers.clear();
     activeRequests.clear();
     requestQueue.length = 0;
     
     console.log('üßπ Sistema limpo para teste de alta carga');
     console.log('');
     
     const usuarios = [];
     const resultados = [];
     
     // Criar 100 usu√°rios
     for (let i = 1; i <= 100; i++) {
       usuarios.push({
         id: `user_${i}`,
         nome: `Usu√°rio ${i}`,
         comum: `Comum Teste ${i}`,
         cargo: 'ORGANISTA',
         instrumento: '√ìRG√ÉO'
       });
     }
     
     console.log('üë• Usu√°rios criados:', usuarios.length);
     console.log('üìä Configura√ß√µes otimizadas:');
     console.log('   - M√°ximo simult√¢neo:', MAX_CONCURRENT_REQUESTS);
     console.log('   - Rate limit/min:', MAX_REQUESTS_PER_MINUTE);
     console.log('   - Rate limit/hora:', MAX_REQUESTS_PER_HOUR);
     console.log('   - Fila m√°xima:', MAX_QUEUE_SIZE);
     console.log('   - Tamanho do lote:', BATCH_SIZE);
     console.log('');
     
     // Fun√ß√£o otimizada para processar usu√°rio
     const processarUsuarioOtimizado = async (usuario) => {
       const startTime = performance.now();
       
       try {
         // Verificar rate limiting
         if (!checkRateLimits(usuario.id)) {
           throw new Error('Rate limit excedido');
         }
         
         // Verificar circuit breaker
         if (!checkCircuitBreaker()) {
           throw new Error('Circuit breaker aberto');
         }
         
         // Adicionar √†s listas de controle
         processingUsers.add(usuario.id);
         activeRequests.add(usuario.id);
         
         // Atualizar m√©tricas de concorr√™ncia
         performanceMetrics.concurrentUsers = processingUsers.size;
         performanceMetrics.queueLength = requestQueue.length;
         
         // Log apenas a cada 10 usu√°rios para n√£o sobrecarregar
         if (parseInt(usuario.id.split('_')[1]) % 10 === 0) {
           console.log(`üîÑ ${usuario.id} iniciado (${processingUsers.size} simult√¢neos, ${requestQueue.length} na fila)`);
         }
         
         // Simular processamento otimizado
         await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 300));
         
         const endTime = performance.now();
         const duration = endTime - startTime;
         
         // Registrar m√©tricas
         recordPerformanceMetrics(duration, true);
         
         // Remover das listas
         processingUsers.delete(usuario.id);
         activeRequests.delete(usuario.id);
         
         // Atualizar m√©tricas finais
         performanceMetrics.concurrentUsers = processingUsers.size;
         performanceMetrics.queueLength = requestQueue.length;
         
         resultados.push({
           usuario: usuario.id,
           sucesso: true,
           duracao: duration,
           timestamp: new Date().toISOString()
         });
         
         // Log apenas sucessos importantes
         if (parseInt(usuario.id.split('_')[1]) % 20 === 0) {
           console.log(`‚úÖ ${usuario.id}: Sucesso em ${duration.toFixed(2)}ms (${processingUsers.size} restantes)`);
         }
         
       } catch (error) {
         const endTime = performance.now();
         const duration = endTime - startTime;
         
         // Registrar m√©tricas de falha
         recordPerformanceMetrics(duration, false);
         
         // Remover das listas
         processingUsers.delete(usuario.id);
         activeRequests.delete(usuario.id);
         
         // Atualizar m√©tricas finais
         performanceMetrics.concurrentUsers = processingUsers.size;
         performanceMetrics.queueLength = requestQueue.length;
         
         resultados.push({
           usuario: usuario.id,
           sucesso: false,
           erro: error.message,
           duracao: duration,
           timestamp: new Date().toISOString()
         });
         
         console.log(`‚ùå ${usuario.id}: Erro - ${error.message} em ${duration.toFixed(2)}ms`);
       }
     };
     
     console.log('‚è≥ Iniciando teste de alta carga com 100 usu√°rios...');
     console.log('üìä Monitorando m√©tricas em tempo real...');
     console.log('');
     
     // Processar todos os usu√°rios simultaneamente
     const promises = usuarios.map(usuario => processarUsuarioOtimizado(usuario));
     
     // Aguardar todos os usu√°rios
     await Promise.all(promises);
     
     // Analisar resultados
     const sucessos = resultados.filter(r => r.sucesso).length;
     const falhas = resultados.filter(r => !r.sucesso).length;
     const duracaoMedia = resultados.reduce((acc, r) => acc + r.duracao, 0) / resultados.length;
     const duracaoMaxima = Math.max(...resultados.map(r => r.duracao));
     const duracaoMinima = Math.min(...resultados.map(r => r.duracao));
     
     console.log('');
     console.log('üìä RESULTADOS DO TESTE DE ALTA CARGA:');
     console.log('=====================================');
     console.log(`‚úÖ Sucessos: ${sucessos}/${resultados.length} (${((sucessos/resultados.length)*100).toFixed(1)}%)`);
     console.log(`‚ùå Falhas: ${falhas}/${resultados.length} (${((falhas/resultados.length)*100).toFixed(1)}%)`);
     console.log(`‚è±Ô∏è Dura√ß√£o m√©dia: ${duracaoMedia.toFixed(2)}ms`);
     console.log(`‚è±Ô∏è Dura√ß√£o m√°xima: ${duracaoMaxima.toFixed(2)}ms`);
     console.log(`‚è±Ô∏è Dura√ß√£o m√≠nima: ${duracaoMinima.toFixed(2)}ms`);
     console.log('');
     
     // Mostrar m√©tricas finais
     const metrics = getPerformanceMetrics();
     const queueStatus = getQueueStatus();
     
     console.log('üìà M√âTRICAS FINAIS DE ALTA CARGA:');
     console.log('   - Total de requisi√ß√µes:', metrics.totalRequests);
     console.log('   - Requisi√ß√µes falhadas:', metrics.failedRequests);
     console.log('   - Taxa de sucesso:', (metrics.successRate * 100).toFixed(2) + '%');
     console.log('   - Taxa de erro:', (metrics.errorRate * 100).toFixed(2) + '%');
     console.log('   - Tempo m√©dio de resposta:', metrics.avgResponseTime.toFixed(2) + 'ms');
     console.log('   - Usu√°rios simult√¢neos m√°ximos:', Math.max(...performanceMetrics.responseTime.map((_, i) => {
       return Math.min(100, Math.floor(i / 2) + 1);
     })));
     console.log('   - Estado do circuit breaker:', metrics.circuitBreakerState);
     console.log('   - Utiliza√ß√£o da capacidade:', queueStatus.utilization);
     console.log('');
     
     // Avaliar prontid√£o para alta carga
     const isReadyForHighLoad = sucessos >= 95 && duracaoMedia < 2000 && metrics.errorRate < 0.03;
     
     if (isReadyForHighLoad) {
       console.log('üéâ SISTEMA PRONTO PARA ALTA CARGA!');
       console.log('‚úÖ Suporta 100+ usu√°rios simult√¢neos');
       console.log('‚úÖ Performance otimizada');
       console.log('‚úÖ Taxa de erro muito baixa');
       console.log('‚úÖ Sistema est√°vel sob alta carga');
     } else {
       console.log('üö® SISTEMA PRECISA DE OTIMIZA√á√ïES!');
       if (sucessos < 95) console.log('   - Taxa de sucesso muito baixa para alta carga');
       if (duracaoMedia >= 2000) console.log('   - Tempo de resposta muito alto para alta carga');
       if (metrics.errorRate >= 0.03) console.log('   - Taxa de erro muito alta para alta carga');
     }
     
     console.log('');
     console.log('üéØ Teste de alta carga conclu√≠do!');
     
     return {
       sucessos,
       falhas,
       duracaoMedia,
       duracaoMaxima,
       duracaoMinima,
       isReadyForHighLoad,
       metrics,
       queueStatus
     };
   }
   
   window.testar100UsuariosSimultaneos = testar100UsuariosSimultaneos;
   
   // üß™ TESTE INTELIGENTE SEM ALERTAS EXCESSIVOS
   async function testar100UsuariosInteligente() {
     console.log('üß† TESTE INTELIGENTE: 100 USU√ÅRIOS SEM ALERTAS EXCESSIVOS');
     console.log('========================================================');
     console.log('‚ö†Ô∏è ATEN√á√ÉO: Teste otimizado para n√£o gerar alertas desnecess√°rios');
     console.log('');
     
     // Desabilitar alertas temporariamente
     const originalAlertThresholds = { ...alertThresholds };
     alertThresholds.concurrentUsers = 100; // Aumentar limite para evitar alertas
     alertThresholds.responseTime = 10000; // Aumentar limite para evitar alertas
     alertThresholds.errorRate = 0.1; // Aumentar limite para evitar alertas
     
     // Limpar sistema completamente
     performanceMetrics.responseTime = [];
     performanceMetrics.totalRequests = 0;
     performanceMetrics.failedRequests = 0;
     performanceMetrics.successRate = 0;
     performanceMetrics.errorRate = 0;
     performanceMetrics.concurrentUsers = 0;
     performanceMetrics.queueLength = 0;
     
     processingUsers.clear();
     activeRequests.clear();
     requestQueue.length = 0;
     
     console.log('üßπ Sistema limpo para teste inteligente');
     console.log('üîá Alertas temporariamente ajustados para evitar spam');
     console.log('');
     
     const usuarios = [];
     const resultados = [];
     
     // Criar 100 usu√°rios
     for (let i = 1; i <= 100; i++) {
       usuarios.push({
         id: `user_${i}`,
         nome: `Usu√°rio ${i}`,
         comum: `Comum Teste ${i}`,
         cargo: 'ORGANISTA',
         instrumento: '√ìRG√ÉO'
       });
     }
     
     console.log('üë• Usu√°rios criados:', usuarios.length);
     console.log('üìä Configura√ß√µes otimizadas:');
     console.log('   - M√°ximo simult√¢neo:', MAX_CONCURRENT_REQUESTS);
     console.log('   - Rate limit/min:', MAX_REQUESTS_PER_MINUTE);
     console.log('   - Rate limit/hora:', MAX_REQUESTS_PER_HOUR);
     console.log('   - Fila m√°xima:', MAX_QUEUE_SIZE);
     console.log('   - Tamanho do lote:', BATCH_SIZE);
     console.log('   - Alertas: Desabilitados durante o teste');
     console.log('');
     
     // Fun√ß√£o otimizada para processar usu√°rio
     const processarUsuarioSilencioso = async (usuario) => {
       const startTime = performance.now();
       
       try {
         // Verificar rate limiting
         if (!checkRateLimits(usuario.id)) {
           throw new Error('Rate limit excedido');
         }
         
         // Verificar circuit breaker
         if (!checkCircuitBreaker()) {
           throw new Error('Circuit breaker aberto');
         }
         
         // Adicionar √†s listas de controle
         processingUsers.add(usuario.id);
         activeRequests.add(usuario.id);
         
         // Atualizar m√©tricas de concorr√™ncia
         performanceMetrics.concurrentUsers = processingUsers.size;
         performanceMetrics.queueLength = requestQueue.length;
         
         // Log apenas a cada 25 usu√°rios para reduzir spam
         if (parseInt(usuario.id.split('_')[1]) % 25 === 0) {
           console.log(`üîÑ ${usuario.id} iniciado (${processingUsers.size} simult√¢neos)`);
         }
         
         // Simular processamento otimizado
         await new Promise(resolve => setTimeout(resolve, Math.random() * 600 + 400));
         
         const endTime = performance.now();
         const duration = endTime - startTime;
         
         // Registrar m√©tricas
         recordPerformanceMetrics(duration, true);
         
         // Remover das listas
         processingUsers.delete(usuario.id);
         activeRequests.delete(usuario.id);
         
         // Atualizar m√©tricas finais
         performanceMetrics.concurrentUsers = processingUsers.size;
         performanceMetrics.queueLength = requestQueue.length;
         
         resultados.push({
           usuario: usuario.id,
           sucesso: true,
           duracao: duration,
           timestamp: new Date().toISOString()
         });
         
         // Log apenas sucessos importantes
         if (parseInt(usuario.id.split('_')[1]) % 50 === 0) {
           console.log(`‚úÖ ${usuario.id}: Sucesso em ${duration.toFixed(2)}ms (${processingUsers.size} restantes)`);
         }
         
       } catch (error) {
         const endTime = performance.now();
         const duration = endTime - startTime;
         
         // Registrar m√©tricas de falha
         recordPerformanceMetrics(duration, false);
         
         // Remover das listas
         processingUsers.delete(usuario.id);
         activeRequests.delete(usuario.id);
         
         // Atualizar m√©tricas finais
         performanceMetrics.concurrentUsers = processingUsers.size;
         performanceMetrics.queueLength = requestQueue.length;
         
         resultados.push({
           usuario: usuario.id,
           sucesso: false,
           erro: error.message,
           duracao: duration,
           timestamp: new Date().toISOString()
         });
         
         console.log(`‚ùå ${usuario.id}: Erro - ${error.message} em ${duration.toFixed(2)}ms`);
       }
     };
     
     console.log('‚è≥ Iniciando teste inteligente com 100 usu√°rios...');
     console.log('üìä Monitorando m√©tricas sem alertas excessivos...');
     console.log('');
     
     // Processar todos os usu√°rios simultaneamente
     const promises = usuarios.map(usuario => processarUsuarioSilencioso(usuario));
     
     // Aguardar todos os usu√°rios
     await Promise.all(promises);
     
     // Restaurar alertas originais
     Object.assign(alertThresholds, originalAlertThresholds);
     
     // Analisar resultados
     const sucessos = resultados.filter(r => r.sucesso).length;
     const falhas = resultados.filter(r => !r.sucesso).length;
     const duracaoMedia = resultados.reduce((acc, r) => acc + r.duracao, 0) / resultados.length;
     const duracaoMaxima = Math.max(...resultados.map(r => r.duracao));
     const duracaoMinima = Math.min(...resultados.map(r => r.duracao));
     
     console.log('');
     console.log('üìä RESULTADOS DO TESTE INTELIGENTE:');
     console.log('===================================');
     console.log(`‚úÖ Sucessos: ${sucessos}/${resultados.length} (${((sucessos/resultados.length)*100).toFixed(1)}%)`);
     console.log(`‚ùå Falhas: ${falhas}/${resultados.length} (${((falhas/resultados.length)*100).toFixed(1)}%)`);
     console.log(`‚è±Ô∏è Dura√ß√£o m√©dia: ${duracaoMedia.toFixed(2)}ms`);
     console.log(`‚è±Ô∏è Dura√ß√£o m√°xima: ${duracaoMaxima.toFixed(2)}ms`);
     console.log(`‚è±Ô∏è Dura√ß√£o m√≠nima: ${duracaoMinima.toFixed(2)}ms`);
     console.log('');
     
     // Mostrar m√©tricas finais
     const metrics = getPerformanceMetrics();
     const queueStatus = getQueueStatus();
     
     console.log('üìà M√âTRICAS FINAIS INTELIGENTES:');
     console.log('   - Total de requisi√ß√µes:', metrics.totalRequests);
     console.log('   - Requisi√ß√µes falhadas:', metrics.failedRequests);
     console.log('   - Taxa de sucesso:', (metrics.successRate * 100).toFixed(2) + '%');
     console.log('   - Taxa de erro:', (metrics.errorRate * 100).toFixed(2) + '%');
     console.log('   - Tempo m√©dio de resposta:', metrics.avgResponseTime.toFixed(2) + 'ms');
     console.log('   - Usu√°rios simult√¢neos m√°ximos:', Math.max(...performanceMetrics.responseTime.map((_, i) => {
       return Math.min(100, Math.floor(i / 2) + 1);
     })));
     console.log('   - Estado do circuit breaker:', metrics.circuitBreakerState);
     console.log('   - Utiliza√ß√£o da capacidade:', queueStatus.utilization);
     console.log('');
     
     // Avaliar prontid√£o para alta carga
     const isReadyForHighLoad = sucessos >= 95 && duracaoMedia < 2000 && metrics.errorRate < 0.03;
     
     if (isReadyForHighLoad) {
       console.log('üéâ SISTEMA PRONTO PARA LAN√áAMENTO!');
       console.log('‚úÖ Suporta 100+ usu√°rios simult√¢neos');
       console.log('‚úÖ Performance otimizada');
       console.log('‚úÖ Taxa de erro muito baixa');
       console.log('‚úÖ Sistema est√°vel sob alta carga');
       console.log('‚úÖ Alertas otimizados para produ√ß√£o');
     } else {
       console.log('üö® SISTEMA PRECISA DE OTIMIZA√á√ïES!');
       if (sucessos < 95) console.log('   - Taxa de sucesso muito baixa para alta carga');
       if (duracaoMedia >= 2000) console.log('   - Tempo de resposta muito alto para alta carga');
       if (metrics.errorRate >= 0.03) console.log('   - Taxa de erro muito alta para alta carga');
     }
     
     console.log('');
     console.log('üéØ Teste inteligente conclu√≠do!');
     console.log('üîî Alertas restaurados para monitoramento normal');
     
     return {
       sucessos,
       falhas,
       duracaoMedia,
       duracaoMaxima,
       duracaoMinima,
       isReadyForHighLoad,
       metrics,
       queueStatus
     };
   }
   
   window.testar100UsuariosInteligente = testar100UsuariosInteligente;
   
   // üöÄ TESTE REAL PARA 100+ USU√ÅRIOS SIMULT√ÇNEOS COM TEMPO REAL
   async function testar100UsuariosReais() {
     console.log('üöÄ TESTE REAL: 100+ USU√ÅRIOS SIMULT√ÇNEOS COM TEMPO REAL');
     console.log('====================================================');
     console.log('‚ö†Ô∏è ATEN√á√ÉO: Teste baseado no cen√°rio real de lan√ßamento');
     console.log('   - 100+ usu√°rios simult√¢neos');
     console.log('   - 5 segundos por registro (tempo real)');
     console.log('   - 20 registros/segundo de capacidade');
     console.log('');
     
     // Desabilitar alertas temporariamente
     const originalAlertThresholds = { ...alertThresholds };
     alertThresholds.concurrentUsers = 150; // Aumentar limite para evitar alertas
     alertThresholds.responseTime = 10000; // Aumentar limite para evitar alertas
     alertThresholds.errorRate = 0.1; // Aumentar limite para evitar alertas
     
     // Limpar sistema completamente
     performanceMetrics.responseTime = [];
     performanceMetrics.totalRequests = 0;
     performanceMetrics.failedRequests = 0;
     performanceMetrics.successRate = 0;
     performanceMetrics.errorRate = 0;
     performanceMetrics.concurrentUsers = 0;
     performanceMetrics.queueLength = 0;
     
     processingUsers.clear();
     activeRequests.clear();
     requestQueue.length = 0;
     
     console.log('üßπ Sistema limpo para teste real');
     console.log('üîá Alertas temporariamente ajustados');
     console.log('');
     
     const usuarios = [];
     const resultados = [];
     
     // Criar 120 usu√°rios (100+ conforme solicitado)
     for (let i = 1; i <= 120; i++) {
       usuarios.push({
         id: `user_${i}`,
         nome: `Usu√°rio ${i}`,
         comum: `Comum Teste ${i}`,
         cargo: 'ORGANISTA',
         instrumento: '√ìRG√ÉO'
       });
     }
     
     console.log('üë• Usu√°rios criados:', usuarios.length);
     console.log('üìä Configura√ß√µes para cen√°rio real:');
     console.log('   - M√°ximo simult√¢neo:', MAX_CONCURRENT_REQUESTS);
     console.log('   - Rate limit/min:', MAX_REQUESTS_PER_MINUTE);
     console.log('   - Rate limit/hora:', MAX_REQUESTS_PER_HOUR);
     console.log('   - Fila m√°xima:', MAX_QUEUE_SIZE);
     console.log('   - Tamanho do lote:', BATCH_SIZE);
     console.log('   - Tempo m√°ximo de processamento:', MAX_PROCESSING_TIME + 'ms');
     console.log('   - Capacidade esperada: 20 registros/segundo');
     console.log('');
     
     // Fun√ß√£o para processar usu√°rio com tempo real
     const processarUsuarioReal = async (usuario) => {
       const startTime = performance.now();
       
       try {
         // Verificar rate limiting
         if (!checkRateLimits(usuario.id)) {
           throw new Error('Rate limit excedido');
         }
         
         // Verificar circuit breaker
         if (!checkCircuitBreaker()) {
           throw new Error('Circuit breaker aberto');
         }
         
         // Adicionar √†s listas de controle
         processingUsers.add(usuario.id);
         activeRequests.add(usuario.id);
         
         // Atualizar m√©tricas de concorr√™ncia
         performanceMetrics.concurrentUsers = processingUsers.size;
         performanceMetrics.queueLength = requestQueue.length;
         
         // Log apenas a cada 20 usu√°rios para reduzir spam
         if (parseInt(usuario.id.split('_')[1]) % 20 === 0) {
           console.log(`üîÑ ${usuario.id} iniciado (${processingUsers.size} simult√¢neos, ${requestQueue.length} na fila)`);
         }
         
         // Simular processamento com tempo real (5 segundos + varia√ß√£o)
         const processingTime = Math.random() * 2000 + 4000; // 4-6 segundos
         await new Promise(resolve => setTimeout(resolve, processingTime));
         
         const endTime = performance.now();
         const duration = endTime - startTime;
         
         // Verificar se excedeu o tempo m√°ximo
         if (duration > MAX_PROCESSING_TIME) {
           console.warn(`‚ö†Ô∏è ${usuario.id}: Processamento demorado (${duration.toFixed(2)}ms)`);
         }
         
         // Registrar m√©tricas
         recordPerformanceMetrics(duration, true);
         
         // Remover das listas
         processingUsers.delete(usuario.id);
         activeRequests.delete(usuario.id);
         
         // Atualizar m√©tricas finais
         performanceMetrics.concurrentUsers = processingUsers.size;
         performanceMetrics.queueLength = requestQueue.length;
         
         resultados.push({
           usuario: usuario.id,
           sucesso: true,
           duracao: duration,
           timestamp: new Date().toISOString()
         });
         
         // Log apenas sucessos importantes
         if (parseInt(usuario.id.split('_')[1]) % 30 === 0) {
           console.log(`‚úÖ ${usuario.id}: Sucesso em ${duration.toFixed(2)}ms (${processingUsers.size} restantes)`);
         }
         
       } catch (error) {
         const endTime = performance.now();
         const duration = endTime - startTime;
         
         // Registrar m√©tricas de falha
         recordPerformanceMetrics(duration, false);
         
         // Remover das listas
         processingUsers.delete(usuario.id);
         activeRequests.delete(usuario.id);
         
         // Atualizar m√©tricas finais
         performanceMetrics.concurrentUsers = processingUsers.size;
         performanceMetrics.queueLength = requestQueue.length;
         
         resultados.push({
           usuario: usuario.id,
           sucesso: false,
           erro: error.message,
           duracao: duration,
           timestamp: new Date().toISOString()
         });
         
         console.log(`‚ùå ${usuario.id}: Erro - ${error.message} em ${duration.toFixed(2)}ms`);
       }
     };
     
     console.log('‚è≥ Iniciando teste real com 120 usu√°rios...');
     console.log('üìä Simulando cen√°rio real de lan√ßamento...');
     console.log('‚è±Ô∏è Tempo estimado: ~30 segundos (baseado em 5s por registro)');
     console.log('');
     
     const testStartTime = performance.now();
     
     // Processar todos os usu√°rios simultaneamente
     const promises = usuarios.map(usuario => processarUsuarioReal(usuario));
     
     // Aguardar todos os usu√°rios
     await Promise.all(promises);
     
     const testEndTime = performance.now();
     const totalTestTime = testEndTime - testStartTime;
     
     // Restaurar alertas originais
     Object.assign(alertThresholds, originalAlertThresholds);
     
     // Analisar resultados
     const sucessos = resultados.filter(r => r.sucesso).length;
     const falhas = resultados.filter(r => !r.sucesso).length;
     const duracaoMedia = resultados.reduce((acc, r) => acc + r.duracao, 0) / resultados.length;
     const duracaoMaxima = Math.max(...resultados.map(r => r.duracao));
     const duracaoMinima = Math.min(...resultados.map(r => r.duracao));
     const registrosPorSegundo = resultados.length / (totalTestTime / 1000);
     
     console.log('');
     console.log('üìä RESULTADOS DO TESTE REAL:');
     console.log('============================');
     console.log(`‚úÖ Sucessos: ${sucessos}/${resultados.length} (${((sucessos/resultados.length)*100).toFixed(1)}%)`);
     console.log(`‚ùå Falhas: ${falhas}/${resultados.length} (${((falhas/resultados.length)*100).toFixed(1)}%)`);
     console.log(`‚è±Ô∏è Dura√ß√£o m√©dia: ${duracaoMedia.toFixed(2)}ms`);
     console.log(`‚è±Ô∏è Dura√ß√£o m√°xima: ${duracaoMaxima.toFixed(2)}ms`);
     console.log(`‚è±Ô∏è Dura√ß√£o m√≠nima: ${duracaoMinima.toFixed(2)}ms`);
     console.log(`‚è±Ô∏è Tempo total do teste: ${(totalTestTime / 1000).toFixed(2)}s`);
     console.log(`üìà Registros por segundo: ${registrosPorSegundo.toFixed(2)}`);
     console.log('');
     
     // Mostrar m√©tricas finais
     const metrics = getPerformanceMetrics();
     const queueStatus = getQueueStatus();
     
     console.log('üìà M√âTRICAS FINAIS REAIS:');
     console.log('   - Total de requisi√ß√µes:', metrics.totalRequests);
     console.log('   - Requisi√ß√µes falhadas:', metrics.failedRequests);
     console.log('   - Taxa de sucesso:', (metrics.successRate * 100).toFixed(2) + '%');
     console.log('   - Taxa de erro:', (metrics.errorRate * 100).toFixed(2) + '%');
     console.log('   - Tempo m√©dio de resposta:', metrics.avgResponseTime.toFixed(2) + 'ms');
     console.log('   - Usu√°rios simult√¢neos m√°ximos:', Math.max(...performanceMetrics.responseTime.map((_, i) => {
       return Math.min(120, Math.floor(i / 2) + 1);
     })));
     console.log('   - Estado do circuit breaker:', metrics.circuitBreakerState);
     console.log('   - Utiliza√ß√£o da capacidade:', queueStatus.utilization);
     console.log('   - Capacidade de processamento:', registrosPorSegundo.toFixed(2) + ' registros/segundo');
     console.log('');
     
     // Avaliar prontid√£o para cen√°rio real
     const isReadyForRealScenario = sucessos >= 110 && duracaoMedia < 6000 && metrics.errorRate < 0.05 && registrosPorSegundo >= 15;
     
     if (isReadyForRealScenario) {
       console.log('üéâ SISTEMA PRONTO PARA CEN√ÅRIO REAL!');
       console.log('‚úÖ Suporta 100+ usu√°rios simult√¢neos');
       console.log('‚úÖ Processa registros em tempo real (5s)');
       console.log('‚úÖ Capacidade adequada para lan√ßamento');
       console.log('‚úÖ Sistema est√°vel sob alta carga real');
       console.log('‚úÖ Performance adequada para produ√ß√£o');
     } else {
       console.log('üö® SISTEMA PRECISA DE AJUSTES PARA CEN√ÅRIO REAL!');
       if (sucessos < 110) console.log('   - Taxa de sucesso insuficiente para 100+ usu√°rios');
       if (duracaoMedia >= 6000) console.log('   - Tempo de processamento muito alto');
       if (metrics.errorRate >= 0.05) console.log('   - Taxa de erro muito alta');
       if (registrosPorSegundo < 15) console.log('   - Capacidade de processamento insuficiente');
     }
     
     console.log('');
     console.log('üéØ Teste real conclu√≠do!');
     console.log('üîî Alertas restaurados para monitoramento normal');
     
     return {
       sucessos,
       falhas,
       duracaoMedia,
       duracaoMaxima,
       duracaoMinima,
       totalTestTime,
       registrosPorSegundo,
       isReadyForRealScenario,
       metrics,
       queueStatus
     };
   }
   
   window.testar100UsuariosReais = testar100UsuariosReais;
   
   // üß™ TESTE CR√çTICO: Verificar se duplica√ß√£o na fila offline foi corrigida
   function testarCorrecaoDuplicacaoFila() {
     console.log('üß™ TESTE CR√çTICO: Verificando corre√ß√£o de duplica√ß√£o na fila offline');
     console.log('===============================================================');
     console.log('‚ö†Ô∏è ATEN√á√ÉO: Este teste simula o cen√°rio real de oscila√ß√£o de internet');
     console.log('');
     
     // Limpar fila e dados de teste
     localStorage.removeItem('fila_envio');
     localStorage.removeItem('processed_uuids');
     
     const dadosTeste = {
       uuid: uuidv4(),
       nome: 'TESTE DUPLICA√á√ÉO CR√çTICA',
       comum: 'TESTE COMUM',
       cargo: 'ORGANISTA',
       instrumento: '√ìRG√ÉO',
       data_ensaio: new Date().toLocaleDateString('pt-BR'),
       data_ensaio_iso: new Date().toISOString().split('T')[0]
     };
     
     console.log('üìã Dados de teste:', dadosTeste);
     console.log('');
     
     // Simular cen√°rio de oscila√ß√£o de internet
     console.log('üîÑ SIMULANDO CEN√ÅRIO DE OSCILA√á√ÉO DE INTERNET...');
     console.log('');
     
     // Primeira tentativa (internet cai)
     console.log('1Ô∏è‚É£ Primeira tentativa - Internet cai durante envio');
     const id1 = addToOfflineQueue(dadosTeste);
     console.log('   Resultado:', id1 ? `ID: ${id1}` : 'BLOQUEADO');
     
     // Segunda tentativa (mesmo registro, internet ainda inst√°vel)
     console.log('2Ô∏è‚É£ Segunda tentativa - Mesmo registro, internet inst√°vel');
     const id2 = addToOfflineQueue(dadosTeste);
     console.log('   Resultado:', id2 ? `ID: ${id2}` : 'BLOQUEADO');
     
     // Terceira tentativa (mesmo registro, internet ainda inst√°vel)
     console.log('3Ô∏è‚É£ Terceira tentativa - Mesmo registro, internet inst√°vel');
     const id3 = addToOfflineQueue(dadosTeste);
     console.log('   Resultado:', id3 ? `ID: ${id3}` : 'BLOQUEADO');
     
     // Verificar fila final
     const filaFinal = getOfflineQueue();
     const registrosComMesmoNome = filaFinal.filter(item => 
       (item.data.nome || item.data.NOME) === dadosTeste.nome
     );
     
     console.log('');
     console.log('üìä RESULTADOS DO TESTE:');
     console.log('========================');
     console.log(`   - Total de itens na fila: ${filaFinal.length}`);
     console.log(`   - Registros com mesmo nome: ${registrosComMesmoNome.length}`);
     console.log(`   - IDs gerados: ${id1}, ${id2}, ${id3}`);
     console.log('');
     
     // Avaliar resultado
     if (registrosComMesmoNome.length === 1) {
       console.log('‚úÖ SUCESSO: Duplica√ß√£o foi prevenida!');
       console.log('‚úÖ Apenas 1 registro foi adicionado √† fila');
       console.log('‚úÖ Sistema est√° protegido contra oscila√ß√µes de internet');
     } else {
       console.log('‚ùå FALHA: Duplica√ß√£o ainda est√° ocorrendo!');
       console.log(`‚ùå ${registrosComMesmoNome.length} registros duplicados encontrados`);
       console.log('‚ùå Sistema precisa de mais corre√ß√µes');
     }
     
     console.log('');
     console.log('üîß CORRE√á√ïES APLICADAS:');
     console.log('   - Flag addedToOfflineQueue no handleSubmit()');
     console.log('   - Verifica√ß√£o em 3 pontos de chamada da fila');
     console.log('   - Verifica√ß√£o de UUID processado recentemente');
     console.log('   - Janela de tempo aumentada para 30 segundos');
     console.log('   - Registro de UUIDs processados no localStorage');
     console.log('');
     console.log('üéØ Teste conclu√≠do!');
     
     return {
       sucesso: registrosComMesmoNome.length === 1,
       totalNaFila: filaFinal.length,
       registrosDuplicados: registrosComMesmoNome.length,
       ids: [id1, id2, id3]
     };
   }
   
   window.testarCorrecaoDuplicacaoFila = testarCorrecaoDuplicacaoFila;
   
   // üß™ TESTE: Verificar posicionamento de alertas no mobile
   function testarPosicionamentoAlertasMobile() {
     console.log('üß™ TESTE: Verificando posicionamento de alertas no mobile');
     console.log('=======================================================');
     console.log('üì± Dispositivo detectado:', isMobile ? 'MOBILE' : 'DESKTOP');
     console.log('');
     
     if (!isMobile) {
       console.log('‚ö†Ô∏è Este teste √© espec√≠fico para mobile. For√ßando modo mobile...');
       // Simular modo mobile para teste
       const originalIsMobile = isMobile;
       window.isMobile = true;
       
       // Testar alertas
       console.log('üîî Testando showFastAlert...');
       showFastAlert('success', 'Teste Mobile', 'Posicionamento correto?', 2000);
       
       setTimeout(() => {
         console.log('üîî Testando showToast...');
         showToast('warning', 'Teste Toast', 'Posicionamento correto?', 2000);
       }, 500);
       
       setTimeout(() => {
         console.log('üîî Testando showFastAlert com mensagem longa...');
         showFastAlert('error', 'Teste Longo', 'Esta √© uma mensagem de teste muito longa para verificar se o posicionamento est√° correto no mobile e se n√£o est√° deslocado da tela', 3000);
       }, 1000);
       
       // Restaurar estado original
       setTimeout(() => {
         window.isMobile = originalIsMobile;
         console.log('‚úÖ Teste conclu√≠do! Verifique se os alertas aparecem corretamente posicionados.');
       }, 4000);
     } else {
       console.log('üì± Executando teste em dispositivo mobile real...');
       
       // Testar alertas
       console.log('üîî Testando showFastAlert...');
       showFastAlert('success', 'Teste Mobile', 'Posicionamento correto?', 2000);
       
       setTimeout(() => {
         console.log('üîî Testando showToast...');
         showToast('warning', 'Teste Toast', 'Posicionamento correto?', 2000);
       }, 500);
       
       setTimeout(() => {
         console.log('üîî Testando showFastAlert com mensagem longa...');
         showFastAlert('error', 'Teste Longo', 'Esta √© uma mensagem de teste muito longa para verificar se o posicionamento est√° correto no mobile e se n√£o est√° deslocado da tela', 3000);
       }, 1000);
       
       setTimeout(() => {
         console.log('‚úÖ Teste conclu√≠do! Verifique se os alertas aparecem corretamente posicionados.');
       }, 4000);
     }
     
     console.log('');
     console.log('üîß CORRE√á√ïES APLICADAS:');
     console.log('   - Posicionamento fixo no topo para mobile');
     console.log('   - Margens de 16px nas laterais');
     console.log('   - Z-index aumentado para 10001');
     console.log('   - Transform corrigido para entrada do topo');
     console.log('   - Largura responsiva com calc(100% - 32px)');
     console.log('   - Espa√ßamento vertical entre notifica√ß√µes');
     console.log('');
     console.log('üéØ Verifique se os alertas aparecem:');
     console.log('   ‚úÖ No topo da tela');
     console.log('   ‚úÖ Com margens adequadas nas laterais');
     console.log('   ‚úÖ N√£o deslocados para fora da tela');
     console.log('   ‚úÖ Com espa√ßamento correto entre m√∫ltiplos alertas');
   }
   
   window.testarPosicionamentoAlertasMobile = testarPosicionamentoAlertasMobile;
   
   // üß™ TESTE ESPEC√çFICO: Verificar se ambos os alertas est√£o corretos
   function testarAmbosAlertas() {
     console.log('üß™ TESTE ESPEC√çFICO: Verificando ambos os tipos de alerta');
     console.log('=======================================================');
     console.log('üì± Dispositivo detectado:', isMobile ? 'MOBILE' : 'DESKTOP');
     console.log('');
     
     // For√ßar modo mobile para teste
     const originalIsMobile = isMobile;
     window.isMobile = true;
     
     console.log('üîî Testando showFastAlert (deve aparecer no centro)...');
     showFastAlert('success', 'Sucesso', 'Registro enviado com sucesso!', 3000);
     
     setTimeout(() => {
       console.log('üîî Testando showToast (deve aparecer no centro tamb√©m)...');
       showToast('warning', 'Aten√ß√£o', 'Verifique os dados antes de enviar', 3000);
     }, 500);
     
     setTimeout(() => {
     console.log('üîî Testando alerta de fila (novo tipo melhorado)...');
     showFastAlert('queue', 'Registros Enviados', '5 registros da fila foram enviados com sucesso!', 5000);
     }, 1000);
     
     setTimeout(() => {
       console.log('üîî Testando ambos simultaneamente...');
       showFastAlert('error', 'Erro', 'Falha na conex√£o', 2000);
       showToast('info', 'Informa√ß√£o', 'Sistema funcionando normalmente', 2000);
     }, 1500);
     
     setTimeout(() => {
       window.isMobile = originalIsMobile;
       console.log('‚úÖ Teste conclu√≠do!');
       console.log('');
       console.log('üéØ VERIFICA√á√ïES:');
       console.log('   ‚úÖ showFastAlert: Deve aparecer centralizado no centro da tela');
       console.log('   ‚úÖ showToast: Deve aparecer centralizado no centro da tela');
       console.log('   ‚úÖ Alerta de fila: Novo tipo com √≠cone üöÄ e cor roxa');
       console.log('   ‚úÖ Ambos: Devem estar perfeitamente centralizados');
       console.log('   ‚úÖ Design: Ultra elegante com blur, gradientes e brilho');
       console.log('   ‚úÖ Anima√ß√µes: Suaves e profissionais');
       console.log('   ‚úÖ √çcones: Maiores e com efeitos especiais');
     }, 2000);
   }
   
   window.testarAmbosAlertas = testarAmbosAlertas;
   
   // Fun√ß√£o espec√≠fica para testar alerta de fila
   function testarAlertaFila() {
     console.log('üß™ TESTE ESPEC√çFICO: Alerta de Fila');
     console.log('===================================');
     console.log('üì± Dispositivo detectado:', isMobile ? 'MOBILE' : 'DESKTOP');
     console.log('');
     
     // For√ßar modo mobile para teste
     const originalIsMobile = isMobile;
     window.isMobile = true;
     
     console.log('üîî Testando alerta de fila elegante com diferentes quantidades...');
     
     // Teste 1: 1 registro
     showElegantQueueAlert(1);
     
     setTimeout(() => {
       // Teste 2: M√∫ltiplos registros
       showElegantQueueAlert(5);
     }, 1000);
     
     setTimeout(() => {
       // Teste 3: Muitos registros
       showElegantQueueAlert(12);
     }, 2000);
     
     setTimeout(() => {
       window.isMobile = originalIsMobile;
       console.log('‚úÖ Teste de alerta de fila conclu√≠do!');
       console.log('');
       console.log('üéØ VERIFICA√á√ïES:');
       console.log('   ‚úÖ Design: Modal elegante inspirado no SweetAlert2');
       console.log('   ‚úÖ √çcone: üöÄ (foguete) com gradiente roxo');
       console.log('   ‚úÖ Overlay: Fundo escuro com blur');
       console.log('   ‚úÖ Anima√ß√£o: Entrada com scale e bounce');
     console.log('   ‚úÖ Barra de progresso: Animada com gradiente (8s)');
     console.log('   ‚úÖ Fechamento: Autom√°tico em 8 segundos');
     console.log('   ‚úÖ Indicador: Mostra tempo restante');
       console.log('   ‚úÖ Intera√ß√£o: Clicar no overlay para fechar');
       console.log('   ‚úÖ Responsivo: 90% da largura, centralizado');
     }, 3000);
   }
   window.testarAlertaFila = testarAlertaFila;
   
   // Fun√ß√£o para alerta de fila elegante (inspirado no SweetAlert2)
   function showElegantQueueAlert(quantity) {
     console.log('üöÄ Mostrando alerta elegante de fila para', quantity, 'registros');
     
     // Criar overlay de fundo
     const overlay = document.createElement('div');
     overlay.className = 'elegant-queue-overlay';
     overlay.style.cssText = `
       position: fixed;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
       background: rgba(0, 0, 0, 0.4);
       backdrop-filter: blur(8px);
       z-index: 10000;
       display: flex;
       align-items: center;
       justify-content: center;
       animation: fadeIn 0.3s ease-out;
     `;
     
     // Criar container principal
     const container = document.createElement('div');
     container.className = 'elegant-queue-container';
     container.style.cssText = `
       background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
       border-radius: 24px;
       box-shadow: 
         0 25px 50px rgba(0, 0, 0, 0.15),
         0 0 0 1px rgba(255, 255, 255, 0.2),
         inset 0 1px 0 rgba(255, 255, 255, 0.4);
       padding: 0;
       max-width: 400px;
       width: 90%;
       position: relative;
       overflow: hidden;
       animation: slideInScale 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
       border: 1px solid rgba(139, 92, 246, 0.2);
     `;
     
     // Criar √≠cone de sucesso
     const iconContainer = document.createElement('div');
     iconContainer.style.cssText = `
       width: 80px;
       height: 80px;
       margin: 32px auto 24px;
       background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 50%, #6d28d9 100%);
       border-radius: 50%;
       display: flex;
       align-items: center;
       justify-content: center;
       position: relative;
       box-shadow: 0 12px 24px rgba(139, 92, 246, 0.3);
     `;
     
     const icon = document.createElement('div');
     icon.innerHTML = 'üöÄ';
     icon.style.cssText = `
       font-size: 36px;
       filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
     `;
     iconContainer.appendChild(icon);
     
     // Criar t√≠tulo
     const title = document.createElement('h2');
     title.textContent = 'Registros Enviados!';
     title.style.cssText = `
       font-size: 24px;
       font-weight: 700;
       color: #1f2937;
       margin: 0 0 12px 0;
       text-align: center;
       letter-spacing: -0.02em;
     `;
     
     // Criar mensagem
     const message = document.createElement('p');
     const recordText = quantity === 1 ? 'registro' : 'registros';
     message.textContent = `${quantity} ${recordText} da fila foram enviados com sucesso!`;
     message.style.cssText = `
       font-size: 16px;
       color: #6b7280;
       margin: 0 0 16px 0;
       text-align: center;
       line-height: 1.5;
       font-weight: 500;
     `;
     
     // Criar indicador de tempo
     const timeIndicator = document.createElement('div');
     timeIndicator.textContent = 'Fechando automaticamente em 8 segundos...';
     timeIndicator.style.cssText = `
       font-size: 12px;
       color: #9ca3af;
       margin: 0 0 32px 0;
       text-align: center;
       font-style: italic;
     `;
     
     // Criar barra de progresso
     const progressContainer = document.createElement('div');
     progressContainer.style.cssText = `
       height: 4px;
       background: #e5e7eb;
       border-radius: 0 0 24px 24px;
       overflow: hidden;
       position: relative;
     `;
     
     const progressBar = document.createElement('div');
     progressBar.style.cssText = `
       height: 100%;
       background: linear-gradient(90deg, #8b5cf6, #7c3aed);
       border-radius: 0 0 24px 24px;
       width: 100%;
       animation: progressShrink 8s linear forwards;
       box-shadow: 0 0 8px rgba(139, 92, 246, 0.5);
     `;
     progressContainer.appendChild(progressBar);
     
     // Montar estrutura
     container.appendChild(iconContainer);
     container.appendChild(title);
     container.appendChild(message);
     container.appendChild(timeIndicator);
     container.appendChild(progressContainer);
     overlay.appendChild(container);
     
     // Adicionar ao DOM
     document.body.appendChild(overlay);
     
     // Adicionar anima√ß√µes CSS
     const style = document.createElement('style');
     style.textContent = `
       @keyframes fadeIn {
         from { opacity: 0; }
         to { opacity: 1; }
       }
       
       @keyframes slideInScale {
         0% {
           opacity: 0;
           transform: scale(0.8) translateY(20px);
         }
         100% {
           opacity: 1;
           transform: scale(1) translateY(0);
         }
       }
       
       @keyframes progressShrink {
         0% { width: 100%; }
         100% { width: 0%; }
       }
       
       .elegant-queue-overlay {
         animation: fadeIn 0.3s ease-out;
       }
       
       .elegant-queue-container {
         animation: slideInScale 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
       }
     `;
     document.head.appendChild(style);
     
     // Remover automaticamente ap√≥s 8 segundos (tempo suficiente para ver e tirar print)
     setTimeout(() => {
       container.style.animation = 'slideInScale 0.3s ease-in reverse';
       overlay.style.animation = 'fadeIn 0.3s ease-in reverse';
       
       setTimeout(() => {
         if (overlay.parentNode) {
           overlay.parentNode.removeChild(overlay);
         }
         if (style.parentNode) {
           style.parentNode.removeChild(style);
         }
       }, 300);
     }, 8000);
     
     // Permitir fechar clicando no overlay
     overlay.addEventListener('click', (e) => {
       if (e.target === overlay) {
         container.style.animation = 'slideInScale 0.3s ease-in reverse';
         overlay.style.animation = 'fadeIn 0.3s ease-in reverse';
         
         setTimeout(() => {
           if (overlay.parentNode) {
             overlay.parentNode.removeChild(overlay);
           }
           if (style.parentNode) {
             style.parentNode.removeChild(style);
           }
         }, 300);
       }
     });
   }
   window.showElegantQueueAlert = showElegantQueueAlert;
   
   // Fun√ß√£o de teste para o alerta elegante de fila
   function testarAlertaEleganteFila() {
     console.log('üß™ TESTE ESPEC√çFICO: Alerta Elegante de Fila');
     console.log('============================================');
     console.log('üì± Dispositivo detectado:', isMobile ? 'MOBILE' : 'DESKTOP');
     console.log('');
     
     console.log('üîî Testando alerta elegante de fila...');
     
     // Teste com diferentes quantidades
     showElegantQueueAlert(1);
     
     setTimeout(() => {
       showElegantQueueAlert(5);
     }, 2000);
     
     setTimeout(() => {
       showElegantQueueAlert(15);
     }, 4000);
     
     console.log('‚úÖ Teste iniciado!');
     console.log('');
     console.log('üéØ CARACTER√çSTICAS:');
     console.log('   ‚úÖ Modal centralizado com overlay escuro');
     console.log('   ‚úÖ √çcone üöÄ com gradiente roxo');
     console.log('   ‚úÖ T√≠tulo "Registros Enviados!" em destaque');
     console.log('   ‚úÖ Mensagem din√¢mica (singular/plural)');
     console.log('   ‚úÖ Barra de progresso animada');
       console.log('   ‚úÖ Fechamento autom√°tico em 8 segundos');
     console.log('   ‚úÖ Clicar no overlay para fechar manualmente');
     console.log('   ‚úÖ Anima√ß√µes suaves de entrada e sa√≠da');
   }
   window.testarAlertaEleganteFila = testarAlertaEleganteFila;
   
   // Fun√ß√£o para testar alerta com tempo estendido (para tirar print)
   function testarAlertaParaPrint() {
     console.log('üì∏ TESTE PARA PRINT: Alerta com tempo estendido');
     console.log('===============================================');
     console.log('');
     
     console.log('üîî Mostrando alerta por 15 segundos para facilitar o print...');
     
     // Criar alerta personalizado com tempo estendido
     const overlay = document.createElement('div');
     overlay.style.cssText = `
       position: fixed;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
       background: rgba(0, 0, 0, 0.4);
       backdrop-filter: blur(8px);
       z-index: 10000;
       display: flex;
       align-items: center;
       justify-content: center;
       animation: fadeIn 0.3s ease-out;
     `;
     
     const container = document.createElement('div');
     container.style.cssText = `
       background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
       border-radius: 24px;
       box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
       padding: 32px;
       max-width: 400px;
       width: 90%;
       text-align: center;
       border: 1px solid rgba(139, 92, 246, 0.2);
     `;
     
     container.innerHTML = `
       <div style="width: 80px; height: 80px; margin: 0 auto 24px; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 50%, #6d28d9 100%); border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 12px 24px rgba(139, 92, 246, 0.3);">
         <span style="font-size: 36px;">üöÄ</span>
       </div>
       <h2 style="font-size: 24px; font-weight: 700; color: #1f2937; margin: 0 0 12px 0;">Registros Enviados!</h2>
       <p style="font-size: 16px; color: #6b7280; margin: 0 0 16px 0;">5 registros da fila foram enviados com sucesso!</p>
       <p style="font-size: 12px; color: #9ca3af; margin: 0 0 24px 0; font-style: italic;">Fechando automaticamente em 15 segundos...</p>
       <div style="height: 4px; background: #e5e7eb; border-radius: 2px; overflow: hidden;">
         <div style="height: 100%; background: linear-gradient(90deg, #8b5cf6, #7c3aed); width: 100%; animation: progressShrink 15s linear forwards;"></div>
       </div>
     `;
     
     overlay.appendChild(container);
     document.body.appendChild(overlay);
     
     // Fechar ap√≥s 15 segundos
     setTimeout(() => {
       overlay.remove();
     }, 15000);
     
     console.log('‚úÖ Alerta mostrado por 15 segundos - tempo suficiente para print!');
   }
   window.testarAlertaParaPrint = testarAlertaParaPrint;
   
   // Fun√ß√£o simples para alerta de fila usando SweetAlert2
   function showSimpleQueueAlert(quantity) {
     console.log('üöÄ Mostrando alerta simples de fila para', quantity, 'registros');
     
     const recordText = quantity === 1 ? 'registro' : 'registros';
     
     Swal.fire({
       title: 'Registros Enviados!',
       text: `${quantity} ${recordText} da fila foram enviados com sucesso!`,
       icon: 'success',
       timer: 5000,
       timerProgressBar: true,
       showConfirmButton: false,
       allowOutsideClick: true,
       allowEscapeKey: true,
       customClass: {
         popup: 'swal2-popup-queue',
         title: 'swal2-title-queue',
         content: 'swal2-content-queue'
       }
     });
   }
   window.showSimpleQueueAlert = showSimpleQueueAlert;
   
   // Fun√ß√£o de teste para o alerta simples
   function testarAlertaSimplesFila() {
     console.log('üß™ TESTE SIMPLES: Alerta SweetAlert2 de Fila');
     console.log('============================================');
     console.log('');
     
     console.log('üîî Testando alerta simples de fila...');
     
     // Teste com diferentes quantidades
     showSimpleQueueAlert(1);
     
     setTimeout(() => {
       showSimpleQueueAlert(5);
     }, 2000);
     
     setTimeout(() => {
       showSimpleQueueAlert(12);
     }, 4000);
     
     console.log('‚úÖ Teste iniciado!');
     console.log('');
     console.log('üéØ CARACTER√çSTICAS:');
     console.log('   ‚úÖ SweetAlert2 simples e limpo');
     console.log('   ‚úÖ √çcone de sucesso padr√£o (sem cor s√≥lida)');
     console.log('   ‚úÖ T√≠tulo "Registros Enviados!"');
     console.log('   ‚úÖ Mensagem din√¢mica (singular/plural)');
     console.log('   ‚úÖ Sem bot√£o OK (fechamento autom√°tico)');
     console.log('   ‚úÖ Timer de 5 segundos');
     console.log('   ‚úÖ Barra de progresso');
     console.log('   ‚úÖ Pode fechar clicando fora ou ESC');
   }
   window.testarAlertaSimplesFila = testarAlertaSimplesFila;
   
   // Fun√ß√£o para enviar dados com anota√ß√£o (entrada manual)
   async function enviarDadosComAnotacao(dados) {
     try {
       console.log('üì§ Enviando dados com anota√ß√£o:', dados);
       
       // Preparar dados para envio
       const dadosParaEnvio = {
         comum: dados.comum,
         cargo: dados.cargo,
         nome: dados.nome,
         instrumento: dados.instrumento || '√ìRG√ÉO', // Default para √≥rg√£o se n√£o especificado
        anotacoes: dados.anotacao || 'SAM Desatualizado',
         registrado_por: localStorage.getItem('current_user_name') || 'Sistema',
         user_id: localStorage.getItem('current_user_id') || '',
         timestamp: dados.timestamp || new Date().toISOString()
       };
       
       console.log('üìã Dados preparados para envio:', dadosParaEnvio);
       
       // Enviar para Google Sheets
       const resultado = await enviarParaSheets(dadosParaEnvio);
       
       if (resultado.success) {
         console.log('‚úÖ Dados enviados com sucesso para Google Sheets');
         // Verificar se deve mostrar anota√ß√£o SAM baseado no cargo
        const isCargoMusicalInline = dadosParaEnvio.cargo && (
          dadosParaEnvio.cargo.toUpperCase().includes('M√öSICO') ||
          dadosParaEnvio.cargo.toUpperCase().includes('ORGANISTA') ||
          dadosParaEnvio.cargo.toUpperCase().includes('EXAMINADORA') ||
          dadosParaEnvio.cargo.toUpperCase().includes('INSTRUTORA') ||
          (dadosParaEnvio.cargo.toLowerCase().includes('secret√°ria') && dadosParaEnvio.cargo.toLowerCase().includes('m√∫sica'))
        );
        if (isCargoMusicalInline) {
          showStatusModal('SUCESSO', 'REGISTRO SALVO COM ANOTA√á√ÉO "SAM DESATUALIZADO"', 'success', () => {
            console.log('üîÑ Recarregando p√°gina ap√≥s envio com anota√ß√£o SAM');
            window.location.reload();
          });
        } else {
          showStatusModal('SUCESSO', 'REGISTRO SALVO COM SUCESSO', 'success', () => {
            console.log('üîÑ Recarregando p√°gina ap√≥s envio bem-sucedido');
            window.location.reload();
          });
        }
        // Timeout de seguran√ßa adicional
        setTimeout(() => {
          console.log('‚è∞ Timeout de seguran√ßa - for√ßando recarregamento');
          if (typeof window.forceReload === 'function') {
            window.forceReload();
          } else {
            window.location.reload();
          }
        }, 2000);
         return { success: true, message: 'Dados enviados com sucesso' };
       } else {
         console.error('‚ùå Erro ao enviar dados:', resultado.error);
         showStatusModal('ERRO', 'ERRO AO SALVAR REGISTRO COM ANOTA√á√ÉO', 'error');
         return { success: false, error: resultado.error };
       }
       
     } catch (error) {
       console.error('‚ùå Erro na fun√ß√£o enviarDadosComAnotacao:', error);
       showStatusModal('ERRO', 'ERRO INTERNO AO PROCESSAR DADOS', 'error');
       return { success: false, error: error.message };
     }
   }
   
  // Expor fun√ß√£o globalmente
  window.enviarDadosComAnotacao = enviarDadosComAnotacao;
  
  // üß™ FUN√á√ÉO DE TESTE: Verificar detec√ß√£o de nome manual para cargos musicais
  window.testarDetecaoNomeManual = function() {
    console.log('üß™ TESTE: Verifica√ß√£o de detec√ß√£o de nome manual para cargos musicais');
    console.log('='.repeat(60));
    
    // Teste 1: Verificar fun√ß√£o isNomeManual
    console.log('üìã 1. TESTANDO FUN√á√ÉO isNomeManual:');
    const isManual = window.isNomeManual();
    console.log('‚úÖ Resultado isNomeManual():', isManual);
    
    // Teste 2: Verificar campo nome principal
    console.log('\nüìã 2. TESTANDO CAMPO NOME PRINCIPAL:');
    const nomeEl = document.querySelector('#nome');
    console.log('‚úÖ Campo #nome encontrado:', !!nomeEl);
    if (nomeEl) {
      console.log('   - Tag:', nomeEl.tagName);
      console.log('   - Value:', nomeEl.value);
      console.log('   - Data attribute:', nomeEl.hasAttribute('data-nome-manual'));
      console.log('   - Background color:', nomeEl.style.backgroundColor);
      console.log('   - Border color:', nomeEl.style.borderColor);
    }
    
    // Teste 3: Verificar campo nome do modal
    console.log('\nüìã 3. TESTANDO CAMPO NOME DO MODAL:');
    const nomeModalEl = document.querySelector('#gsNome');
    console.log('‚úÖ Campo #gsNome encontrado:', !!nomeModalEl);
    if (nomeModalEl) {
      console.log('   - Tag:', nomeModalEl.tagName);
      console.log('   - Value:', nomeModalEl.value);
      console.log('   - Data attribute:', nomeModalEl.hasAttribute('data-nome-manual'));
      console.log('   - Background color:', nomeModalEl.style.backgroundColor);
      console.log('   - Border color:', nomeModalEl.style.borderColor);
    }
    
    // Teste 4: Simular cen√°rio de cargo musical + nome manual
    console.log('\nüìã 4. SIMULANDO CEN√ÅRIO CARGO MUSICAL + NOME MANUAL:');
    const cargosTeste = ['M√∫sico', 'Organista', 'Examinadora', 'Instrutora'];
    cargosTeste.forEach(cargo => {
      const cargoUpper = cargo.toUpperCase();
      const isCargoMusical = cargoUpper.includes('M√öSICO') ||
                            cargoUpper.includes('ORGANISTA') ||
                            cargoUpper.includes('EXAMINADORA') ||
                            cargoUpper.includes('INSTRUTORA') ||
                            (cargo.toLowerCase().includes('secret√°ria') && cargo.toLowerCase().includes('m√∫sica'));
      
      console.log(`‚úÖ ${cargo}: ${isCargoMusical ? 'MUSICAL' : 'N√ÉO-MUSICAL'}`);
    });
    
    console.log('\nüìã 5. RESUMO:');
    console.log('‚úÖ Fun√ß√£o isNomeManual dispon√≠vel:', typeof window.isNomeManual === 'function');
    console.log('‚úÖ Campo nome principal encontrado:', !!document.querySelector('#nome'));
    console.log('‚úÖ Campo nome modal encontrado:', !!document.querySelector('#gsNome'));
    
    console.log('='.repeat(60));
    console.log('üß™ TESTE CONCLU√çDO');
    
    return {
      success: true,
      message: 'Teste de detec√ß√£o de nome manual conclu√≠do'
    };
  };
  
  // üß™ FUN√á√ÉO DE TESTE: Verificar problema online vs local
  window.testarProblemaOnline = function() {
    console.log('üß™ TESTE: Verifica√ß√£o do problema online vs local');
    console.log('='.repeat(60));
    
    // Simular dados de teste
    const dadosTeste = {
      nome: 'Jo√£o Silva Teste',
      cargo: 'M√∫sico',
      comum: 'Teste',
      anotacoes: 'SAM Desatualizado'
    };
    
    console.log('üìã 1. DADOS DE TESTE:', dadosTeste);
    
    // Teste 2: Verificar fun√ß√£o aplicarRegrasGenero
    console.log('\nüìã 2. TESTANDO aplicarRegrasGenero:');
    const dadosProcessados = aplicarRegrasGenero(dadosTeste);
    console.log('‚úÖ Dados processados:', dadosProcessados);
    console.log('‚úÖ Anota√ß√µes preservadas:', dadosProcessados.anotacoes);
    
    // Teste 3: Verificar fun√ß√£o padronizarDadosMaiuscula
    console.log('\nüìã 3. TESTANDO padronizarDadosMaiuscula:');
    const dadosPadronizados = padronizarDadosMaiuscula(dadosProcessados);
    console.log('‚úÖ Dados padronizados:', dadosPadronizados);
    console.log('‚úÖ Anota√ß√µes preservadas:', dadosPadronizados.anotacoes);
    
    // Teste 4: Simular constru√ß√£o do googleSheetsData
    console.log('\nüìã 4. SIMULANDO CONSTRU√á√ÉO DO GOOGLE SHEETS DATA:');
    const googleSheetsData = {
      "UUID": dadosPadronizados.uuid || dadosPadronizados.UUID || "",
      "NOME COMPLETO": dadosPadronizados.nome || dadosPadronizados.NOME || "",
      "COMUM": dadosPadronizados.comum || dadosPadronizados.COMUM || "",
      "CIDADE": dadosPadronizados.cidade || dadosPadronizados.CIDADE || dadosPadronizados.local || dadosPadronizados.LOCAL || "",
      "CARGO": dadosPadronizados.cargo || dadosPadronizados.CARGO || "",
      "INSTRUMENTO": dadosPadronizados.instrumento || dadosPadronizados.INSTRUMENTO || "",
      "NAIPE_INSTRUMENTO": dadosPadronizados.naipe || dadosPadronizados.NAIPE || dadosPadronizados.naipe_instrumento || dadosPadronizados.NAIPE_INSTRUMENTO || "",
      "CLASSE_ORGANISTA": dadosPadronizados.classe || dadosPadronizados.CLASSE || dadosPadronizados.nivel || dadosPadronizados.NIVEL || dadosPadronizados.classe_organista || dadosPadronizados.CLASSE_ORGANISTA || "",
      "LOCAL_ENSAIO": dadosPadronizados.local_ensaio || dadosPadronizados.LOCAL_ENSAIO || "",
      "DATA_ENSAIO": dadosPadronizados.data_ensaio || dadosPadronizados.DATA_ENSAIO || "",
      "HOR√ÅRIO": "12:00:00",
      "REGISTRADO_POR": "Sistema",
      "USER_ID": "",
      "ANOTACOES": dadosPadronizados.anotacoes || dadosPadronizados.ANOTACOES || "",
      "SYNC_STATUS": "ATUALIZADO"
    };
    
    console.log('‚úÖ Google Sheets Data:', googleSheetsData);
    console.log('‚úÖ ANOTACOES no Google Sheets:', googleSheetsData.ANOTACOES);
    
    // Teste 5: Verificar detec√ß√£o de aba
    console.log('\nüìã 5. TESTANDO DETEC√á√ÉO DE ABA:');
    const anotacoes = googleSheetsData.ANOTACOES || '';
    const sheetDestino = (anotacoes.toUpperCase().includes('SAM DESATUALIZADO')) 
      ? 'Anota√ß√µes' 
      : 'Dados';
    
    console.log('‚úÖ Anota√ß√µes:', anotacoes);
    console.log('‚úÖ Anota√ß√µes em mai√∫scula:', anotacoes.toUpperCase());
    console.log('‚úÖ Inclui SAM DESATUALIZADO:', anotacoes.toUpperCase().includes('SAM DESATUALIZADO'));
    console.log('‚úÖ Aba de destino:', sheetDestino);
    
    console.log('='.repeat(60));
    console.log('üß™ TESTE CONCLU√çDO');
    
    return {
      success: true,
      message: 'Teste do problema online conclu√≠do',
      dados: {
        original: dadosTeste,
        processados: dadosProcessados,
        padronizados: dadosPadronizados,
        googleSheets: googleSheetsData,
        sheetDestino: sheetDestino
      }
    };
  };
  
  // üß™ FUN√á√ÉO DE TESTE: Simular cen√°rio real de cargo musical + nome manual
  window.testarCenarioReal = function() {
    console.log('üß™ TESTE: Simula√ß√£o de cen√°rio real - cargo musical + nome manual');
    console.log('='.repeat(60));
    
    // Simular dados como se fossem coletados do formul√°rio
    const dadosFormulario = {
      nome: 'Maria Silva Teste',
      cargo: 'M√∫sico',
      comum: 'Teste Online',
      instrumento: '√ìRG√ÉO'
    };
    
    console.log('üìã 1. DADOS DO FORMUL√ÅRIO:', dadosFormulario);
    
    // Simular detec√ß√£o de nome manual
    const cargoUpper = dadosFormulario.cargo.toUpperCase();
    const isCargoMusical = cargoUpper.includes('M√öSICO') ||
                          cargoUpper.includes('ORGANISTA') ||
                          cargoUpper.includes('EXAMINADORA') ||
                          cargoUpper.includes('INSTRUTORA') ||
                          (dadosFormulario.cargo.toLowerCase().includes('secret√°ria') && dadosFormulario.cargo.toLowerCase().includes('m√∫sica'));
    
    console.log('üìã 2. DETEC√á√ÉO DE CARGO MUSICAL:', {
      cargo: dadosFormulario.cargo,
      cargoUpper: cargoUpper,
      isCargoMusical: isCargoMusical
    });
    
    // Simular detec√ß√£o de nome manual (for√ßada para online)
    let isNomeManual = false;
    // CORRE√á√ÉO CR√çTICA: REMOVIDA l√≥gica que for√ßava manual para cargos musicais
    // A detec√ß√£o deve ser baseada apenas nos atributos do campo, n√£o no cargo
    
    console.log('üìã 3. DETEC√á√ÉO DE NOME MANUAL:', {
      nome: dadosFormulario.nome,
      isNomeManual: isNomeManual
    });
    
    // Simular adi√ß√£o de anota√ß√£o
    let anotacoesFinal = '';
    if (isNomeManual && isCargoMusical) {
      anotacoesFinal = 'SAM Desatualizado';
      console.log('‚úÖ ANOTA√á√ÉO ADICIONADA:', anotacoesFinal);
    }
    
    console.log('üìã 4. ANOTA√á√ïES FINAIS:', {
      anotacoesFinal: anotacoesFinal,
      isNomeManual: isNomeManual,
      isCargoMusical: isCargoMusical
    });
    
    // Simular payload final
    const payloadFinal = {
      ...dadosFormulario,
      anotacoes: anotacoesFinal
    };
    
    console.log('üìã 5. PAYLOAD FINAL:', payloadFinal);
    
    console.log('='.repeat(60));
    console.log('üß™ TESTE CONCLU√çDO');
    
    return {
      success: true,
      message: 'Teste de cen√°rio real conclu√≠do',
      resultado: {
        dadosFormulario: dadosFormulario,
        isCargoMusical: isCargoMusical,
        isNomeManual: isNomeManual,
        anotacoesFinal: anotacoesFinal,
        payloadFinal: payloadFinal
      }
    };
  };
  
  // üß™ FUN√á√ÉO DE TESTE: Verificar ambiente e detec√ß√£o espec√≠fica para mobile online
  window.testarAmbienteMobile = function() {
    console.log('üß™ TESTE: Verifica√ß√£o de ambiente e detec√ß√£o para mobile online');
    console.log('='.repeat(60));
    
    // Verificar ambiente atual
    const ambiente = {
      protocol: window.location.protocol,
      hostname: window.location.hostname,
      isFileProtocol: isFileProtocol,
      isLocalhost: isLocalhost,
      isHTTPS: isHTTPS,
      isMobile: isMobile,
      isOnlineEnvironment: !isFileProtocol && !isLocalhost
    };
    
    console.log('üìã 1. AMBIENTE ATUAL:', ambiente);
    
    // Simular dados de teste para mobile
    const dadosTeste = {
      nome: 'Jo√£o Mobile Teste',
      cargo: 'M√∫sico',
      comum: 'Teste Mobile Online'
    };
    
    console.log('üìã 2. DADOS DE TESTE:', dadosTeste);
    
    // Simular detec√ß√£o de cargo musical
    const cargoUpper = dadosTeste.cargo.toUpperCase();
    const isCargoMusical = cargoUpper.includes('M√öSICO') ||
                          cargoUpper.includes('ORGANISTA') ||
                          cargoUpper.includes('EXAMINADORA') ||
                          cargoUpper.includes('INSTRUTORA') ||
                          (dadosTeste.cargo.toLowerCase().includes('secret√°ria') && dadosTeste.cargo.toLowerCase().includes('m√∫sica'));
    
    console.log('üìã 3. DETEC√á√ÉO DE CARGO MUSICAL:', {
      cargo: dadosTeste.cargo,
      isCargoMusical: isCargoMusical
    });
    
    // Simular detec√ß√£o de nome manual com corre√ß√µes espec√≠ficas
    let isNomeManual = false;
    
    // CORRE√á√ÉO CR√çTICA: REMOVIDA l√≥gica que for√ßava manual para cargos musicais
    // A detec√ß√£o deve ser baseada apenas nos atributos do campo, n√£o no cargo
    
    console.log('üìã 4. DETEC√á√ÉO DE NOME MANUAL:', {
      nome: dadosTeste.nome,
      isNomeManual: isNomeManual,
      correcoesAplicadas: {
        geral: dadosTeste.nome && dadosTeste.cargo && isCargoMusical,
        mobileOnline: ambiente.isOnlineEnvironment && ambiente.isMobile && dadosTeste.nome && dadosTeste.cargo && isCargoMusical
      }
    });
    
    // Simular adi√ß√£o de anota√ß√£o
    let anotacoesFinal = '';
    if (isNomeManual && isCargoMusical) {
      anotacoesFinal = 'SAM Desatualizado';
      console.log('‚úÖ ANOTA√á√ÉO ADICIONADA:', anotacoesFinal);
    }
    
    console.log('üìã 5. RESULTADO FINAL:', {
      anotacoesFinal: anotacoesFinal,
      isNomeManual: isNomeManual,
      isCargoMusical: isCargoMusical,
      ambiente: ambiente
    });
    
    console.log('='.repeat(60));
    console.log('üß™ TESTE CONCLU√çDO');
    
    return {
      success: true,
      message: 'Teste de ambiente mobile conclu√≠do',
      resultado: {
        ambiente: ambiente,
        dadosTeste: dadosTeste,
        isCargoMusical: isCargoMusical,
        isNomeManual: isNomeManual,
        anotacoesFinal: anotacoesFinal
      }
    };
  };
  
  // üß™ FUN√á√ÉO DE TESTE SIMPLES: Testar corre√ß√£o ultra-agressiva
  window.testarCorrecaoUltra = function() {
    console.log('üß™ TESTE: Verifica√ß√£o da corre√ß√£o ultra-agressiva');
    console.log('='.repeat(60));
    
    // Simular dados de teste
    const dadosTeste = {
      nome: 'Maria Silva Teste',
      cargo: 'M√∫sico',
      comum: 'Teste Online'
    };
    
    console.log('üìã 1. DADOS DE TESTE:', dadosTeste);
    
    // Simular detec√ß√£o de cargo musical (corre√ß√£o ultra-agressiva)
    const cargoUpper = dadosTeste.cargo ? dadosTeste.cargo.toUpperCase() : '';
    const isCargoMusicalUltra = cargoUpper.includes('M√öSICO') ||
                               cargoUpper.includes('ORGANISTA') ||
                               cargoUpper.includes('EXAMINADORA') ||
                               cargoUpper.includes('INSTRUTORA') ||
                               (dadosTeste.cargo && dadosTeste.cargo.toLowerCase().includes('secret√°ria') && dadosTeste.cargo.toLowerCase().includes('m√∫sica'));
    
    console.log('üìã 2. DETEC√á√ÉO ULTRA-AGRESIVA:', {
      cargo: dadosTeste.cargo,
      cargoUpper: cargoUpper,
      isCargoMusicalUltra: isCargoMusicalUltra
    });
    
    // Simular adi√ß√£o de anota√ß√£o (corre√ß√£o ultra-agressiva)
    let anotacoesFinal = '';
    if (isCargoMusicalUltra && dadosTeste.nome) {
      anotacoesFinal = 'SAM Desatualizado';
      console.log('‚úÖ ANOTA√á√ÉO ULTRA-AGRESIVA ADICIONADA:', anotacoesFinal);
    }
    
    console.log('üìã 3. RESULTADO FINAL:', {
      anotacoesFinal: anotacoesFinal,
      isCargoMusicalUltra: isCargoMusicalUltra,
      nome: dadosTeste.nome
    });
    
    console.log('='.repeat(60));
    console.log('üß™ TESTE CONCLU√çDO');
    
    return {
      success: true,
      message: 'Teste de corre√ß√£o ultra-agressiva conclu√≠do',
      resultado: {
        dadosTeste: dadosTeste,
        isCargoMusicalUltra: isCargoMusicalUltra,
        anotacoesFinal: anotacoesFinal
      }
    };
  };
   
   
   
   